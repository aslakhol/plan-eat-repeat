/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg@8.16.3";
exports.ids = ["vendor-chunks/pg@8.16.3"];
exports.modules = {

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/esm/index.mjs":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/esm/index.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   Connection: () => (/* binding */ Connection),\n/* harmony export */   DatabaseError: () => (/* binding */ DatabaseError),\n/* harmony export */   Pool: () => (/* binding */ Pool),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   TypeOverrides: () => (/* binding */ TypeOverrides),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   escapeIdentifier: () => (/* binding */ escapeIdentifier),\n/* harmony export */   escapeLiteral: () => (/* binding */ escapeLiteral),\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\n/* harmony import */ var _lib_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/index.js */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js\");\n// ESM wrapper for pg\n\n\n// Re-export all the properties\nconst Client = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.Client\nconst Pool = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.Pool\nconst Connection = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.Connection\nconst types = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.types\nconst Query = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.Query\nconst DatabaseError = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.DatabaseError\nconst escapeIdentifier = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.escapeIdentifier\nconst escapeLiteral = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.escapeLiteral\nconst Result = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.Result\nconst TypeOverrides = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.TypeOverrides\n\n// Also export the defaults\nconst defaults = _lib_index_js__WEBPACK_IMPORTED_MODULE_0__.defaults\n\n// Re-export the default\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNnQzs7QUFFaEM7QUFDTyxlQUFlLGlEQUFTO0FBQ3hCLGFBQWEsK0NBQU87QUFDcEIsbUJBQW1CLHFEQUFhO0FBQ2hDLGNBQWMsZ0RBQVE7QUFDdEIsY0FBYyxnREFBUTtBQUN0QixzQkFBc0Isd0RBQWdCO0FBQ3RDLHlCQUF5QiwyREFBbUI7QUFDNUMsc0JBQXNCLHdEQUFnQjtBQUN0QyxlQUFlLGlEQUFTO0FBQ3hCLHNCQUFzQix3REFBZ0I7O0FBRTdDO0FBQ08saUJBQWlCLG1EQUFXOztBQUVuQztBQUNBLGlFQUFlLDBDQUFFIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2VzbS9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRVNNIHdyYXBwZXIgZm9yIHBnXG5pbXBvcnQgcGcgZnJvbSAnLi4vbGliL2luZGV4LmpzJ1xuXG4vLyBSZS1leHBvcnQgYWxsIHRoZSBwcm9wZXJ0aWVzXG5leHBvcnQgY29uc3QgQ2xpZW50ID0gcGcuQ2xpZW50XG5leHBvcnQgY29uc3QgUG9vbCA9IHBnLlBvb2xcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uID0gcGcuQ29ubmVjdGlvblxuZXhwb3J0IGNvbnN0IHR5cGVzID0gcGcudHlwZXNcbmV4cG9ydCBjb25zdCBRdWVyeSA9IHBnLlF1ZXJ5XG5leHBvcnQgY29uc3QgRGF0YWJhc2VFcnJvciA9IHBnLkRhdGFiYXNlRXJyb3JcbmV4cG9ydCBjb25zdCBlc2NhcGVJZGVudGlmaWVyID0gcGcuZXNjYXBlSWRlbnRpZmllclxuZXhwb3J0IGNvbnN0IGVzY2FwZUxpdGVyYWwgPSBwZy5lc2NhcGVMaXRlcmFsXG5leHBvcnQgY29uc3QgUmVzdWx0ID0gcGcuUmVzdWx0XG5leHBvcnQgY29uc3QgVHlwZU92ZXJyaWRlcyA9IHBnLlR5cGVPdmVycmlkZXNcblxuLy8gQWxzbyBleHBvcnQgdGhlIGRlZmF1bHRzXG5leHBvcnQgY29uc3QgZGVmYXVsdHMgPSBwZy5kZWZhdWx0c1xuXG4vLyBSZS1leHBvcnQgdGhlIGRlZmF1bHRcbmV4cG9ydCBkZWZhdWx0IHBnXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/esm/index.mjs\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst utils = __webpack_require__(/*! ./utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\")\nconst sasl = __webpack_require__(/*! ./crypto/sasl */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js\")\nconst TypeOverrides = __webpack_require__(/*! ./type-overrides */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js\")\n\nconst ConnectionParameters = __webpack_require__(/*! ./connection-parameters */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js\")\nconst Query = __webpack_require__(/*! ./query */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js\")\nconst defaults = __webpack_require__(/*! ./defaults */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js\")\nconst Connection = __webpack_require__(/*! ./connection */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js\")\nconst crypto = __webpack_require__(/*! ./crypto/utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js\")\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super()\n\n    this.connectionParameters = new ConnectionParameters(config)\n    this.user = this.connectionParameters.user\n    this.database = this.connectionParameters.database\n    this.port = this.connectionParameters.port\n    this.host = this.connectionParameters.host\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password,\n    })\n\n    this.replication = this.connectionParameters.replication\n\n    const c = config || {}\n\n    this._Promise = c.Promise || global.Promise\n    this._types = new TypeOverrides(c.types)\n    this._ending = false\n    this._ended = false\n    this._connecting = false\n    this._connected = false\n    this._connectionError = false\n    this._queryable = true\n\n    this.enableChannelBinding = Boolean(c.enableChannelBinding) // set true to use SCRAM-SHA-256-PLUS when offered\n    this.connection =\n      c.connection ||\n      new Connection({\n        stream: c.stream,\n        ssl: this.connectionParameters.ssl,\n        keepAlive: c.keepAlive || false,\n        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n        encoding: this.connectionParameters.client_encoding || 'utf8',\n      })\n    this.queryQueue = []\n    this.binary = c.binary || defaults.binary\n    this.processID = null\n    this.secretKey = null\n    this.ssl = this.connectionParameters.ssl || false\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = (query) => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection)\n      })\n    }\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery)\n      this.activeQuery = null\n    }\n\n    this.queryQueue.forEach(enqueueError)\n    this.queryQueue.length = 0\n  }\n\n  _connect(callback) {\n    const self = this\n    const con = this.connection\n    this._connectionCallback = callback\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.')\n      process.nextTick(() => {\n        callback(err)\n      })\n      return\n    }\n    this._connecting = true\n\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true\n        con.stream.destroy(new Error('timeout expired'))\n      }, this._connectionTimeoutMillis)\n\n      if (this.connectionTimeoutHandle.unref) {\n        this.connectionTimeoutHandle.unref()\n      }\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl()\n      } else {\n        con.startup(self.getStartupConf())\n      }\n    })\n\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf())\n    })\n\n    this._attachListeners(con)\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n      clearTimeout(this.connectionTimeoutHandle)\n      this._errorAllQueries(error)\n      this._ended = true\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error)\n          } else {\n            this._handleErrorEvent(error)\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error)\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end')\n      })\n    })\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback)\n      return\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect((error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this))\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this))\n    con.on('error', this._handleErrorEvent.bind(this))\n    con.on('errorMessage', this._handleErrorMessage.bind(this))\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this))\n    con.on('notice', this._handleNotice.bind(this))\n    con.on('rowDescription', this._handleRowDescription.bind(this))\n    con.on('dataRow', this._handleDataRow.bind(this))\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this))\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this))\n    con.on('commandComplete', this._handleCommandComplete.bind(this))\n    con.on('parseComplete', this._handleParseComplete.bind(this))\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this))\n    con.on('copyData', this._handleCopyData.bind(this))\n    con.on('notification', this._handleNotification.bind(this))\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection\n    if (typeof this.password === 'function') {\n      this._Promise\n        .resolve()\n        .then(() => this.password())\n        .then((pass) => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'))\n              return\n            }\n            this.connectionParameters.password = this.password = pass\n          } else {\n            this.connectionParameters.password = this.password = null\n          }\n          cb()\n        })\n        .catch((err) => {\n          con.emit('error', err)\n        })\n    } else if (this.password !== null) {\n      cb()\n    } else {\n      try {\n        const pgPass = __webpack_require__(/*! pgpass */ \"(api-node)/../../node_modules/.pnpm/pgpass@1.0.5/node_modules/pgpass/lib/index.js\")\n        pgPass(this.connectionParameters, (pass) => {\n          if (undefined !== pass) {\n            this.connectionParameters.password = this.password = pass\n          }\n          cb()\n        })\n      } catch (e) {\n        this.emit('error', e)\n      }\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password)\n    })\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(async () => {\n      try {\n        const hashedPassword = await crypto.postgresMd5PasswordHash(this.user, this.password, msg.salt)\n        this.connection.password(hashedPassword)\n      } catch (e) {\n        this.emit('error', e)\n      }\n    })\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      try {\n        this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream)\n        this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)\n      } catch (err) {\n        this.connection.emit('error', err)\n      }\n    })\n  }\n\n  async _handleAuthSASLContinue(msg) {\n    try {\n      await sasl.continueSession(\n        this.saslSession,\n        this.password,\n        msg.data,\n        this.enableChannelBinding && this.connection.stream\n      )\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleAuthSASLFinal(msg) {\n    try {\n      sasl.finalizeSession(this.saslSession, msg.data)\n      this.saslSession = null\n    } catch (err) {\n      this.connection.emit('error', err)\n    }\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID\n    this.secretKey = msg.secretKey\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false\n      this._connected = true\n      clearTimeout(this.connectionTimeoutHandle)\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this)\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null\n      }\n      this.emit('connect')\n    }\n    const { activeQuery } = this\n    this.activeQuery = null\n    this.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection)\n    }\n    this._pulseQueryQueue()\n  }\n\n  // if we receive an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return\n    }\n    this._connectionError = true\n    clearTimeout(this.connectionTimeoutHandle)\n    if (this._connectionCallback) {\n      return this._connectionCallback(err)\n    }\n    this.emit('error', err)\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err)\n    }\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg)\n    }\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, this.connection)\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg)\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg)\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection)\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection)\n  }\n\n  _handleCommandComplete(msg) {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected commandComplete message from backend.')\n      this._handleErrorEvent(error)\n      return\n    }\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection)\n  }\n\n  _handleParseComplete() {\n    if (this.activeQuery == null) {\n      const error = new Error('Received unexpected parseComplete message from backend.')\n      this._handleErrorEvent(error)\n      return\n    }\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection)\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection)\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg)\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg)\n  }\n\n  getStartupConf() {\n    const params = this.connectionParameters\n\n    const data = {\n      user: params.user,\n      database: params.database,\n    }\n\n    const appName = params.application_name || params.fallback_application_name\n    if (appName) {\n      data.application_name = appName\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n    }\n    if (params.lock_timeout) {\n      data.lock_timeout = String(parseInt(params.lock_timeout, 10))\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n    }\n    if (params.options) {\n      data.options = params.options\n    }\n\n    return data\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      const con = this.connection\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port)\n      } else {\n        con.connect(this.port, this.host)\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey)\n      })\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn)\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format)\n  }\n\n  // escapeIdentifier and escapeLiteral moved to utility functions & exported\n  // on PG\n  // re-exported here for backwards compatibility\n  escapeIdentifier(str) {\n    return utils.escapeIdentifier(str)\n  }\n\n  escapeLiteral(str) {\n    return utils.escapeLiteral(str)\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift()\n      if (this.activeQuery) {\n        this.readyForQuery = false\n        this.hasExecuted = true\n\n        const queryError = this.activeQuery.submit(this.connection)\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection)\n            this.readyForQuery = true\n            this._pulseQueryQueue()\n          })\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null\n        this.emit('drain')\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    let query\n    let result\n    let readTimeout\n    let readTimeoutTimer\n    let queryCallback\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query')\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      result = query = config\n      if (typeof values === 'function') {\n        query.callback = query.callback || values\n      }\n    } else {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      query = new Query(config, values, callback)\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => (err ? reject(err) : resolve(res))\n        }).catch((err) => {\n          // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n          // application that created the query\n          Error.captureStackTrace(err)\n          throw err\n        })\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback\n\n      readTimeoutTimer = setTimeout(() => {\n        const error = new Error('Query read timeout')\n\n        process.nextTick(() => {\n          query.handleError(error, this.connection)\n        })\n\n        queryCallback(error)\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {}\n\n        // Remove from queue\n        const index = this.queryQueue.indexOf(query)\n        if (index > -1) {\n          this.queryQueue.splice(index, 1)\n        }\n\n        this._pulseQueryQueue()\n      }, readTimeout)\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer)\n        queryCallback(err, res)\n      }\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    this.queryQueue.push(query)\n    this._pulseQueryQueue()\n    return result\n  }\n\n  ref() {\n    this.connection.ref()\n  }\n\n  unref() {\n    this.connection.unref()\n  }\n\n  end(cb) {\n    this._ending = true\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting || this._ended) {\n      if (cb) {\n        cb()\n      } else {\n        return this._Promise.resolve()\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy()\n    } else {\n      this.connection.end()\n    }\n\n    if (cb) {\n      this.connection.once('end', cb)\n    } else {\n      return new this._Promise((resolve) => {\n        this.connection.once('end', resolve)\n      })\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHFCQUFxQiwwREFBOEI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDJGQUFTO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyx1R0FBZTtBQUNwQyxzQkFBc0IsbUJBQU8sQ0FBQyw2R0FBa0I7O0FBRWhELDZCQUE2QixtQkFBTyxDQUFDLDJIQUF5QjtBQUM5RCxjQUFjLG1CQUFPLENBQUMsMkZBQVM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsaUdBQVk7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMscUdBQWM7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHlHQUFnQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsaUdBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBzYXNsID0gcmVxdWlyZSgnLi9jcnlwdG8vc2FzbCcpXG5jb25zdCBUeXBlT3ZlcnJpZGVzID0gcmVxdWlyZSgnLi90eXBlLW92ZXJyaWRlcycpXG5cbmNvbnN0IENvbm5lY3Rpb25QYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uLXBhcmFtZXRlcnMnKVxuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5JylcbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvL3V0aWxzJylcblxuY2xhc3MgQ2xpZW50IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycyA9IG5ldyBDb25uZWN0aW9uUGFyYW1ldGVycyhjb25maWcpXG4gICAgdGhpcy51c2VyID0gdGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycy51c2VyXG4gICAgdGhpcy5kYXRhYmFzZSA9IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMuZGF0YWJhc2VcbiAgICB0aGlzLnBvcnQgPSB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLnBvcnRcbiAgICB0aGlzLmhvc3QgPSB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLmhvc3RcblxuICAgIC8vIFwiaGlkaW5nXCIgdGhlIHBhc3N3b3JkIHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXNzd29yZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycy5wYXNzd29yZCxcbiAgICB9KVxuXG4gICAgdGhpcy5yZXBsaWNhdGlvbiA9IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMucmVwbGljYXRpb25cblxuICAgIGNvbnN0IGMgPSBjb25maWcgfHwge31cblxuICAgIHRoaXMuX1Byb21pc2UgPSBjLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2VcbiAgICB0aGlzLl90eXBlcyA9IG5ldyBUeXBlT3ZlcnJpZGVzKGMudHlwZXMpXG4gICAgdGhpcy5fZW5kaW5nID0gZmFsc2VcbiAgICB0aGlzLl9lbmRlZCA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLl9jb25uZWN0aW9uRXJyb3IgPSBmYWxzZVxuICAgIHRoaXMuX3F1ZXJ5YWJsZSA9IHRydWVcblxuICAgIHRoaXMuZW5hYmxlQ2hhbm5lbEJpbmRpbmcgPSBCb29sZWFuKGMuZW5hYmxlQ2hhbm5lbEJpbmRpbmcpIC8vIHNldCB0cnVlIHRvIHVzZSBTQ1JBTS1TSEEtMjU2LVBMVVMgd2hlbiBvZmZlcmVkXG4gICAgdGhpcy5jb25uZWN0aW9uID1cbiAgICAgIGMuY29ubmVjdGlvbiB8fFxuICAgICAgbmV3IENvbm5lY3Rpb24oe1xuICAgICAgICBzdHJlYW06IGMuc3RyZWFtLFxuICAgICAgICBzc2w6IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMuc3NsLFxuICAgICAgICBrZWVwQWxpdmU6IGMua2VlcEFsaXZlIHx8IGZhbHNlLFxuICAgICAgICBrZWVwQWxpdmVJbml0aWFsRGVsYXlNaWxsaXM6IGMua2VlcEFsaXZlSW5pdGlhbERlbGF5TWlsbGlzIHx8IDAsXG4gICAgICAgIGVuY29kaW5nOiB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLmNsaWVudF9lbmNvZGluZyB8fCAndXRmOCcsXG4gICAgICB9KVxuICAgIHRoaXMucXVlcnlRdWV1ZSA9IFtdXG4gICAgdGhpcy5iaW5hcnkgPSBjLmJpbmFyeSB8fCBkZWZhdWx0cy5iaW5hcnlcbiAgICB0aGlzLnByb2Nlc3NJRCA9IG51bGxcbiAgICB0aGlzLnNlY3JldEtleSA9IG51bGxcbiAgICB0aGlzLnNzbCA9IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMuc3NsIHx8IGZhbHNlXG4gICAgLy8gQXMgd2l0aCBQYXNzd29yZCwgbWFrZSBTU0wtPktleSAodGhlIHByaXZhdGUga2V5KSBub24tZW51bWVyYWJsZS5cbiAgICAvLyBJdCB3b24ndCBzaG93IHVwIGluIHN0YWNrIHRyYWNlc1xuICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICBpZiAodGhpcy5zc2wgJiYgdGhpcy5zc2wua2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zc2wsICdrZXknLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uVGltZW91dE1pbGxpcyA9IGMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMgfHwgMFxuICB9XG5cbiAgX2Vycm9yQWxsUXVlcmllcyhlcnIpIHtcbiAgICBjb25zdCBlbnF1ZXVlRXJyb3IgPSAocXVlcnkpID0+IHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBxdWVyeS5oYW5kbGVFcnJvcihlcnIsIHRoaXMuY29ubmVjdGlvbilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUXVlcnkpIHtcbiAgICAgIGVucXVldWVFcnJvcih0aGlzLmFjdGl2ZVF1ZXJ5KVxuICAgICAgdGhpcy5hY3RpdmVRdWVyeSA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLnF1ZXJ5UXVldWUuZm9yRWFjaChlbnF1ZXVlRXJyb3IpXG4gICAgdGhpcy5xdWVyeVF1ZXVlLmxlbmd0aCA9IDBcbiAgfVxuXG4gIF9jb25uZWN0KGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBjb24gPSB0aGlzLmNvbm5lY3Rpb25cbiAgICB0aGlzLl9jb25uZWN0aW9uQ2FsbGJhY2sgPSBjYWxsYmFja1xuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RpbmcgfHwgdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0NsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGNvbm5lY3RlZC4gWW91IGNhbm5vdCByZXVzZSBhIGNsaWVudC4nKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWVcblxuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uVGltZW91dE1pbGxpcyA+IDApIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uLl9lbmRpbmcgPSB0cnVlXG4gICAgICAgIGNvbi5zdHJlYW0uZGVzdHJveShuZXcgRXJyb3IoJ3RpbWVvdXQgZXhwaXJlZCcpKVxuICAgICAgfSwgdGhpcy5fY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpXG5cbiAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUudW5yZWYoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3QgJiYgdGhpcy5ob3N0LmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgY29uLmNvbm5lY3QodGhpcy5ob3N0ICsgJy8ucy5QR1NRTC4nICsgdGhpcy5wb3J0KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb24uY29ubmVjdCh0aGlzLnBvcnQsIHRoaXMuaG9zdClcbiAgICB9XG5cbiAgICAvLyBvbmNlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgc2VuZCBzdGFydHVwIG1lc3NhZ2VcbiAgICBjb24ub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zc2wpIHtcbiAgICAgICAgY29uLnJlcXVlc3RTc2woKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uLnN0YXJ0dXAoc2VsZi5nZXRTdGFydHVwQ29uZigpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb24ub24oJ3NzbGNvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb24uc3RhcnR1cChzZWxmLmdldFN0YXJ0dXBDb25mKCkpXG4gICAgfSlcblxuICAgIHRoaXMuX2F0dGFjaExpc3RlbmVycyhjb24pXG5cbiAgICBjb24ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9lbmRpbmcgPyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGVybWluYXRlZCcpIDogbmV3IEVycm9yKCdDb25uZWN0aW9uIHRlcm1pbmF0ZWQgdW5leHBlY3RlZGx5JylcblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUpXG4gICAgICB0aGlzLl9lcnJvckFsbFF1ZXJpZXMoZXJyb3IpXG4gICAgICB0aGlzLl9lbmRlZCA9IHRydWVcblxuICAgICAgaWYgKCF0aGlzLl9lbmRpbmcpIHtcbiAgICAgICAgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgZW5kZWQgd2l0aG91dCB1cyBjYWxsaW5nIC5lbmQoKVxuICAgICAgICAvLyBvbiB0aGlzIGNsaWVudCB0aGVuIHdlIGhhdmUgYW4gdW5leHBlY3RlZCBkaXNjb25uZWN0aW9uXG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgYW4gZXJyb3IgdW5sZXNzIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCBhbiBlcnJvclxuICAgICAgICAvLyBkdXJpbmcgY29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RpbmcgJiYgIXRoaXMuX2Nvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25DYWxsYmFjayhlcnJvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3JFdmVudChlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2Nvbm5lY3Rpb25FcnJvcikge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yRXZlbnQoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGNvbm5lY3QoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3QoY2FsbGJhY2spXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdCgoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBfYXR0YWNoTGlzdGVuZXJzKGNvbikge1xuICAgIC8vIHBhc3N3b3JkIHJlcXVlc3QgaGFuZGxpbmdcbiAgICBjb24ub24oJ2F1dGhlbnRpY2F0aW9uQ2xlYXJ0ZXh0UGFzc3dvcmQnLCB0aGlzLl9oYW5kbGVBdXRoQ2xlYXJ0ZXh0UGFzc3dvcmQuYmluZCh0aGlzKSlcbiAgICAvLyBwYXNzd29yZCByZXF1ZXN0IGhhbmRsaW5nXG4gICAgY29uLm9uKCdhdXRoZW50aWNhdGlvbk1ENVBhc3N3b3JkJywgdGhpcy5faGFuZGxlQXV0aE1ENVBhc3N3b3JkLmJpbmQodGhpcykpXG4gICAgLy8gcGFzc3dvcmQgcmVxdWVzdCBoYW5kbGluZyAoU0FTTClcbiAgICBjb24ub24oJ2F1dGhlbnRpY2F0aW9uU0FTTCcsIHRoaXMuX2hhbmRsZUF1dGhTQVNMLmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdhdXRoZW50aWNhdGlvblNBU0xDb250aW51ZScsIHRoaXMuX2hhbmRsZUF1dGhTQVNMQ29udGludWUuYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ2F1dGhlbnRpY2F0aW9uU0FTTEZpbmFsJywgdGhpcy5faGFuZGxlQXV0aFNBU0xGaW5hbC5iaW5kKHRoaXMpKVxuICAgIGNvbi5vbignYmFja2VuZEtleURhdGEnLCB0aGlzLl9oYW5kbGVCYWNrZW5kS2V5RGF0YS5iaW5kKHRoaXMpKVxuICAgIGNvbi5vbignZXJyb3InLCB0aGlzLl9oYW5kbGVFcnJvckV2ZW50LmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdlcnJvck1lc3NhZ2UnLCB0aGlzLl9oYW5kbGVFcnJvck1lc3NhZ2UuYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ3JlYWR5Rm9yUXVlcnknLCB0aGlzLl9oYW5kbGVSZWFkeUZvclF1ZXJ5LmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdub3RpY2UnLCB0aGlzLl9oYW5kbGVOb3RpY2UuYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ3Jvd0Rlc2NyaXB0aW9uJywgdGhpcy5faGFuZGxlUm93RGVzY3JpcHRpb24uYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ2RhdGFSb3cnLCB0aGlzLl9oYW5kbGVEYXRhUm93LmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdwb3J0YWxTdXNwZW5kZWQnLCB0aGlzLl9oYW5kbGVQb3J0YWxTdXNwZW5kZWQuYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ2VtcHR5UXVlcnknLCB0aGlzLl9oYW5kbGVFbXB0eVF1ZXJ5LmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdjb21tYW5kQ29tcGxldGUnLCB0aGlzLl9oYW5kbGVDb21tYW5kQ29tcGxldGUuYmluZCh0aGlzKSlcbiAgICBjb24ub24oJ3BhcnNlQ29tcGxldGUnLCB0aGlzLl9oYW5kbGVQYXJzZUNvbXBsZXRlLmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdjb3B5SW5SZXNwb25zZScsIHRoaXMuX2hhbmRsZUNvcHlJblJlc3BvbnNlLmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdjb3B5RGF0YScsIHRoaXMuX2hhbmRsZUNvcHlEYXRhLmJpbmQodGhpcykpXG4gICAgY29uLm9uKCdub3RpZmljYXRpb24nLCB0aGlzLl9oYW5kbGVOb3RpZmljYXRpb24uYmluZCh0aGlzKSlcbiAgfVxuXG4gIC8vIFRPRE8oYm1jKTogZGVwcmVjYXRlIHBncGFzcyBcImJ1aWx0IGluXCIgaW50ZWdyYXRpb24gc2luY2UgdGhpcy5wYXNzd29yZCBjYW4gYmUgYSBmdW5jdGlvblxuICAvLyBpdCBjYW4gYmUgc3VwcGxpZWQgYnkgdGhlIHVzZXIgaWYgcmVxdWlyZWQgLSB0aGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlIVxuICBfY2hlY2tQZ1Bhc3MoY2IpIHtcbiAgICBjb25zdCBjb24gPSB0aGlzLmNvbm5lY3Rpb25cbiAgICBpZiAodHlwZW9mIHRoaXMucGFzc3dvcmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX1Byb21pc2VcbiAgICAgICAgLnJlc29sdmUoKVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLnBhc3N3b3JkKCkpXG4gICAgICAgIC50aGVuKChwYXNzKSA9PiB7XG4gICAgICAgICAgaWYgKHBhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXNzICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb24uZW1pdCgnZXJyb3InLCBuZXcgVHlwZUVycm9yKCdQYXNzd29yZCBtdXN0IGJlIGEgc3RyaW5nJykpXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycy5wYXNzd29yZCA9IHRoaXMucGFzc3dvcmQgPSBwYXNzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMucGFzc3dvcmQgPSB0aGlzLnBhc3N3b3JkID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBjYigpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgICB9KVxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXNzd29yZCAhPT0gbnVsbCkge1xuICAgICAgY2IoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwZ1Bhc3MgPSByZXF1aXJlKCdwZ3Bhc3MnKVxuICAgICAgICBwZ1Bhc3ModGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycywgKHBhc3MpID0+IHtcbiAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBwYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLnBhc3N3b3JkID0gdGhpcy5wYXNzd29yZCA9IHBhc3NcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfaGFuZGxlQXV0aENsZWFydGV4dFBhc3N3b3JkKG1zZykge1xuICAgIHRoaXMuX2NoZWNrUGdQYXNzKCgpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5wYXNzd29yZCh0aGlzLnBhc3N3b3JkKVxuICAgIH0pXG4gIH1cblxuICBfaGFuZGxlQXV0aE1ENVBhc3N3b3JkKG1zZykge1xuICAgIHRoaXMuX2NoZWNrUGdQYXNzKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gYXdhaXQgY3J5cHRvLnBvc3RncmVzTWQ1UGFzc3dvcmRIYXNoKHRoaXMudXNlciwgdGhpcy5wYXNzd29yZCwgbXNnLnNhbHQpXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5wYXNzd29yZChoYXNoZWRQYXNzd29yZClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF9oYW5kbGVBdXRoU0FTTChtc2cpIHtcbiAgICB0aGlzLl9jaGVja1BnUGFzcygoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNhc2xTZXNzaW9uID0gc2FzbC5zdGFydFNlc3Npb24obXNnLm1lY2hhbmlzbXMsIHRoaXMuZW5hYmxlQ2hhbm5lbEJpbmRpbmcgJiYgdGhpcy5jb25uZWN0aW9uLnN0cmVhbSlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmRTQVNMSW5pdGlhbFJlc3BvbnNlTWVzc2FnZSh0aGlzLnNhc2xTZXNzaW9uLm1lY2hhbmlzbSwgdGhpcy5zYXNsU2Vzc2lvbi5yZXNwb25zZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIF9oYW5kbGVBdXRoU0FTTENvbnRpbnVlKG1zZykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzYXNsLmNvbnRpbnVlU2Vzc2lvbihcbiAgICAgICAgdGhpcy5zYXNsU2Vzc2lvbixcbiAgICAgICAgdGhpcy5wYXNzd29yZCxcbiAgICAgICAgbXNnLmRhdGEsXG4gICAgICAgIHRoaXMuZW5hYmxlQ2hhbm5lbEJpbmRpbmcgJiYgdGhpcy5jb25uZWN0aW9uLnN0cmVhbVxuICAgICAgKVxuICAgICAgdGhpcy5jb25uZWN0aW9uLnNlbmRTQ1JBTUNsaWVudEZpbmFsTWVzc2FnZSh0aGlzLnNhc2xTZXNzaW9uLnJlc3BvbnNlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVBdXRoU0FTTEZpbmFsKG1zZykge1xuICAgIHRyeSB7XG4gICAgICBzYXNsLmZpbmFsaXplU2Vzc2lvbih0aGlzLnNhc2xTZXNzaW9uLCBtc2cuZGF0YSlcbiAgICAgIHRoaXMuc2FzbFNlc3Npb24gPSBudWxsXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24uZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJhY2tlbmRLZXlEYXRhKG1zZykge1xuICAgIHRoaXMucHJvY2Vzc0lEID0gbXNnLnByb2Nlc3NJRFxuICAgIHRoaXMuc2VjcmV0S2V5ID0gbXNnLnNlY3JldEtleVxuICB9XG5cbiAgX2hhbmRsZVJlYWR5Rm9yUXVlcnkobXNnKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RpbmcpIHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUpXG5cbiAgICAgIC8vIHByb2Nlc3MgcG9zc2libGUgY2FsbGJhY2sgYXJndW1lbnQgdG8gQ2xpZW50I2Nvbm5lY3RcbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkNhbGxiYWNrKG51bGwsIHRoaXMpXG4gICAgICAgIC8vIHJlbW92ZSBjYWxsYmFjayBmb3IgcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIC8vIGFmdGVyIHRoZSBjb25uZWN0IGV2ZW50XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25DYWxsYmFjayA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpXG4gICAgfVxuICAgIGNvbnN0IHsgYWN0aXZlUXVlcnkgfSA9IHRoaXNcbiAgICB0aGlzLmFjdGl2ZVF1ZXJ5ID0gbnVsbFxuICAgIHRoaXMucmVhZHlGb3JRdWVyeSA9IHRydWVcbiAgICBpZiAoYWN0aXZlUXVlcnkpIHtcbiAgICAgIGFjdGl2ZVF1ZXJ5LmhhbmRsZVJlYWR5Rm9yUXVlcnkodGhpcy5jb25uZWN0aW9uKVxuICAgIH1cbiAgICB0aGlzLl9wdWxzZVF1ZXJ5UXVldWUoKVxuICB9XG5cbiAgLy8gaWYgd2UgcmVjZWl2ZSBhbiBlcnJvciBldmVudCBvciBlcnJvciBtZXNzYWdlXG4gIC8vIGR1cmluZyB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIHdlIGhhbmRsZSBpdCBoZXJlXG4gIF9oYW5kbGVFcnJvcldoaWxlQ29ubmVjdGluZyhlcnIpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAvLyBUT0RPKGJtYyk6IHRoaXMgaXMgc3dhbGxvd2luZyBlcnJvcnMgLSB3ZSBzaG91bGRuJ3QgZG8gdGhpc1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3Rpb25FcnJvciA9IHRydWVcbiAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSlcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvbkNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbkNhbGxiYWNrKGVycilcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIC8vIGlmIHdlJ3JlIGNvbm5lY3RlZCBhbmQgd2UgcmVjZWl2ZSBhbiBlcnJvciBldmVudCBmcm9tIHRoZSBjb25uZWN0aW9uXG4gIC8vIHRoaXMgbWVhbnMgdGhlIHNvY2tldCBpcyBkZWFkIC0gZG8gYSBoYXJkIGFib3J0IG9mIGFsbCBxdWVyaWVzIGFuZCBlbWl0XG4gIC8vIHRoZSBzb2NrZXQgZXJyb3Igb24gdGhlIGNsaWVudCBhcyB3ZWxsXG4gIF9oYW5kbGVFcnJvckV2ZW50KGVycikge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlRXJyb3JXaGlsZUNvbm5lY3RpbmcoZXJyKVxuICAgIH1cbiAgICB0aGlzLl9xdWVyeWFibGUgPSBmYWxzZVxuICAgIHRoaXMuX2Vycm9yQWxsUXVlcmllcyhlcnIpXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG4gIC8vIGhhbmRsZSBlcnJvciBtZXNzYWdlcyBmcm9tIHRoZSBwb3N0Z3JlcyBiYWNrZW5kXG4gIF9oYW5kbGVFcnJvck1lc3NhZ2UobXNnKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFcnJvcldoaWxlQ29ubmVjdGluZyhtc2cpXG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVF1ZXJ5ID0gdGhpcy5hY3RpdmVRdWVyeVxuXG4gICAgaWYgKCFhY3RpdmVRdWVyeSkge1xuICAgICAgdGhpcy5faGFuZGxlRXJyb3JFdmVudChtc2cpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmFjdGl2ZVF1ZXJ5ID0gbnVsbFxuICAgIGFjdGl2ZVF1ZXJ5LmhhbmRsZUVycm9yKG1zZywgdGhpcy5jb25uZWN0aW9uKVxuICB9XG5cbiAgX2hhbmRsZVJvd0Rlc2NyaXB0aW9uKG1zZykge1xuICAgIC8vIGRlbGVnYXRlIHJvd0Rlc2NyaXB0aW9uIHRvIGFjdGl2ZSBxdWVyeVxuICAgIHRoaXMuYWN0aXZlUXVlcnkuaGFuZGxlUm93RGVzY3JpcHRpb24obXNnKVxuICB9XG5cbiAgX2hhbmRsZURhdGFSb3cobXNnKSB7XG4gICAgLy8gZGVsZWdhdGUgZGF0YVJvdyB0byBhY3RpdmUgcXVlcnlcbiAgICB0aGlzLmFjdGl2ZVF1ZXJ5LmhhbmRsZURhdGFSb3cobXNnKVxuICB9XG5cbiAgX2hhbmRsZVBvcnRhbFN1c3BlbmRlZChtc2cpIHtcbiAgICAvLyBkZWxlZ2F0ZSBwb3J0YWxTdXNwZW5kZWQgdG8gYWN0aXZlIHF1ZXJ5XG4gICAgdGhpcy5hY3RpdmVRdWVyeS5oYW5kbGVQb3J0YWxTdXNwZW5kZWQodGhpcy5jb25uZWN0aW9uKVxuICB9XG5cbiAgX2hhbmRsZUVtcHR5UXVlcnkobXNnKSB7XG4gICAgLy8gZGVsZWdhdGUgZW1wdHlRdWVyeSB0byBhY3RpdmUgcXVlcnlcbiAgICB0aGlzLmFjdGl2ZVF1ZXJ5LmhhbmRsZUVtcHR5UXVlcnkodGhpcy5jb25uZWN0aW9uKVxuICB9XG5cbiAgX2hhbmRsZUNvbW1hbmRDb21wbGV0ZShtc2cpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVRdWVyeSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignUmVjZWl2ZWQgdW5leHBlY3RlZCBjb21tYW5kQ29tcGxldGUgbWVzc2FnZSBmcm9tIGJhY2tlbmQuJylcbiAgICAgIHRoaXMuX2hhbmRsZUVycm9yRXZlbnQoZXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gZGVsZWdhdGUgY29tbWFuZENvbXBsZXRlIHRvIGFjdGl2ZSBxdWVyeVxuICAgIHRoaXMuYWN0aXZlUXVlcnkuaGFuZGxlQ29tbWFuZENvbXBsZXRlKG1zZywgdGhpcy5jb25uZWN0aW9uKVxuICB9XG5cbiAgX2hhbmRsZVBhcnNlQ29tcGxldGUoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUXVlcnkgPT0gbnVsbCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1JlY2VpdmVkIHVuZXhwZWN0ZWQgcGFyc2VDb21wbGV0ZSBtZXNzYWdlIGZyb20gYmFja2VuZC4nKVxuICAgICAgdGhpcy5faGFuZGxlRXJyb3JFdmVudChlcnJvcilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBpZiBhIHByZXBhcmVkIHN0YXRlbWVudCBoYXMgYSBuYW1lIGFuZCBwcm9wZXJseSBwYXJzZXNcbiAgICAvLyB3ZSB0cmFjayB0aGF0IGl0cyBhbHJlYWR5IGJlZW4gZXhlY3V0ZWQgc28gd2UgZG9uJ3QgcGFyc2VcbiAgICAvLyBpdCBhZ2FpbiBvbiB0aGUgc2FtZSBjbGllbnRcbiAgICBpZiAodGhpcy5hY3RpdmVRdWVyeS5uYW1lKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24ucGFyc2VkU3RhdGVtZW50c1t0aGlzLmFjdGl2ZVF1ZXJ5Lm5hbWVdID0gdGhpcy5hY3RpdmVRdWVyeS50ZXh0XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUNvcHlJblJlc3BvbnNlKG1zZykge1xuICAgIHRoaXMuYWN0aXZlUXVlcnkuaGFuZGxlQ29weUluUmVzcG9uc2UodGhpcy5jb25uZWN0aW9uKVxuICB9XG5cbiAgX2hhbmRsZUNvcHlEYXRhKG1zZykge1xuICAgIHRoaXMuYWN0aXZlUXVlcnkuaGFuZGxlQ29weURhdGEobXNnLCB0aGlzLmNvbm5lY3Rpb24pXG4gIH1cblxuICBfaGFuZGxlTm90aWZpY2F0aW9uKG1zZykge1xuICAgIHRoaXMuZW1pdCgnbm90aWZpY2F0aW9uJywgbXNnKVxuICB9XG5cbiAgX2hhbmRsZU5vdGljZShtc2cpIHtcbiAgICB0aGlzLmVtaXQoJ25vdGljZScsIG1zZylcbiAgfVxuXG4gIGdldFN0YXJ0dXBDb25mKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnNcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICB1c2VyOiBwYXJhbXMudXNlcixcbiAgICAgIGRhdGFiYXNlOiBwYXJhbXMuZGF0YWJhc2UsXG4gICAgfVxuXG4gICAgY29uc3QgYXBwTmFtZSA9IHBhcmFtcy5hcHBsaWNhdGlvbl9uYW1lIHx8IHBhcmFtcy5mYWxsYmFja19hcHBsaWNhdGlvbl9uYW1lXG4gICAgaWYgKGFwcE5hbWUpIHtcbiAgICAgIGRhdGEuYXBwbGljYXRpb25fbmFtZSA9IGFwcE5hbWVcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5yZXBsaWNhdGlvbikge1xuICAgICAgZGF0YS5yZXBsaWNhdGlvbiA9ICcnICsgcGFyYW1zLnJlcGxpY2F0aW9uXG4gICAgfVxuICAgIGlmIChwYXJhbXMuc3RhdGVtZW50X3RpbWVvdXQpIHtcbiAgICAgIGRhdGEuc3RhdGVtZW50X3RpbWVvdXQgPSBTdHJpbmcocGFyc2VJbnQocGFyYW1zLnN0YXRlbWVudF90aW1lb3V0LCAxMCkpXG4gICAgfVxuICAgIGlmIChwYXJhbXMubG9ja190aW1lb3V0KSB7XG4gICAgICBkYXRhLmxvY2tfdGltZW91dCA9IFN0cmluZyhwYXJzZUludChwYXJhbXMubG9ja190aW1lb3V0LCAxMCkpXG4gICAgfVxuICAgIGlmIChwYXJhbXMuaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXQpIHtcbiAgICAgIGRhdGEuaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXQgPSBTdHJpbmcocGFyc2VJbnQocGFyYW1zLmlkbGVfaW5fdHJhbnNhY3Rpb25fc2Vzc2lvbl90aW1lb3V0LCAxMCkpXG4gICAgfVxuICAgIGlmIChwYXJhbXMub3B0aW9ucykge1xuICAgICAgZGF0YS5vcHRpb25zID0gcGFyYW1zLm9wdGlvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgY2FuY2VsKGNsaWVudCwgcXVlcnkpIHtcbiAgICBpZiAoY2xpZW50LmFjdGl2ZVF1ZXJ5ID09PSBxdWVyeSkge1xuICAgICAgY29uc3QgY29uID0gdGhpcy5jb25uZWN0aW9uXG5cbiAgICAgIGlmICh0aGlzLmhvc3QgJiYgdGhpcy5ob3N0LmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICBjb24uY29ubmVjdCh0aGlzLmhvc3QgKyAnLy5zLlBHU1FMLicgKyB0aGlzLnBvcnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb24uY29ubmVjdCh0aGlzLnBvcnQsIHRoaXMuaG9zdClcbiAgICAgIH1cblxuICAgICAgLy8gb25jZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkIHNlbmQgY2FuY2VsIG1lc3NhZ2VcbiAgICAgIGNvbi5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uLmNhbmNlbChjbGllbnQucHJvY2Vzc0lELCBjbGllbnQuc2VjcmV0S2V5KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNsaWVudC5xdWVyeVF1ZXVlLmluZGV4T2YocXVlcnkpICE9PSAtMSkge1xuICAgICAgY2xpZW50LnF1ZXJ5UXVldWUuc3BsaWNlKGNsaWVudC5xdWVyeVF1ZXVlLmluZGV4T2YocXVlcnkpLCAxKVxuICAgIH1cbiAgfVxuXG4gIHNldFR5cGVQYXJzZXIob2lkLCBmb3JtYXQsIHBhcnNlRm4pIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZXMuc2V0VHlwZVBhcnNlcihvaWQsIGZvcm1hdCwgcGFyc2VGbilcbiAgfVxuXG4gIGdldFR5cGVQYXJzZXIob2lkLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZXMuZ2V0VHlwZVBhcnNlcihvaWQsIGZvcm1hdClcbiAgfVxuXG4gIC8vIGVzY2FwZUlkZW50aWZpZXIgYW5kIGVzY2FwZUxpdGVyYWwgbW92ZWQgdG8gdXRpbGl0eSBmdW5jdGlvbnMgJiBleHBvcnRlZFxuICAvLyBvbiBQR1xuICAvLyByZS1leHBvcnRlZCBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBlc2NhcGVJZGVudGlmaWVyKHN0cikge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGVJZGVudGlmaWVyKHN0cilcbiAgfVxuXG4gIGVzY2FwZUxpdGVyYWwoc3RyKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZUxpdGVyYWwoc3RyKVxuICB9XG5cbiAgX3B1bHNlUXVlcnlRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5yZWFkeUZvclF1ZXJ5ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmFjdGl2ZVF1ZXJ5ID0gdGhpcy5xdWVyeVF1ZXVlLnNoaWZ0KClcbiAgICAgIGlmICh0aGlzLmFjdGl2ZVF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucmVhZHlGb3JRdWVyeSA9IGZhbHNlXG4gICAgICAgIHRoaXMuaGFzRXhlY3V0ZWQgPSB0cnVlXG5cbiAgICAgICAgY29uc3QgcXVlcnlFcnJvciA9IHRoaXMuYWN0aXZlUXVlcnkuc3VibWl0KHRoaXMuY29ubmVjdGlvbilcbiAgICAgICAgaWYgKHF1ZXJ5RXJyb3IpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUXVlcnkuaGFuZGxlRXJyb3IocXVlcnlFcnJvciwgdGhpcy5jb25uZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkeUZvclF1ZXJ5ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5fcHVsc2VRdWVyeVF1ZXVlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzRXhlY3V0ZWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVRdWVyeSA9IG51bGxcbiAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVlcnkoY29uZmlnLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgLy8gY2FuIHRha2UgaW4gc3RyaW5ncywgY29uZmlnIG9iamVjdCBvciBxdWVyeSBvYmplY3RcbiAgICBsZXQgcXVlcnlcbiAgICBsZXQgcmVzdWx0XG4gICAgbGV0IHJlYWRUaW1lb3V0XG4gICAgbGV0IHJlYWRUaW1lb3V0VGltZXJcbiAgICBsZXQgcXVlcnlDYWxsYmFja1xuXG4gICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2xpZW50IHdhcyBwYXNzZWQgYSBudWxsIG9yIHVuZGVmaW5lZCBxdWVyeScpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnLnN1Ym1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVhZFRpbWVvdXQgPSBjb25maWcucXVlcnlfdGltZW91dCB8fCB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLnF1ZXJ5X3RpbWVvdXRcbiAgICAgIHJlc3VsdCA9IHF1ZXJ5ID0gY29uZmlnXG4gICAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBxdWVyeS5jYWxsYmFjayA9IHF1ZXJ5LmNhbGxiYWNrIHx8IHZhbHVlc1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWFkVGltZW91dCA9IGNvbmZpZy5xdWVyeV90aW1lb3V0IHx8IHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMucXVlcnlfdGltZW91dFxuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkoY29uZmlnLCB2YWx1ZXMsIGNhbGxiYWNrKVxuICAgICAgaWYgKCFxdWVyeS5jYWxsYmFjaykge1xuICAgICAgICByZXN1bHQgPSBuZXcgdGhpcy5fUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcXVlcnkuY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IChlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKSlcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHN0YWNrIHRyYWNlIHRoYXQgbGVhZHMgdG8gYFRDUC5vblN0cmVhbVJlYWRgIHdpdGggb25lIHRoYXQgbGVhZHMgYmFjayB0byB0aGVcbiAgICAgICAgICAvLyBhcHBsaWNhdGlvbiB0aGF0IGNyZWF0ZWQgdGhlIHF1ZXJ5XG4gICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyKVxuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFkVGltZW91dCkge1xuICAgICAgcXVlcnlDYWxsYmFjayA9IHF1ZXJ5LmNhbGxiYWNrXG5cbiAgICAgIHJlYWRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1F1ZXJ5IHJlYWQgdGltZW91dCcpXG5cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgcXVlcnkuaGFuZGxlRXJyb3IoZXJyb3IsIHRoaXMuY29ubmVjdGlvbilcbiAgICAgICAgfSlcblxuICAgICAgICBxdWVyeUNhbGxiYWNrKGVycm9yKVxuXG4gICAgICAgIC8vIHdlIGFscmVhZHkgcmV0dXJuZWQgYW4gZXJyb3IsXG4gICAgICAgIC8vIGp1c3QgZG8gbm90aGluZyBpZiBxdWVyeSBjb21wbGV0ZXNcbiAgICAgICAgcXVlcnkuY2FsbGJhY2sgPSAoKSA9PiB7fVxuXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHF1ZXVlXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWVyeVF1ZXVlLmluZGV4T2YocXVlcnkpXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeVF1ZXVlLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3B1bHNlUXVlcnlRdWV1ZSgpXG4gICAgICB9LCByZWFkVGltZW91dClcblxuICAgICAgcXVlcnkuY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlYWRUaW1lb3V0VGltZXIpXG4gICAgICAgIHF1ZXJ5Q2FsbGJhY2soZXJyLCByZXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmluYXJ5ICYmICFxdWVyeS5iaW5hcnkpIHtcbiAgICAgIHF1ZXJ5LmJpbmFyeSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuX3Jlc3VsdCAmJiAhcXVlcnkuX3Jlc3VsdC5fdHlwZXMpIHtcbiAgICAgIHF1ZXJ5Ll9yZXN1bHQuX3R5cGVzID0gdGhpcy5fdHlwZXNcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3F1ZXJ5YWJsZSkge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHF1ZXJ5LmhhbmRsZUVycm9yKG5ldyBFcnJvcignQ2xpZW50IGhhcyBlbmNvdW50ZXJlZCBhIGNvbm5lY3Rpb24gZXJyb3IgYW5kIGlzIG5vdCBxdWVyeWFibGUnKSwgdGhpcy5jb25uZWN0aW9uKVxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW5kaW5nKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgcXVlcnkuaGFuZGxlRXJyb3IobmV3IEVycm9yKCdDbGllbnQgd2FzIGNsb3NlZCBhbmQgaXMgbm90IHF1ZXJ5YWJsZScpLCB0aGlzLmNvbm5lY3Rpb24pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHRoaXMucXVlcnlRdWV1ZS5wdXNoKHF1ZXJ5KVxuICAgIHRoaXMuX3B1bHNlUXVlcnlRdWV1ZSgpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmVmKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZWYoKVxuICB9XG5cbiAgdW5yZWYoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLnVucmVmKClcbiAgfVxuXG4gIGVuZChjYikge1xuICAgIHRoaXMuX2VuZGluZyA9IHRydWVcblxuICAgIC8vIGlmIHdlIGhhdmUgbmV2ZXIgY29ubmVjdGVkLCB0aGVuIGVuZCBpcyBhIG5vb3AsIGNhbGxiYWNrIGltbWVkaWF0ZWx5XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24uX2Nvbm5lY3RpbmcgfHwgdGhpcy5fZW5kZWQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICBjYigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hY3RpdmVRdWVyeSB8fCAhdGhpcy5fcXVlcnlhYmxlKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSBxdWVyeSB3ZSBuZWVkIHRvIGZvcmNlIGEgZGlzY29ubmVjdFxuICAgICAgLy8gb24gdGhlIHNvY2tldCAtIG90aGVyd2lzZSBhIGh1bmcgcXVlcnkgY291bGQgYmxvY2sgZW5kIGZvcmV2ZXJcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5lbmQoKVxuICAgIH1cblxuICAgIGlmIChjYikge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLm9uY2UoJ2VuZCcsIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uY2UoJ2VuZCcsIHJlc29sdmUpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG4vLyBleHBvc2UgYSBRdWVyeSBjb25zdHJ1Y3RvclxuQ2xpZW50LlF1ZXJ5ID0gUXVlcnlcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst dns = __webpack_require__(/*! dns */ \"dns\")\n\nconst defaults = __webpack_require__(/*! ./defaults */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js\")\n\nconst parse = (__webpack_require__(/*! pg-connection-string */ \"(api-node)/../../node_modules/.pnpm/pg-connection-string@2.9.1/node_modules/pg-connection-string/index.js\").parse) // parses a connection string\n\nconst val = function (key, config, envVar) {\n  if (envVar === undefined) {\n    envVar = process.env['PG' + key.toUpperCase()]\n  } else if (envVar === false) {\n    // do nothing ... use false\n  } else {\n    envVar = process.env[envVar]\n  }\n\n  return config[key] || envVar || defaults[key]\n}\n\nconst readSSLConfigFromEnvironment = function () {\n  switch (process.env.PGSSLMODE) {\n    case 'disable':\n      return false\n    case 'prefer':\n    case 'require':\n    case 'verify-ca':\n    case 'verify-full':\n      return true\n    case 'no-verify':\n      return { rejectUnauthorized: false }\n  }\n  return defaults.ssl\n}\n\n// Convert arg to a string, surround in single quotes, and escape single quotes and backslashes\nconst quoteParamValue = function (value) {\n  return \"'\" + ('' + value).replace(/\\\\/g, '\\\\\\\\').replace(/'/g, \"\\\\'\") + \"'\"\n}\n\nconst add = function (params, config, paramName) {\n  const value = config[paramName]\n  if (value !== undefined && value !== null) {\n    params.push(paramName + '=' + quoteParamValue(value))\n  }\n}\n\nclass ConnectionParameters {\n  constructor(config) {\n    // if a string is passed, it is a raw connection string so we parse it into a config\n    config = typeof config === 'string' ? parse(config) : config || {}\n\n    // if the config has a connectionString defined, parse IT into the config we use\n    // this will override other default values with what is stored in connectionString\n    if (config.connectionString) {\n      config = Object.assign({}, config, parse(config.connectionString))\n    }\n\n    this.user = val('user', config)\n    this.database = val('database', config)\n\n    if (this.database === undefined) {\n      this.database = this.user\n    }\n\n    this.port = parseInt(val('port', config), 10)\n    this.host = val('host', config)\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: val('password', config),\n    })\n\n    this.binary = val('binary', config)\n    this.options = val('options', config)\n\n    this.ssl = typeof config.ssl === 'undefined' ? readSSLConfigFromEnvironment() : config.ssl\n\n    if (typeof this.ssl === 'string') {\n      if (this.ssl === 'true') {\n        this.ssl = true\n      }\n    }\n    // support passing in ssl=no-verify via connection string\n    if (this.ssl === 'no-verify') {\n      this.ssl = { rejectUnauthorized: false }\n    }\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.client_encoding = val('client_encoding', config)\n    this.replication = val('replication', config)\n    // a domain socket begins with '/'\n    this.isDomainSocket = !(this.host || '').indexOf('/')\n\n    this.application_name = val('application_name', config, 'PGAPPNAME')\n    this.fallback_application_name = val('fallback_application_name', config, false)\n    this.statement_timeout = val('statement_timeout', config, false)\n    this.lock_timeout = val('lock_timeout', config, false)\n    this.idle_in_transaction_session_timeout = val('idle_in_transaction_session_timeout', config, false)\n    this.query_timeout = val('query_timeout', config, false)\n\n    if (config.connectionTimeoutMillis === undefined) {\n      this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0\n    } else {\n      this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000)\n    }\n\n    if (config.keepAlive === false) {\n      this.keepalives = 0\n    } else if (config.keepAlive === true) {\n      this.keepalives = 1\n    }\n\n    if (typeof config.keepAliveInitialDelayMillis === 'number') {\n      this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000)\n    }\n  }\n\n  getLibpqConnectionString(cb) {\n    const params = []\n    add(params, this, 'user')\n    add(params, this, 'password')\n    add(params, this, 'port')\n    add(params, this, 'application_name')\n    add(params, this, 'fallback_application_name')\n    add(params, this, 'connect_timeout')\n    add(params, this, 'options')\n\n    const ssl = typeof this.ssl === 'object' ? this.ssl : this.ssl ? { sslmode: this.ssl } : {}\n    add(params, ssl, 'sslmode')\n    add(params, ssl, 'sslca')\n    add(params, ssl, 'sslkey')\n    add(params, ssl, 'sslcert')\n    add(params, ssl, 'sslrootcert')\n\n    if (this.database) {\n      params.push('dbname=' + quoteParamValue(this.database))\n    }\n    if (this.replication) {\n      params.push('replication=' + quoteParamValue(this.replication))\n    }\n    if (this.host) {\n      params.push('host=' + quoteParamValue(this.host))\n    }\n    if (this.isDomainSocket) {\n      return cb(null, params.join(' '))\n    }\n    if (this.client_encoding) {\n      params.push('client_encoding=' + quoteParamValue(this.client_encoding))\n    }\n    dns.lookup(this.host, function (err, address) {\n      if (err) return cb(err, null)\n      params.push('hostaddr=' + quoteParamValue(address))\n      return cb(null, params.join(' '))\n    })\n  }\n}\n\nmodule.exports = ConnectionParameters\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY29ubmVjdGlvbi1wYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFlBQVksbUJBQU8sQ0FBQyxnQkFBSzs7QUFFekIsaUJBQWlCLG1CQUFPLENBQUMsaUdBQVk7O0FBRXJDLGNBQWMsb0tBQXFDOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVFQUF1RSxvQkFBb0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9jb25uZWN0aW9uLXBhcmFtZXRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGRucyA9IHJlcXVpcmUoJ2RucycpXG5cbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpXG5cbmNvbnN0IHBhcnNlID0gcmVxdWlyZSgncGctY29ubmVjdGlvbi1zdHJpbmcnKS5wYXJzZSAvLyBwYXJzZXMgYSBjb25uZWN0aW9uIHN0cmluZ1xuXG5jb25zdCB2YWwgPSBmdW5jdGlvbiAoa2V5LCBjb25maWcsIGVudlZhcikge1xuICBpZiAoZW52VmFyID09PSB1bmRlZmluZWQpIHtcbiAgICBlbnZWYXIgPSBwcm9jZXNzLmVudlsnUEcnICsga2V5LnRvVXBwZXJDYXNlKCldXG4gIH0gZWxzZSBpZiAoZW52VmFyID09PSBmYWxzZSkge1xuICAgIC8vIGRvIG5vdGhpbmcgLi4uIHVzZSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGVudlZhciA9IHByb2Nlc3MuZW52W2VudlZhcl1cbiAgfVxuXG4gIHJldHVybiBjb25maWdba2V5XSB8fCBlbnZWYXIgfHwgZGVmYXVsdHNba2V5XVxufVxuXG5jb25zdCByZWFkU1NMQ29uZmlnRnJvbUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkge1xuICBzd2l0Y2ggKHByb2Nlc3MuZW52LlBHU1NMTU9ERSkge1xuICAgIGNhc2UgJ2Rpc2FibGUnOlxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgY2FzZSAncHJlZmVyJzpcbiAgICBjYXNlICdyZXF1aXJlJzpcbiAgICBjYXNlICd2ZXJpZnktY2EnOlxuICAgIGNhc2UgJ3ZlcmlmeS1mdWxsJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgY2FzZSAnbm8tdmVyaWZ5JzpcbiAgICAgIHJldHVybiB7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cy5zc2xcbn1cblxuLy8gQ29udmVydCBhcmcgdG8gYSBzdHJpbmcsIHN1cnJvdW5kIGluIHNpbmdsZSBxdW90ZXMsIGFuZCBlc2NhcGUgc2luZ2xlIHF1b3RlcyBhbmQgYmFja3NsYXNoZXNcbmNvbnN0IHF1b3RlUGFyYW1WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gXCInXCIgKyAoJycgKyB2YWx1ZSkucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikgKyBcIidcIlxufVxuXG5jb25zdCBhZGQgPSBmdW5jdGlvbiAocGFyYW1zLCBjb25maWcsIHBhcmFtTmFtZSkge1xuICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twYXJhbU5hbWVdXG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgcGFyYW1zLnB1c2gocGFyYW1OYW1lICsgJz0nICsgcXVvdGVQYXJhbVZhbHVlKHZhbHVlKSlcbiAgfVxufVxuXG5jbGFzcyBDb25uZWN0aW9uUGFyYW1ldGVycyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIGlmIGEgc3RyaW5nIGlzIHBhc3NlZCwgaXQgaXMgYSByYXcgY29ubmVjdGlvbiBzdHJpbmcgc28gd2UgcGFyc2UgaXQgaW50byBhIGNvbmZpZ1xuICAgIGNvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gcGFyc2UoY29uZmlnKSA6IGNvbmZpZyB8fCB7fVxuXG4gICAgLy8gaWYgdGhlIGNvbmZpZyBoYXMgYSBjb25uZWN0aW9uU3RyaW5nIGRlZmluZWQsIHBhcnNlIElUIGludG8gdGhlIGNvbmZpZyB3ZSB1c2VcbiAgICAvLyB0aGlzIHdpbGwgb3ZlcnJpZGUgb3RoZXIgZGVmYXVsdCB2YWx1ZXMgd2l0aCB3aGF0IGlzIHN0b3JlZCBpbiBjb25uZWN0aW9uU3RyaW5nXG4gICAgaWYgKGNvbmZpZy5jb25uZWN0aW9uU3RyaW5nKSB7XG4gICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHBhcnNlKGNvbmZpZy5jb25uZWN0aW9uU3RyaW5nKSlcbiAgICB9XG5cbiAgICB0aGlzLnVzZXIgPSB2YWwoJ3VzZXInLCBjb25maWcpXG4gICAgdGhpcy5kYXRhYmFzZSA9IHZhbCgnZGF0YWJhc2UnLCBjb25maWcpXG5cbiAgICBpZiAodGhpcy5kYXRhYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRhdGFiYXNlID0gdGhpcy51c2VyXG4gICAgfVxuXG4gICAgdGhpcy5wb3J0ID0gcGFyc2VJbnQodmFsKCdwb3J0JywgY29uZmlnKSwgMTApXG4gICAgdGhpcy5ob3N0ID0gdmFsKCdob3N0JywgY29uZmlnKVxuXG4gICAgLy8gXCJoaWRpbmdcIiB0aGUgcGFzc3dvcmQgc28gaXQgZG9lc24ndCBzaG93IHVwIGluIHN0YWNrIHRyYWNlc1xuICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Bhc3N3b3JkJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiB2YWwoJ3Bhc3N3b3JkJywgY29uZmlnKSxcbiAgICB9KVxuXG4gICAgdGhpcy5iaW5hcnkgPSB2YWwoJ2JpbmFyeScsIGNvbmZpZylcbiAgICB0aGlzLm9wdGlvbnMgPSB2YWwoJ29wdGlvbnMnLCBjb25maWcpXG5cbiAgICB0aGlzLnNzbCA9IHR5cGVvZiBjb25maWcuc3NsID09PSAndW5kZWZpbmVkJyA/IHJlYWRTU0xDb25maWdGcm9tRW52aXJvbm1lbnQoKSA6IGNvbmZpZy5zc2xcblxuICAgIGlmICh0eXBlb2YgdGhpcy5zc2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodGhpcy5zc2wgPT09ICd0cnVlJykge1xuICAgICAgICB0aGlzLnNzbCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3VwcG9ydCBwYXNzaW5nIGluIHNzbD1uby12ZXJpZnkgdmlhIGNvbm5lY3Rpb24gc3RyaW5nXG4gICAgaWYgKHRoaXMuc3NsID09PSAnbm8tdmVyaWZ5Jykge1xuICAgICAgdGhpcy5zc2wgPSB7IHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zc2wgJiYgdGhpcy5zc2wua2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zc2wsICdrZXknLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudF9lbmNvZGluZyA9IHZhbCgnY2xpZW50X2VuY29kaW5nJywgY29uZmlnKVxuICAgIHRoaXMucmVwbGljYXRpb24gPSB2YWwoJ3JlcGxpY2F0aW9uJywgY29uZmlnKVxuICAgIC8vIGEgZG9tYWluIHNvY2tldCBiZWdpbnMgd2l0aCAnLydcbiAgICB0aGlzLmlzRG9tYWluU29ja2V0ID0gISh0aGlzLmhvc3QgfHwgJycpLmluZGV4T2YoJy8nKVxuXG4gICAgdGhpcy5hcHBsaWNhdGlvbl9uYW1lID0gdmFsKCdhcHBsaWNhdGlvbl9uYW1lJywgY29uZmlnLCAnUEdBUFBOQU1FJylcbiAgICB0aGlzLmZhbGxiYWNrX2FwcGxpY2F0aW9uX25hbWUgPSB2YWwoJ2ZhbGxiYWNrX2FwcGxpY2F0aW9uX25hbWUnLCBjb25maWcsIGZhbHNlKVxuICAgIHRoaXMuc3RhdGVtZW50X3RpbWVvdXQgPSB2YWwoJ3N0YXRlbWVudF90aW1lb3V0JywgY29uZmlnLCBmYWxzZSlcbiAgICB0aGlzLmxvY2tfdGltZW91dCA9IHZhbCgnbG9ja190aW1lb3V0JywgY29uZmlnLCBmYWxzZSlcbiAgICB0aGlzLmlkbGVfaW5fdHJhbnNhY3Rpb25fc2Vzc2lvbl90aW1lb3V0ID0gdmFsKCdpZGxlX2luX3RyYW5zYWN0aW9uX3Nlc3Npb25fdGltZW91dCcsIGNvbmZpZywgZmFsc2UpXG4gICAgdGhpcy5xdWVyeV90aW1lb3V0ID0gdmFsKCdxdWVyeV90aW1lb3V0JywgY29uZmlnLCBmYWxzZSlcblxuICAgIGlmIChjb25maWcuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb25uZWN0X3RpbWVvdXQgPSBwcm9jZXNzLmVudi5QR0NPTk5FQ1RfVElNRU9VVCB8fCAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29ubmVjdF90aW1lb3V0ID0gTWF0aC5mbG9vcihjb25maWcuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMgLyAxMDAwKVxuICAgIH1cblxuICAgIGlmIChjb25maWcua2VlcEFsaXZlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5rZWVwYWxpdmVzID0gMFxuICAgIH0gZWxzZSBpZiAoY29uZmlnLmtlZXBBbGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5rZWVwYWxpdmVzID0gMVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmtlZXBBbGl2ZUluaXRpYWxEZWxheU1pbGxpcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMua2VlcGFsaXZlc19pZGxlID0gTWF0aC5mbG9vcihjb25maWcua2VlcEFsaXZlSW5pdGlhbERlbGF5TWlsbGlzIC8gMTAwMClcbiAgICB9XG4gIH1cblxuICBnZXRMaWJwcUNvbm5lY3Rpb25TdHJpbmcoY2IpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXVxuICAgIGFkZChwYXJhbXMsIHRoaXMsICd1c2VyJylcbiAgICBhZGQocGFyYW1zLCB0aGlzLCAncGFzc3dvcmQnKVxuICAgIGFkZChwYXJhbXMsIHRoaXMsICdwb3J0JylcbiAgICBhZGQocGFyYW1zLCB0aGlzLCAnYXBwbGljYXRpb25fbmFtZScpXG4gICAgYWRkKHBhcmFtcywgdGhpcywgJ2ZhbGxiYWNrX2FwcGxpY2F0aW9uX25hbWUnKVxuICAgIGFkZChwYXJhbXMsIHRoaXMsICdjb25uZWN0X3RpbWVvdXQnKVxuICAgIGFkZChwYXJhbXMsIHRoaXMsICdvcHRpb25zJylcblxuICAgIGNvbnN0IHNzbCA9IHR5cGVvZiB0aGlzLnNzbCA9PT0gJ29iamVjdCcgPyB0aGlzLnNzbCA6IHRoaXMuc3NsID8geyBzc2xtb2RlOiB0aGlzLnNzbCB9IDoge31cbiAgICBhZGQocGFyYW1zLCBzc2wsICdzc2xtb2RlJylcbiAgICBhZGQocGFyYW1zLCBzc2wsICdzc2xjYScpXG4gICAgYWRkKHBhcmFtcywgc3NsLCAnc3Nsa2V5JylcbiAgICBhZGQocGFyYW1zLCBzc2wsICdzc2xjZXJ0JylcbiAgICBhZGQocGFyYW1zLCBzc2wsICdzc2xyb290Y2VydCcpXG5cbiAgICBpZiAodGhpcy5kYXRhYmFzZSkge1xuICAgICAgcGFyYW1zLnB1c2goJ2RibmFtZT0nICsgcXVvdGVQYXJhbVZhbHVlKHRoaXMuZGF0YWJhc2UpKVxuICAgIH1cbiAgICBpZiAodGhpcy5yZXBsaWNhdGlvbikge1xuICAgICAgcGFyYW1zLnB1c2goJ3JlcGxpY2F0aW9uPScgKyBxdW90ZVBhcmFtVmFsdWUodGhpcy5yZXBsaWNhdGlvbikpXG4gICAgfVxuICAgIGlmICh0aGlzLmhvc3QpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdob3N0PScgKyBxdW90ZVBhcmFtVmFsdWUodGhpcy5ob3N0KSlcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEb21haW5Tb2NrZXQpIHtcbiAgICAgIHJldHVybiBjYihudWxsLCBwYXJhbXMuam9pbignICcpKVxuICAgIH1cbiAgICBpZiAodGhpcy5jbGllbnRfZW5jb2RpbmcpIHtcbiAgICAgIHBhcmFtcy5wdXNoKCdjbGllbnRfZW5jb2Rpbmc9JyArIHF1b3RlUGFyYW1WYWx1ZSh0aGlzLmNsaWVudF9lbmNvZGluZykpXG4gICAgfVxuICAgIGRucy5sb29rdXAodGhpcy5ob3N0LCBmdW5jdGlvbiAoZXJyLCBhZGRyZXNzKSB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyLCBudWxsKVxuICAgICAgcGFyYW1zLnB1c2goJ2hvc3RhZGRyPScgKyBxdW90ZVBhcmFtVmFsdWUoYWRkcmVzcykpXG4gICAgICByZXR1cm4gY2IobnVsbCwgcGFyYW1zLmpvaW4oJyAnKSlcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblBhcmFtZXRlcnNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst { parse, serialize } = __webpack_require__(/*! pg-protocol */ \"(api-node)/../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/index.js\")\nconst { getStream, getSecureStream } = __webpack_require__(/*! ./stream */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js\")\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n\n    this.stream = config.stream || getStream(config.ssl)\n    if (typeof this.stream === 'function') {\n      this.stream = this.stream(config)\n    }\n\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    const self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    const self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      const responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      const net = __webpack_require__(/*! net */ \"net\")\n      if (net.isIP && net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = getSecureStream(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    parse(stream, (msg) => {\n      const eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(syncBuffer)\n  }\n\n  ref() {\n    this.stream.ref()\n  }\n\n  unref() {\n    this.stream.unref()\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixxQkFBcUIsMERBQThCOztBQUVuRCxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsa0hBQWE7QUFDbEQsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLDZGQUFVOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxnQkFBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hc2xhay9yZXBvcy9wbGFuLWVhdC1yZXBlYXQvbm9kZV9tb2R1bGVzLy5wbnBtL3BnQDguMTYuMy9ub2RlX21vZHVsZXMvcGcvbGliL2Nvbm5lY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuXG5jb25zdCB7IHBhcnNlLCBzZXJpYWxpemUgfSA9IHJlcXVpcmUoJ3BnLXByb3RvY29sJylcbmNvbnN0IHsgZ2V0U3RyZWFtLCBnZXRTZWN1cmVTdHJlYW0gfSA9IHJlcXVpcmUoJy4vc3RyZWFtJylcblxuY29uc3QgZmx1c2hCdWZmZXIgPSBzZXJpYWxpemUuZmx1c2goKVxuY29uc3Qgc3luY0J1ZmZlciA9IHNlcmlhbGl6ZS5zeW5jKClcbmNvbnN0IGVuZEJ1ZmZlciA9IHNlcmlhbGl6ZS5lbmQoKVxuXG4vLyBUT0RPKGJtYykgc3VwcG9ydCBiaW5hcnkgbW9kZSBhdCBzb21lIHBvaW50XG5jbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKVxuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fVxuXG4gICAgdGhpcy5zdHJlYW0gPSBjb25maWcuc3RyZWFtIHx8IGdldFN0cmVhbShjb25maWcuc3NsKVxuICAgIGlmICh0eXBlb2YgdGhpcy5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc3RyZWFtID0gdGhpcy5zdHJlYW0oY29uZmlnKVxuICAgIH1cblxuICAgIHRoaXMuX2tlZXBBbGl2ZSA9IGNvbmZpZy5rZWVwQWxpdmVcbiAgICB0aGlzLl9rZWVwQWxpdmVJbml0aWFsRGVsYXlNaWxsaXMgPSBjb25maWcua2VlcEFsaXZlSW5pdGlhbERlbGF5TWlsbGlzXG4gICAgdGhpcy5sYXN0QnVmZmVyID0gZmFsc2VcbiAgICB0aGlzLnBhcnNlZFN0YXRlbWVudHMgPSB7fVxuICAgIHRoaXMuc3NsID0gY29uZmlnLnNzbCB8fCBmYWxzZVxuICAgIHRoaXMuX2VuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5fZW1pdE1lc3NhZ2UgPSBmYWxzZVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5vbignbmV3TGlzdGVuZXInLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgICAgc2VsZi5fZW1pdE1lc3NhZ2UgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbm5lY3QocG9ydCwgaG9zdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZVxuICAgIHRoaXMuc3RyZWFtLnNldE5vRGVsYXkodHJ1ZSlcbiAgICB0aGlzLnN0cmVhbS5jb25uZWN0KHBvcnQsIGhvc3QpXG5cbiAgICB0aGlzLnN0cmVhbS5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuX2tlZXBBbGl2ZSkge1xuICAgICAgICBzZWxmLnN0cmVhbS5zZXRLZWVwQWxpdmUodHJ1ZSwgc2VsZi5fa2VlcEFsaXZlSW5pdGlhbERlbGF5TWlsbGlzKVxuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdjb25uZWN0JylcbiAgICB9KVxuXG4gICAgY29uc3QgcmVwb3J0U3RyZWFtRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIC8vIGVycm9ycyBhYm91dCBkaXNjb25uZWN0aW9ucyBzaG91bGQgYmUgaWdub3JlZCBkdXJpbmcgZGlzY29ubmVjdFxuICAgICAgaWYgKHNlbGYuX2VuZGluZyAmJiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8IGVycm9yLmNvZGUgPT09ICdFUElQRScpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgIH1cbiAgICB0aGlzLnN0cmVhbS5vbignZXJyb3InLCByZXBvcnRTdHJlYW1FcnJvcilcblxuICAgIHRoaXMuc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnZW5kJylcbiAgICB9KVxuXG4gICAgaWYgKCF0aGlzLnNzbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoTGlzdGVuZXJzKHRoaXMuc3RyZWFtKVxuICAgIH1cblxuICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2RhdGEnLCBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICBjb25zdCByZXNwb25zZUNvZGUgPSBidWZmZXIudG9TdHJpbmcoJ3V0ZjgnKVxuICAgICAgc3dpdGNoIChyZXNwb25zZUNvZGUpIHtcbiAgICAgICAgY2FzZSAnUyc6IC8vIFNlcnZlciBzdXBwb3J0cyBTU0wgY29ubmVjdGlvbnMsIGNvbnRpbnVlIHdpdGggYSBzZWN1cmUgY29ubmVjdGlvblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ04nOiAvLyBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBTU0wgY29ubmVjdGlvbnNcbiAgICAgICAgICBzZWxmLnN0cmVhbS5lbmQoKVxuICAgICAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdUaGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgU1NMIGNvbm5lY3Rpb25zJykpXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQW55IG90aGVyIHJlc3BvbnNlIGJ5dGUsIGluY2x1ZGluZyAnRScgKEVycm9yUmVzcG9uc2UpIGluZGljYXRpbmcgYSBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgICBzZWxmLnN0cmVhbS5lbmQoKVxuICAgICAgICAgIHJldHVybiBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZXN0YWJsaXNoaW5nIGFuIFNTTCBjb25uZWN0aW9uJykpXG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBzb2NrZXQ6IHNlbGYuc3RyZWFtLFxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5zc2wgIT09IHRydWUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzZWxmLnNzbClcblxuICAgICAgICBpZiAoJ2tleScgaW4gc2VsZi5zc2wpIHtcbiAgICAgICAgICBvcHRpb25zLmtleSA9IHNlbGYuc3NsLmtleVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICAgICBpZiAobmV0LmlzSVAgJiYgbmV0LmlzSVAoaG9zdCkgPT09IDApIHtcbiAgICAgICAgb3B0aW9ucy5zZXJ2ZXJuYW1lID0gaG9zdFxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5zdHJlYW0gPSBnZXRTZWN1cmVTdHJlYW0ob3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH1cbiAgICAgIHNlbGYuYXR0YWNoTGlzdGVuZXJzKHNlbGYuc3RyZWFtKVxuICAgICAgc2VsZi5zdHJlYW0ub24oJ2Vycm9yJywgcmVwb3J0U3RyZWFtRXJyb3IpXG5cbiAgICAgIHNlbGYuZW1pdCgnc3NsY29ubmVjdCcpXG4gICAgfSlcbiAgfVxuXG4gIGF0dGFjaExpc3RlbmVycyhzdHJlYW0pIHtcbiAgICBwYXJzZShzdHJlYW0sIChtc2cpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG1zZy5uYW1lID09PSAnZXJyb3InID8gJ2Vycm9yTWVzc2FnZScgOiBtc2cubmFtZVxuICAgICAgaWYgKHRoaXMuX2VtaXRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZylcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIG1zZylcbiAgICB9KVxuICB9XG5cbiAgcmVxdWVzdFNzbCgpIHtcbiAgICB0aGlzLnN0cmVhbS53cml0ZShzZXJpYWxpemUucmVxdWVzdFNzbCgpKVxuICB9XG5cbiAgc3RhcnR1cChjb25maWcpIHtcbiAgICB0aGlzLnN0cmVhbS53cml0ZShzZXJpYWxpemUuc3RhcnR1cChjb25maWcpKVxuICB9XG5cbiAgY2FuY2VsKHByb2Nlc3NJRCwgc2VjcmV0S2V5KSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuY2FuY2VsKHByb2Nlc3NJRCwgc2VjcmV0S2V5KSlcbiAgfVxuXG4gIHBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUucGFzc3dvcmQocGFzc3dvcmQpKVxuICB9XG5cbiAgc2VuZFNBU0xJbml0aWFsUmVzcG9uc2VNZXNzYWdlKG1lY2hhbmlzbSwgaW5pdGlhbFJlc3BvbnNlKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuc2VuZFNBU0xJbml0aWFsUmVzcG9uc2VNZXNzYWdlKG1lY2hhbmlzbSwgaW5pdGlhbFJlc3BvbnNlKSlcbiAgfVxuXG4gIHNlbmRTQ1JBTUNsaWVudEZpbmFsTWVzc2FnZShhZGRpdGlvbmFsRGF0YSkge1xuICAgIHRoaXMuX3NlbmQoc2VyaWFsaXplLnNlbmRTQ1JBTUNsaWVudEZpbmFsTWVzc2FnZShhZGRpdGlvbmFsRGF0YSkpXG4gIH1cblxuICBfc2VuZChidWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuc3RyZWFtLndyaXRhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGJ1ZmZlcilcbiAgfVxuXG4gIHF1ZXJ5KHRleHQpIHtcbiAgICB0aGlzLl9zZW5kKHNlcmlhbGl6ZS5xdWVyeSh0ZXh0KSlcbiAgfVxuXG4gIC8vIHNlbmQgcGFyc2UgbWVzc2FnZVxuICBwYXJzZShxdWVyeSkge1xuICAgIHRoaXMuX3NlbmQoc2VyaWFsaXplLnBhcnNlKHF1ZXJ5KSlcbiAgfVxuXG4gIC8vIHNlbmQgYmluZCBtZXNzYWdlXG4gIGJpbmQoY29uZmlnKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuYmluZChjb25maWcpKVxuICB9XG5cbiAgLy8gc2VuZCBleGVjdXRlIG1lc3NhZ2VcbiAgZXhlY3V0ZShjb25maWcpIHtcbiAgICB0aGlzLl9zZW5kKHNlcmlhbGl6ZS5leGVjdXRlKGNvbmZpZykpXG4gIH1cblxuICBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5zdHJlYW0ud3JpdGFibGUpIHtcbiAgICAgIHRoaXMuc3RyZWFtLndyaXRlKGZsdXNoQnVmZmVyKVxuICAgIH1cbiAgfVxuXG4gIHN5bmMoKSB7XG4gICAgdGhpcy5fZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXMuX3NlbmQoc3luY0J1ZmZlcilcbiAgfVxuXG4gIHJlZigpIHtcbiAgICB0aGlzLnN0cmVhbS5yZWYoKVxuICB9XG5cbiAgdW5yZWYoKSB7XG4gICAgdGhpcy5zdHJlYW0udW5yZWYoKVxuICB9XG5cbiAgZW5kKCkge1xuICAgIC8vIDB4NTggPSAnWCdcbiAgICB0aGlzLl9lbmRpbmcgPSB0cnVlXG4gICAgaWYgKCF0aGlzLl9jb25uZWN0aW5nIHx8ICF0aGlzLnN0cmVhbS53cml0YWJsZSkge1xuICAgICAgdGhpcy5zdHJlYW0uZW5kKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoZW5kQnVmZmVyLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0cmVhbS5lbmQoKVxuICAgIH0pXG4gIH1cblxuICBjbG9zZShtc2cpIHtcbiAgICB0aGlzLl9zZW5kKHNlcmlhbGl6ZS5jbG9zZShtc2cpKVxuICB9XG5cbiAgZGVzY3JpYmUobXNnKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuZGVzY3JpYmUobXNnKSlcbiAgfVxuXG4gIHNlbmRDb3B5RnJvbUNodW5rKGNodW5rKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuY29weURhdGEoY2h1bmspKVxuICB9XG5cbiAgZW5kQ29weUZyb20oKSB7XG4gICAgdGhpcy5fc2VuZChzZXJpYWxpemUuY29weURvbmUoKSlcbiAgfVxuXG4gIHNlbmRDb3B5RmFpbChtc2cpIHtcbiAgICB0aGlzLl9zZW5kKHNlcmlhbGl6ZS5jb3B5RmFpbChtc2cpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("function x509Error(msg, cert) {\n  return new Error('SASL channel binding: ' + msg + ' when parsing public certificate ' + cert.toString('base64'))\n}\n\nfunction readASN1Length(data, index) {\n  let length = data[index++]\n  if (length < 0x80) return { length, index }\n\n  const lengthBytes = length & 0x7f\n  if (lengthBytes > 4) throw x509Error('bad length', data)\n\n  length = 0\n  for (let i = 0; i < lengthBytes; i++) {\n    length = (length << 8) | data[index++]\n  }\n\n  return { length, index }\n}\n\nfunction readASN1OID(data, index) {\n  if (data[index++] !== 0x6) throw x509Error('non-OID data', data) // 6 = OID\n\n  const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index)\n  index = indexAfterOIDLength\n  const lastIndex = index + OIDLength\n\n  const byte1 = data[index++]\n  let oid = ((byte1 / 40) >> 0) + '.' + (byte1 % 40)\n\n  while (index < lastIndex) {\n    // loop over numbers in OID\n    let value = 0\n    while (index < lastIndex) {\n      // loop over bytes in number\n      const nextByte = data[index++]\n      value = (value << 7) | (nextByte & 0x7f)\n      if (nextByte < 0x80) break\n    }\n    oid += '.' + value\n  }\n\n  return { oid, index }\n}\n\nfunction expectASN1Seq(data, index) {\n  if (data[index++] !== 0x30) throw x509Error('non-sequence data', data) // 30 = Sequence\n  return readASN1Length(data, index)\n}\n\nfunction signatureAlgorithmHashFromCertificate(data, index) {\n  // read this thread: https://www.postgresql.org/message-id/17760-b6c61e752ec07060%40postgresql.org\n  if (index === undefined) index = 0\n  index = expectASN1Seq(data, index).index\n  const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index)\n  index = indexAfterCertInfoLength + certInfoLength // skip over certificate info\n  index = expectASN1Seq(data, index).index // skip over signature length field\n  const { oid, index: indexAfterOID } = readASN1OID(data, index)\n  switch (oid) {\n    // RSA\n    case '1.2.840.113549.1.1.4':\n      return 'MD5'\n    case '1.2.840.113549.1.1.5':\n      return 'SHA-1'\n    case '1.2.840.113549.1.1.11':\n      return 'SHA-256'\n    case '1.2.840.113549.1.1.12':\n      return 'SHA-384'\n    case '1.2.840.113549.1.1.13':\n      return 'SHA-512'\n    case '1.2.840.113549.1.1.14':\n      return 'SHA-224'\n    case '1.2.840.113549.1.1.15':\n      return 'SHA512-224'\n    case '1.2.840.113549.1.1.16':\n      return 'SHA512-256'\n    // ECDSA\n    case '1.2.840.10045.4.1':\n      return 'SHA-1'\n    case '1.2.840.10045.4.3.1':\n      return 'SHA-224'\n    case '1.2.840.10045.4.3.2':\n      return 'SHA-256'\n    case '1.2.840.10045.4.3.3':\n      return 'SHA-384'\n    case '1.2.840.10045.4.3.4':\n      return 'SHA-512'\n    // RSASSA-PSS: hash is indicated separately\n    case '1.2.840.113549.1.1.10': {\n      index = indexAfterOID\n      index = expectASN1Seq(data, index).index\n      if (data[index++] !== 0xa0) throw x509Error('non-tag data', data) // a0 = constructed tag 0\n      index = readASN1Length(data, index).index // skip over tag length field\n      index = expectASN1Seq(data, index).index // skip over sequence length field\n      const { oid: hashOID } = readASN1OID(data, index)\n      switch (hashOID) {\n        // standalone hash OIDs\n        case '1.2.840.113549.2.5':\n          return 'MD5'\n        case '1.3.14.3.2.26':\n          return 'SHA-1'\n        case '2.16.840.1.101.3.4.2.1':\n          return 'SHA-256'\n        case '2.16.840.1.101.3.4.2.2':\n          return 'SHA-384'\n        case '2.16.840.1.101.3.4.2.3':\n          return 'SHA-512'\n      }\n      throw x509Error('unknown hash OID ' + hashOID, data)\n    }\n    // Ed25519 -- see https: return//github.com/openssl/openssl/issues/15477\n    case '1.3.101.110':\n    case '1.3.101.112': // ph\n      return 'SHA-512'\n    // Ed448 -- still not in pg 17.2 (if supported, digest would be SHAKE256 x 64 bytes)\n    case '1.3.101.111':\n    case '1.3.101.113': // ph\n      throw x509Error('Ed448 certificate channel binding is not currently supported by Postgres')\n  }\n  throw x509Error('unknown OID ' + oid, data)\n}\n\nmodule.exports = { signatureAlgorithmHashFromCertificate }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL2NlcnQtc2lnbmF0dXJlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQSxVQUFVLGdEQUFnRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBEQUEwRDtBQUNwRTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9jcnlwdG8vY2VydC1zaWduYXR1cmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHg1MDlFcnJvcihtc2csIGNlcnQpIHtcbiAgcmV0dXJuIG5ldyBFcnJvcignU0FTTCBjaGFubmVsIGJpbmRpbmc6ICcgKyBtc2cgKyAnIHdoZW4gcGFyc2luZyBwdWJsaWMgY2VydGlmaWNhdGUgJyArIGNlcnQudG9TdHJpbmcoJ2Jhc2U2NCcpKVxufVxuXG5mdW5jdGlvbiByZWFkQVNOMUxlbmd0aChkYXRhLCBpbmRleCkge1xuICBsZXQgbGVuZ3RoID0gZGF0YVtpbmRleCsrXVxuICBpZiAobGVuZ3RoIDwgMHg4MCkgcmV0dXJuIHsgbGVuZ3RoLCBpbmRleCB9XG5cbiAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBsZW5ndGggJiAweDdmXG4gIGlmIChsZW5ndGhCeXRlcyA+IDQpIHRocm93IHg1MDlFcnJvcignYmFkIGxlbmd0aCcsIGRhdGEpXG5cbiAgbGVuZ3RoID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aEJ5dGVzOyBpKyspIHtcbiAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgZGF0YVtpbmRleCsrXVxuICB9XG5cbiAgcmV0dXJuIHsgbGVuZ3RoLCBpbmRleCB9XG59XG5cbmZ1bmN0aW9uIHJlYWRBU04xT0lEKGRhdGEsIGluZGV4KSB7XG4gIGlmIChkYXRhW2luZGV4KytdICE9PSAweDYpIHRocm93IHg1MDlFcnJvcignbm9uLU9JRCBkYXRhJywgZGF0YSkgLy8gNiA9IE9JRFxuXG4gIGNvbnN0IHsgbGVuZ3RoOiBPSURMZW5ndGgsIGluZGV4OiBpbmRleEFmdGVyT0lETGVuZ3RoIH0gPSByZWFkQVNOMUxlbmd0aChkYXRhLCBpbmRleClcbiAgaW5kZXggPSBpbmRleEFmdGVyT0lETGVuZ3RoXG4gIGNvbnN0IGxhc3RJbmRleCA9IGluZGV4ICsgT0lETGVuZ3RoXG5cbiAgY29uc3QgYnl0ZTEgPSBkYXRhW2luZGV4KytdXG4gIGxldCBvaWQgPSAoKGJ5dGUxIC8gNDApID4+IDApICsgJy4nICsgKGJ5dGUxICUgNDApXG5cbiAgd2hpbGUgKGluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgLy8gbG9vcCBvdmVyIG51bWJlcnMgaW4gT0lEXG4gICAgbGV0IHZhbHVlID0gMFxuICAgIHdoaWxlIChpbmRleCA8IGxhc3RJbmRleCkge1xuICAgICAgLy8gbG9vcCBvdmVyIGJ5dGVzIGluIG51bWJlclxuICAgICAgY29uc3QgbmV4dEJ5dGUgPSBkYXRhW2luZGV4KytdXG4gICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA3KSB8IChuZXh0Qnl0ZSAmIDB4N2YpXG4gICAgICBpZiAobmV4dEJ5dGUgPCAweDgwKSBicmVha1xuICAgIH1cbiAgICBvaWQgKz0gJy4nICsgdmFsdWVcbiAgfVxuXG4gIHJldHVybiB7IG9pZCwgaW5kZXggfVxufVxuXG5mdW5jdGlvbiBleHBlY3RBU04xU2VxKGRhdGEsIGluZGV4KSB7XG4gIGlmIChkYXRhW2luZGV4KytdICE9PSAweDMwKSB0aHJvdyB4NTA5RXJyb3IoJ25vbi1zZXF1ZW5jZSBkYXRhJywgZGF0YSkgLy8gMzAgPSBTZXF1ZW5jZVxuICByZXR1cm4gcmVhZEFTTjFMZW5ndGgoZGF0YSwgaW5kZXgpXG59XG5cbmZ1bmN0aW9uIHNpZ25hdHVyZUFsZ29yaXRobUhhc2hGcm9tQ2VydGlmaWNhdGUoZGF0YSwgaW5kZXgpIHtcbiAgLy8gcmVhZCB0aGlzIHRocmVhZDogaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvbWVzc2FnZS1pZC8xNzc2MC1iNmM2MWU3NTJlYzA3MDYwJTQwcG9zdGdyZXNxbC5vcmdcbiAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIGluZGV4ID0gMFxuICBpbmRleCA9IGV4cGVjdEFTTjFTZXEoZGF0YSwgaW5kZXgpLmluZGV4XG4gIGNvbnN0IHsgbGVuZ3RoOiBjZXJ0SW5mb0xlbmd0aCwgaW5kZXg6IGluZGV4QWZ0ZXJDZXJ0SW5mb0xlbmd0aCB9ID0gZXhwZWN0QVNOMVNlcShkYXRhLCBpbmRleClcbiAgaW5kZXggPSBpbmRleEFmdGVyQ2VydEluZm9MZW5ndGggKyBjZXJ0SW5mb0xlbmd0aCAvLyBza2lwIG92ZXIgY2VydGlmaWNhdGUgaW5mb1xuICBpbmRleCA9IGV4cGVjdEFTTjFTZXEoZGF0YSwgaW5kZXgpLmluZGV4IC8vIHNraXAgb3ZlciBzaWduYXR1cmUgbGVuZ3RoIGZpZWxkXG4gIGNvbnN0IHsgb2lkLCBpbmRleDogaW5kZXhBZnRlck9JRCB9ID0gcmVhZEFTTjFPSUQoZGF0YSwgaW5kZXgpXG4gIHN3aXRjaCAob2lkKSB7XG4gICAgLy8gUlNBXG4gICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjQnOlxuICAgICAgcmV0dXJuICdNRDUnXG4gICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjUnOlxuICAgICAgcmV0dXJuICdTSEEtMSdcbiAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMTEnOlxuICAgICAgcmV0dXJuICdTSEEtMjU2J1xuICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xMic6XG4gICAgICByZXR1cm4gJ1NIQS0zODQnXG4gICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjEzJzpcbiAgICAgIHJldHVybiAnU0hBLTUxMidcbiAgICBjYXNlICcxLjIuODQwLjExMzU0OS4xLjEuMTQnOlxuICAgICAgcmV0dXJuICdTSEEtMjI0J1xuICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xNSc6XG4gICAgICByZXR1cm4gJ1NIQTUxMi0yMjQnXG4gICAgY2FzZSAnMS4yLjg0MC4xMTM1NDkuMS4xLjE2JzpcbiAgICAgIHJldHVybiAnU0hBNTEyLTI1NidcbiAgICAvLyBFQ0RTQVxuICAgIGNhc2UgJzEuMi44NDAuMTAwNDUuNC4xJzpcbiAgICAgIHJldHVybiAnU0hBLTEnXG4gICAgY2FzZSAnMS4yLjg0MC4xMDA0NS40LjMuMSc6XG4gICAgICByZXR1cm4gJ1NIQS0yMjQnXG4gICAgY2FzZSAnMS4yLjg0MC4xMDA0NS40LjMuMic6XG4gICAgICByZXR1cm4gJ1NIQS0yNTYnXG4gICAgY2FzZSAnMS4yLjg0MC4xMDA0NS40LjMuMyc6XG4gICAgICByZXR1cm4gJ1NIQS0zODQnXG4gICAgY2FzZSAnMS4yLjg0MC4xMDA0NS40LjMuNCc6XG4gICAgICByZXR1cm4gJ1NIQS01MTInXG4gICAgLy8gUlNBU1NBLVBTUzogaGFzaCBpcyBpbmRpY2F0ZWQgc2VwYXJhdGVseVxuICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjEuMS4xMCc6IHtcbiAgICAgIGluZGV4ID0gaW5kZXhBZnRlck9JRFxuICAgICAgaW5kZXggPSBleHBlY3RBU04xU2VxKGRhdGEsIGluZGV4KS5pbmRleFxuICAgICAgaWYgKGRhdGFbaW5kZXgrK10gIT09IDB4YTApIHRocm93IHg1MDlFcnJvcignbm9uLXRhZyBkYXRhJywgZGF0YSkgLy8gYTAgPSBjb25zdHJ1Y3RlZCB0YWcgMFxuICAgICAgaW5kZXggPSByZWFkQVNOMUxlbmd0aChkYXRhLCBpbmRleCkuaW5kZXggLy8gc2tpcCBvdmVyIHRhZyBsZW5ndGggZmllbGRcbiAgICAgIGluZGV4ID0gZXhwZWN0QVNOMVNlcShkYXRhLCBpbmRleCkuaW5kZXggLy8gc2tpcCBvdmVyIHNlcXVlbmNlIGxlbmd0aCBmaWVsZFxuICAgICAgY29uc3QgeyBvaWQ6IGhhc2hPSUQgfSA9IHJlYWRBU04xT0lEKGRhdGEsIGluZGV4KVxuICAgICAgc3dpdGNoIChoYXNoT0lEKSB7XG4gICAgICAgIC8vIHN0YW5kYWxvbmUgaGFzaCBPSURzXG4gICAgICAgIGNhc2UgJzEuMi44NDAuMTEzNTQ5LjIuNSc6XG4gICAgICAgICAgcmV0dXJuICdNRDUnXG4gICAgICAgIGNhc2UgJzEuMy4xNC4zLjIuMjYnOlxuICAgICAgICAgIHJldHVybiAnU0hBLTEnXG4gICAgICAgIGNhc2UgJzIuMTYuODQwLjEuMTAxLjMuNC4yLjEnOlxuICAgICAgICAgIHJldHVybiAnU0hBLTI1NidcbiAgICAgICAgY2FzZSAnMi4xNi44NDAuMS4xMDEuMy40LjIuMic6XG4gICAgICAgICAgcmV0dXJuICdTSEEtMzg0J1xuICAgICAgICBjYXNlICcyLjE2Ljg0MC4xLjEwMS4zLjQuMi4zJzpcbiAgICAgICAgICByZXR1cm4gJ1NIQS01MTInXG4gICAgICB9XG4gICAgICB0aHJvdyB4NTA5RXJyb3IoJ3Vua25vd24gaGFzaCBPSUQgJyArIGhhc2hPSUQsIGRhdGEpXG4gICAgfVxuICAgIC8vIEVkMjU1MTkgLS0gc2VlIGh0dHBzOiByZXR1cm4vL2dpdGh1Yi5jb20vb3BlbnNzbC9vcGVuc3NsL2lzc3Vlcy8xNTQ3N1xuICAgIGNhc2UgJzEuMy4xMDEuMTEwJzpcbiAgICBjYXNlICcxLjMuMTAxLjExMic6IC8vIHBoXG4gICAgICByZXR1cm4gJ1NIQS01MTInXG4gICAgLy8gRWQ0NDggLS0gc3RpbGwgbm90IGluIHBnIDE3LjIgKGlmIHN1cHBvcnRlZCwgZGlnZXN0IHdvdWxkIGJlIFNIQUtFMjU2IHggNjQgYnl0ZXMpXG4gICAgY2FzZSAnMS4zLjEwMS4xMTEnOlxuICAgIGNhc2UgJzEuMy4xMDEuMTEzJzogLy8gcGhcbiAgICAgIHRocm93IHg1MDlFcnJvcignRWQ0NDggY2VydGlmaWNhdGUgY2hhbm5lbCBiaW5kaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IFBvc3RncmVzJylcbiAgfVxuICB0aHJvdyB4NTA5RXJyb3IoJ3Vua25vd24gT0lEICcgKyBvaWQsIGRhdGEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBzaWduYXR1cmVBbGdvcml0aG1IYXNoRnJvbUNlcnRpZmljYXRlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst crypto = __webpack_require__(/*! ./utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js\")\nconst { signatureAlgorithmHashFromCertificate } = __webpack_require__(/*! ./cert-signatures */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/cert-signatures.js\")\n\nfunction startSession(mechanisms, stream) {\n  const candidates = ['SCRAM-SHA-256']\n  if (stream) candidates.unshift('SCRAM-SHA-256-PLUS') // higher-priority, so placed first\n\n  const mechanism = candidates.find((candidate) => mechanisms.includes(candidate))\n\n  if (!mechanism) {\n    throw new Error('SASL: Only mechanism(s) ' + candidates.join(' and ') + ' are supported')\n  }\n\n  if (mechanism === 'SCRAM-SHA-256-PLUS' && typeof stream.getPeerCertificate !== 'function') {\n    // this should never happen if we are really talking to a Postgres server\n    throw new Error('SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate')\n  }\n\n  const clientNonce = crypto.randomBytes(18).toString('base64')\n  const gs2Header = mechanism === 'SCRAM-SHA-256-PLUS' ? 'p=tls-server-end-point' : stream ? 'y' : 'n'\n\n  return {\n    mechanism,\n    clientNonce,\n    response: gs2Header + ',,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse',\n  }\n}\n\nasync function continueSession(session, password, serverData, stream) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse')\n  }\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string')\n  }\n  if (password === '') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string')\n  }\n\n  const sv = parseServerFirstMessage(serverData)\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short')\n  }\n\n  const clientFirstMessageBare = 'n=*,r=' + session.clientNonce\n  const serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration\n\n  // without channel binding:\n  let channelBinding = stream ? 'eSws' : 'biws' // 'y,,' or 'n,,', base64-encoded\n\n  // override if channel binding is in use:\n  if (session.mechanism === 'SCRAM-SHA-256-PLUS') {\n    const peerCert = stream.getPeerCertificate().raw\n    let hashName = signatureAlgorithmHashFromCertificate(peerCert)\n    if (hashName === 'MD5' || hashName === 'SHA-1') hashName = 'SHA-256'\n    const certHash = await crypto.hashByName(hashName, peerCert)\n    const bindingData = Buffer.concat([Buffer.from('p=tls-server-end-point,,'), Buffer.from(certHash)])\n    channelBinding = bindingData.toString('base64')\n  }\n\n  const clientFinalMessageWithoutProof = 'c=' + channelBinding + ',r=' + sv.nonce\n  const authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof\n\n  const saltBytes = Buffer.from(sv.salt, 'base64')\n  const saltedPassword = await crypto.deriveKey(password, saltBytes, sv.iteration)\n  const clientKey = await crypto.hmacSha256(saltedPassword, 'Client Key')\n  const storedKey = await crypto.sha256(clientKey)\n  const clientSignature = await crypto.hmacSha256(storedKey, authMessage)\n  const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString('base64')\n  const serverKey = await crypto.hmacSha256(saltedPassword, 'Server Key')\n  const serverSignatureBytes = await crypto.hmacSha256(serverKey, authMessage)\n\n  session.message = 'SASLResponse'\n  session.serverSignature = Buffer.from(serverSignatureBytes).toString('base64')\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse')\n  }\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string')\n  }\n\n  const { serverSignature } = parseServerFinalMessage(serverData)\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')\n  }\n}\n\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string')\n  }\n  return text\n    .split('')\n    .map((_, i) => text.charCodeAt(i))\n    .every((c) => (c >= 0x21 && c <= 0x2b) || (c >= 0x2d && c <= 0x7e))\n}\n\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text)\n}\n\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string')\n  }\n\n  return new Map(\n    text.split(',').map((attrValue) => {\n      if (!/^.=/.test(attrValue)) {\n        throw new Error('SASL: Invalid attribute pair entry')\n      }\n      const name = attrValue[0]\n      const value = attrValue.substring(2)\n      return [name, value]\n    })\n  )\n}\n\nfunction parseServerFirstMessage(data) {\n  const attrPairs = parseAttributePairs(data)\n\n  const nonce = attrPairs.get('r')\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters')\n  }\n  const salt = attrPairs.get('s')\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64')\n  }\n  const iterationText = attrPairs.get('i')\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count')\n  }\n  const iteration = parseInt(iterationText, 10)\n\n  return {\n    nonce,\n    salt,\n    iteration,\n  }\n}\n\nfunction parseServerFinalMessage(serverData) {\n  const attrPairs = parseAttributePairs(serverData)\n  const serverSignature = attrPairs.get('v')\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing')\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64')\n  }\n  return {\n    serverSignature,\n  }\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer')\n  }\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer')\n  }\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match')\n  }\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty')\n  }\n  return Buffer.from(a.map((_, i) => a[i] ^ b[i]))\n}\n\nmodule.exports = {\n  startSession,\n  continueSession,\n  finalizeSession,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3Nhc2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsa0dBQVM7QUFDaEMsUUFBUSx3Q0FBd0MsRUFBRSxtQkFBTyxDQUFDLHNIQUFtQjs7QUFFN0U7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtCQUFrQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3Nhc2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IHsgc2lnbmF0dXJlQWxnb3JpdGhtSGFzaEZyb21DZXJ0aWZpY2F0ZSB9ID0gcmVxdWlyZSgnLi9jZXJ0LXNpZ25hdHVyZXMnKVxuXG5mdW5jdGlvbiBzdGFydFNlc3Npb24obWVjaGFuaXNtcywgc3RyZWFtKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbJ1NDUkFNLVNIQS0yNTYnXVxuICBpZiAoc3RyZWFtKSBjYW5kaWRhdGVzLnVuc2hpZnQoJ1NDUkFNLVNIQS0yNTYtUExVUycpIC8vIGhpZ2hlci1wcmlvcml0eSwgc28gcGxhY2VkIGZpcnN0XG5cbiAgY29uc3QgbWVjaGFuaXNtID0gY2FuZGlkYXRlcy5maW5kKChjYW5kaWRhdGUpID0+IG1lY2hhbmlzbXMuaW5jbHVkZXMoY2FuZGlkYXRlKSlcblxuICBpZiAoIW1lY2hhbmlzbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogT25seSBtZWNoYW5pc20ocykgJyArIGNhbmRpZGF0ZXMuam9pbignIGFuZCAnKSArICcgYXJlIHN1cHBvcnRlZCcpXG4gIH1cblxuICBpZiAobWVjaGFuaXNtID09PSAnU0NSQU0tU0hBLTI1Ni1QTFVTJyAmJiB0eXBlb2Ygc3RyZWFtLmdldFBlZXJDZXJ0aWZpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBpZiB3ZSBhcmUgcmVhbGx5IHRhbGtpbmcgdG8gYSBQb3N0Z3JlcyBzZXJ2ZXJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IE1lY2hhbmlzbSBTQ1JBTS1TSEEtMjU2LVBMVVMgcmVxdWlyZXMgYSBjZXJ0aWZpY2F0ZScpXG4gIH1cblxuICBjb25zdCBjbGllbnROb25jZSA9IGNyeXB0by5yYW5kb21CeXRlcygxOCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIGNvbnN0IGdzMkhlYWRlciA9IG1lY2hhbmlzbSA9PT0gJ1NDUkFNLVNIQS0yNTYtUExVUycgPyAncD10bHMtc2VydmVyLWVuZC1wb2ludCcgOiBzdHJlYW0gPyAneScgOiAnbidcblxuICByZXR1cm4ge1xuICAgIG1lY2hhbmlzbSxcbiAgICBjbGllbnROb25jZSxcbiAgICByZXNwb25zZTogZ3MySGVhZGVyICsgJywsbj0qLHI9JyArIGNsaWVudE5vbmNlLFxuICAgIG1lc3NhZ2U6ICdTQVNMSW5pdGlhbFJlc3BvbnNlJyxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb250aW51ZVNlc3Npb24oc2Vzc2lvbiwgcGFzc3dvcmQsIHNlcnZlckRhdGEsIHN0cmVhbSkge1xuICBpZiAoc2Vzc2lvbi5tZXNzYWdlICE9PSAnU0FTTEluaXRpYWxSZXNwb25zZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IExhc3QgbWVzc2FnZSB3YXMgbm90IFNBU0xJbml0aWFsUmVzcG9uc2UnKVxuICB9XG4gIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTQVNMOiBTQ1JBTS1TRVJWRVItRklSU1QtTUVTU0FHRTogY2xpZW50IHBhc3N3b3JkIG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG4gIGlmIChwYXNzd29yZCA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IFNDUkFNLVNFUlZFUi1GSVJTVC1NRVNTQUdFOiBjbGllbnQgcGFzc3dvcmQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKVxuICB9XG4gIGlmICh0eXBlb2Ygc2VydmVyRGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IFNDUkFNLVNFUlZFUi1GSVJTVC1NRVNTQUdFOiBzZXJ2ZXJEYXRhIG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgY29uc3Qgc3YgPSBwYXJzZVNlcnZlckZpcnN0TWVzc2FnZShzZXJ2ZXJEYXRhKVxuXG4gIGlmICghc3Yubm9uY2Uuc3RhcnRzV2l0aChzZXNzaW9uLmNsaWVudE5vbmNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJUlNULU1FU1NBR0U6IHNlcnZlciBub25jZSBkb2VzIG5vdCBzdGFydCB3aXRoIGNsaWVudCBub25jZScpXG4gIH0gZWxzZSBpZiAoc3Yubm9uY2UubGVuZ3RoID09PSBzZXNzaW9uLmNsaWVudE5vbmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJUlNULU1FU1NBR0U6IHNlcnZlciBub25jZSBpcyB0b28gc2hvcnQnKVxuICB9XG5cbiAgY29uc3QgY2xpZW50Rmlyc3RNZXNzYWdlQmFyZSA9ICduPSoscj0nICsgc2Vzc2lvbi5jbGllbnROb25jZVxuICBjb25zdCBzZXJ2ZXJGaXJzdE1lc3NhZ2UgPSAncj0nICsgc3Yubm9uY2UgKyAnLHM9JyArIHN2LnNhbHQgKyAnLGk9JyArIHN2Lml0ZXJhdGlvblxuXG4gIC8vIHdpdGhvdXQgY2hhbm5lbCBiaW5kaW5nOlxuICBsZXQgY2hhbm5lbEJpbmRpbmcgPSBzdHJlYW0gPyAnZVN3cycgOiAnYml3cycgLy8gJ3ksLCcgb3IgJ24sLCcsIGJhc2U2NC1lbmNvZGVkXG5cbiAgLy8gb3ZlcnJpZGUgaWYgY2hhbm5lbCBiaW5kaW5nIGlzIGluIHVzZTpcbiAgaWYgKHNlc3Npb24ubWVjaGFuaXNtID09PSAnU0NSQU0tU0hBLTI1Ni1QTFVTJykge1xuICAgIGNvbnN0IHBlZXJDZXJ0ID0gc3RyZWFtLmdldFBlZXJDZXJ0aWZpY2F0ZSgpLnJhd1xuICAgIGxldCBoYXNoTmFtZSA9IHNpZ25hdHVyZUFsZ29yaXRobUhhc2hGcm9tQ2VydGlmaWNhdGUocGVlckNlcnQpXG4gICAgaWYgKGhhc2hOYW1lID09PSAnTUQ1JyB8fCBoYXNoTmFtZSA9PT0gJ1NIQS0xJykgaGFzaE5hbWUgPSAnU0hBLTI1NidcbiAgICBjb25zdCBjZXJ0SGFzaCA9IGF3YWl0IGNyeXB0by5oYXNoQnlOYW1lKGhhc2hOYW1lLCBwZWVyQ2VydClcbiAgICBjb25zdCBiaW5kaW5nRGF0YSA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCdwPXRscy1zZXJ2ZXItZW5kLXBvaW50LCwnKSwgQnVmZmVyLmZyb20oY2VydEhhc2gpXSlcbiAgICBjaGFubmVsQmluZGluZyA9IGJpbmRpbmdEYXRhLnRvU3RyaW5nKCdiYXNlNjQnKVxuICB9XG5cbiAgY29uc3QgY2xpZW50RmluYWxNZXNzYWdlV2l0aG91dFByb29mID0gJ2M9JyArIGNoYW5uZWxCaW5kaW5nICsgJyxyPScgKyBzdi5ub25jZVxuICBjb25zdCBhdXRoTWVzc2FnZSA9IGNsaWVudEZpcnN0TWVzc2FnZUJhcmUgKyAnLCcgKyBzZXJ2ZXJGaXJzdE1lc3NhZ2UgKyAnLCcgKyBjbGllbnRGaW5hbE1lc3NhZ2VXaXRob3V0UHJvb2ZcblxuICBjb25zdCBzYWx0Qnl0ZXMgPSBCdWZmZXIuZnJvbShzdi5zYWx0LCAnYmFzZTY0JylcbiAgY29uc3Qgc2FsdGVkUGFzc3dvcmQgPSBhd2FpdCBjcnlwdG8uZGVyaXZlS2V5KHBhc3N3b3JkLCBzYWx0Qnl0ZXMsIHN2Lml0ZXJhdGlvbilcbiAgY29uc3QgY2xpZW50S2V5ID0gYXdhaXQgY3J5cHRvLmhtYWNTaGEyNTYoc2FsdGVkUGFzc3dvcmQsICdDbGllbnQgS2V5JylcbiAgY29uc3Qgc3RvcmVkS2V5ID0gYXdhaXQgY3J5cHRvLnNoYTI1NihjbGllbnRLZXkpXG4gIGNvbnN0IGNsaWVudFNpZ25hdHVyZSA9IGF3YWl0IGNyeXB0by5obWFjU2hhMjU2KHN0b3JlZEtleSwgYXV0aE1lc3NhZ2UpXG4gIGNvbnN0IGNsaWVudFByb29mID0geG9yQnVmZmVycyhCdWZmZXIuZnJvbShjbGllbnRLZXkpLCBCdWZmZXIuZnJvbShjbGllbnRTaWduYXR1cmUpKS50b1N0cmluZygnYmFzZTY0JylcbiAgY29uc3Qgc2VydmVyS2V5ID0gYXdhaXQgY3J5cHRvLmhtYWNTaGEyNTYoc2FsdGVkUGFzc3dvcmQsICdTZXJ2ZXIgS2V5JylcbiAgY29uc3Qgc2VydmVyU2lnbmF0dXJlQnl0ZXMgPSBhd2FpdCBjcnlwdG8uaG1hY1NoYTI1NihzZXJ2ZXJLZXksIGF1dGhNZXNzYWdlKVxuXG4gIHNlc3Npb24ubWVzc2FnZSA9ICdTQVNMUmVzcG9uc2UnXG4gIHNlc3Npb24uc2VydmVyU2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2VydmVyU2lnbmF0dXJlQnl0ZXMpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICBzZXNzaW9uLnJlc3BvbnNlID0gY2xpZW50RmluYWxNZXNzYWdlV2l0aG91dFByb29mICsgJyxwPScgKyBjbGllbnRQcm9vZlxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVNlc3Npb24oc2Vzc2lvbiwgc2VydmVyRGF0YSkge1xuICBpZiAoc2Vzc2lvbi5tZXNzYWdlICE9PSAnU0FTTFJlc3BvbnNlJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogTGFzdCBtZXNzYWdlIHdhcyBub3QgU0FTTFJlc3BvbnNlJylcbiAgfVxuICBpZiAodHlwZW9mIHNlcnZlckRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTQVNMOiBTQ1JBTS1TRVJWRVItRklOQUwtTUVTU0FHRTogc2VydmVyRGF0YSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgfVxuXG4gIGNvbnN0IHsgc2VydmVyU2lnbmF0dXJlIH0gPSBwYXJzZVNlcnZlckZpbmFsTWVzc2FnZShzZXJ2ZXJEYXRhKVxuXG4gIGlmIChzZXJ2ZXJTaWduYXR1cmUgIT09IHNlc3Npb24uc2VydmVyU2lnbmF0dXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTQVNMOiBTQ1JBTS1TRVJWRVItRklOQUwtTUVTU0FHRTogc2VydmVyIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCcpXG4gIH1cbn1cblxuLyoqXG4gKiBwcmludGFibGUgICAgICAgPSAleDIxLTJCIC8gJXgyRC03RVxuICogICAgICAgICAgICAgICAgICAgOzsgUHJpbnRhYmxlIEFTQ0lJIGV4Y2VwdCBcIixcIi5cbiAqICAgICAgICAgICAgICAgICAgIDs7IE5vdGUgdGhhdCBhbnkgXCJwcmludGFibGVcIiBpcyBhbHNvXG4gKiAgICAgICAgICAgICAgICAgICA7OyBhIHZhbGlkIFwidmFsdWVcIi5cbiAqL1xuZnVuY3Rpb24gaXNQcmludGFibGVDaGFycyh0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTQVNMOiB0ZXh0IG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG4gIHJldHVybiB0ZXh0XG4gICAgLnNwbGl0KCcnKVxuICAgIC5tYXAoKF8sIGkpID0+IHRleHQuY2hhckNvZGVBdChpKSlcbiAgICAuZXZlcnkoKGMpID0+IChjID49IDB4MjEgJiYgYyA8PSAweDJiKSB8fCAoYyA+PSAweDJkICYmIGMgPD0gMHg3ZSkpXG59XG5cbi8qKlxuICogYmFzZTY0LWNoYXIgICAgID0gQUxQSEEgLyBESUdJVCAvIFwiL1wiIC8gXCIrXCJcbiAqXG4gKiBiYXNlNjQtNCAgICAgICAgPSA0YmFzZTY0LWNoYXJcbiAqXG4gKiBiYXNlNjQtMyAgICAgICAgPSAzYmFzZTY0LWNoYXIgXCI9XCJcbiAqXG4gKiBiYXNlNjQtMiAgICAgICAgPSAyYmFzZTY0LWNoYXIgXCI9PVwiXG4gKlxuICogYmFzZTY0ICAgICAgICAgID0gKmJhc2U2NC00IFtiYXNlNjQtMyAvIGJhc2U2NC0yXVxuICovXG5mdW5jdGlvbiBpc0Jhc2U2NCh0ZXh0KSB7XG4gIHJldHVybiAvXig/OlthLXpBLVowLTkrL117NH0pKig/OlthLXpBLVowLTkrL117Mn09PXxbYS16QS1aMC05Ky9dezN9PSk/JC8udGVzdCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVBhaXJzKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NBU0w6IGF0dHJpYnV0ZSBwYWlycyB0ZXh0IG11c3QgYmUgYSBzdHJpbmcnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNYXAoXG4gICAgdGV4dC5zcGxpdCgnLCcpLm1hcCgoYXR0clZhbHVlKSA9PiB7XG4gICAgICBpZiAoIS9eLj0vLnRlc3QoYXR0clZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IEludmFsaWQgYXR0cmlidXRlIHBhaXIgZW50cnknKVxuICAgICAgfVxuICAgICAgY29uc3QgbmFtZSA9IGF0dHJWYWx1ZVswXVxuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWUuc3Vic3RyaW5nKDIpXG4gICAgICByZXR1cm4gW25hbWUsIHZhbHVlXVxuICAgIH0pXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VTZXJ2ZXJGaXJzdE1lc3NhZ2UoZGF0YSkge1xuICBjb25zdCBhdHRyUGFpcnMgPSBwYXJzZUF0dHJpYnV0ZVBhaXJzKGRhdGEpXG5cbiAgY29uc3Qgbm9uY2UgPSBhdHRyUGFpcnMuZ2V0KCdyJylcbiAgaWYgKCFub25jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJUlNULU1FU1NBR0U6IG5vbmNlIG1pc3NpbmcnKVxuICB9IGVsc2UgaWYgKCFpc1ByaW50YWJsZUNoYXJzKG5vbmNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJUlNULU1FU1NBR0U6IG5vbmNlIG11c3Qgb25seSBjb250YWluIHByaW50YWJsZSBjaGFyYWN0ZXJzJylcbiAgfVxuICBjb25zdCBzYWx0ID0gYXR0clBhaXJzLmdldCgncycpXG4gIGlmICghc2FsdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJUlNULU1FU1NBR0U6IHNhbHQgbWlzc2luZycpXG4gIH0gZWxzZSBpZiAoIWlzQmFzZTY0KHNhbHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTQVNMOiBTQ1JBTS1TRVJWRVItRklSU1QtTUVTU0FHRTogc2FsdCBtdXN0IGJlIGJhc2U2NCcpXG4gIH1cbiAgY29uc3QgaXRlcmF0aW9uVGV4dCA9IGF0dHJQYWlycy5nZXQoJ2knKVxuICBpZiAoIWl0ZXJhdGlvblRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IFNDUkFNLVNFUlZFUi1GSVJTVC1NRVNTQUdFOiBpdGVyYXRpb24gbWlzc2luZycpXG4gIH0gZWxzZSBpZiAoIS9eWzEtOV1bMC05XSokLy50ZXN0KGl0ZXJhdGlvblRleHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTQVNMOiBTQ1JBTS1TRVJWRVItRklSU1QtTUVTU0FHRTogaW52YWxpZCBpdGVyYXRpb24gY291bnQnKVxuICB9XG4gIGNvbnN0IGl0ZXJhdGlvbiA9IHBhcnNlSW50KGl0ZXJhdGlvblRleHQsIDEwKVxuXG4gIHJldHVybiB7XG4gICAgbm9uY2UsXG4gICAgc2FsdCxcbiAgICBpdGVyYXRpb24sXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTZXJ2ZXJGaW5hbE1lc3NhZ2Uoc2VydmVyRGF0YSkge1xuICBjb25zdCBhdHRyUGFpcnMgPSBwYXJzZUF0dHJpYnV0ZVBhaXJzKHNlcnZlckRhdGEpXG4gIGNvbnN0IHNlcnZlclNpZ25hdHVyZSA9IGF0dHJQYWlycy5nZXQoJ3YnKVxuICBpZiAoIXNlcnZlclNpZ25hdHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU0FTTDogU0NSQU0tU0VSVkVSLUZJTkFMLU1FU1NBR0U6IHNlcnZlciBzaWduYXR1cmUgaXMgbWlzc2luZycpXG4gIH0gZWxzZSBpZiAoIWlzQmFzZTY0KHNlcnZlclNpZ25hdHVyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NBU0w6IFNDUkFNLVNFUlZFUi1GSU5BTC1NRVNTQUdFOiBzZXJ2ZXIgc2lnbmF0dXJlIG11c3QgYmUgYmFzZTY0JylcbiAgfVxuICByZXR1cm4ge1xuICAgIHNlcnZlclNpZ25hdHVyZSxcbiAgfVxufVxuXG5mdW5jdGlvbiB4b3JCdWZmZXJzKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NlY29uZCBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgbGVuZ3RocyBtdXN0IG1hdGNoJylcbiAgfVxuICBpZiAoYS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlcnMgY2Fubm90IGJlIGVtcHR5JylcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oYS5tYXAoKF8sIGkpID0+IGFbaV0gXiBiW2ldKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YXJ0U2Vzc2lvbixcbiAgY29udGludWVTZXNzaW9uLFxuICBmaW5hbGl6ZVNlc3Npb24sXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/sasl.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// This file contains crypto utility functions for versions of Node.js < 15.0.0,\n// which does not support the WebCrypto.subtle API.\n\nconst nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nfunction md5(string) {\n  return nodeCrypto.createHash('md5').update(string, 'utf-8').digest('hex')\n}\n\n// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html\nfunction postgresMd5PasswordHash(user, password, salt) {\n  const inner = md5(password + user)\n  const outer = md5(Buffer.concat([Buffer.from(inner), salt]))\n  return 'md5' + outer\n}\n\nfunction sha256(text) {\n  return nodeCrypto.createHash('sha256').update(text).digest()\n}\n\nfunction hashByName(hashName, text) {\n  hashName = hashName.replace(/(\\D)-/, '$1') // e.g. SHA-256 -> SHA256\n  return nodeCrypto.createHash(hashName).update(text).digest()\n}\n\nfunction hmacSha256(key, msg) {\n  return nodeCrypto.createHmac('sha256', key).update(msg).digest()\n}\n\nasync function deriveKey(password, salt, iterations) {\n  return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, 'sha256')\n}\n\nmodule.exports = {\n  postgresMd5PasswordHash,\n  randomBytes: nodeCrypto.randomBytes,\n  deriveKey,\n  sha256,\n  hashByName,\n  hmacSha256,\n  md5,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3V0aWxzLWxlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9jcnlwdG8vdXRpbHMtbGVnYWN5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIGNyeXB0byB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgdmVyc2lvbnMgb2YgTm9kZS5qcyA8IDE1LjAuMCxcbi8vIHdoaWNoIGRvZXMgbm90IHN1cHBvcnQgdGhlIFdlYkNyeXB0by5zdWJ0bGUgQVBJLlxuXG5jb25zdCBub2RlQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcblxuZnVuY3Rpb24gbWQ1KHN0cmluZykge1xuICByZXR1cm4gbm9kZUNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKS51cGRhdGUoc3RyaW5nLCAndXRmLTgnKS5kaWdlc3QoJ2hleCcpXG59XG5cbi8vIFNlZSBBdXRoZW50aWNhdGlvbk1ENVBhc3N3b3JkIGF0IGh0dHBzOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvY3VycmVudC9zdGF0aWMvcHJvdG9jb2wtZmxvdy5odG1sXG5mdW5jdGlvbiBwb3N0Z3Jlc01kNVBhc3N3b3JkSGFzaCh1c2VyLCBwYXNzd29yZCwgc2FsdCkge1xuICBjb25zdCBpbm5lciA9IG1kNShwYXNzd29yZCArIHVzZXIpXG4gIGNvbnN0IG91dGVyID0gbWQ1KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGlubmVyKSwgc2FsdF0pKVxuICByZXR1cm4gJ21kNScgKyBvdXRlclxufVxuXG5mdW5jdGlvbiBzaGEyNTYodGV4dCkge1xuICByZXR1cm4gbm9kZUNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUodGV4dCkuZGlnZXN0KClcbn1cblxuZnVuY3Rpb24gaGFzaEJ5TmFtZShoYXNoTmFtZSwgdGV4dCkge1xuICBoYXNoTmFtZSA9IGhhc2hOYW1lLnJlcGxhY2UoLyhcXEQpLS8sICckMScpIC8vIGUuZy4gU0hBLTI1NiAtPiBTSEEyNTZcbiAgcmV0dXJuIG5vZGVDcnlwdG8uY3JlYXRlSGFzaChoYXNoTmFtZSkudXBkYXRlKHRleHQpLmRpZ2VzdCgpXG59XG5cbmZ1bmN0aW9uIGhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgcmV0dXJuIG5vZGVDcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKVxufVxuXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVLZXkocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMpIHtcbiAgcmV0dXJuIG5vZGVDcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgaXRlcmF0aW9ucywgMzIsICdzaGEyNTYnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9zdGdyZXNNZDVQYXNzd29yZEhhc2gsXG4gIHJhbmRvbUJ5dGVzOiBub2RlQ3J5cHRvLnJhbmRvbUJ5dGVzLFxuICBkZXJpdmVLZXksXG4gIHNoYTI1NixcbiAgaGFzaEJ5TmFtZSxcbiAgaG1hY1NoYTI1NixcbiAgbWQ1LFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const nodeCrypto = __webpack_require__(/*! crypto */ \"crypto\")\n\nmodule.exports = {\n  postgresMd5PasswordHash,\n  randomBytes,\n  deriveKey,\n  sha256,\n  hashByName,\n  hmacSha256,\n  md5,\n}\n\n/**\n * The Web Crypto API - grabbed from the Node.js library or the global\n * @type Crypto\n */\n// eslint-disable-next-line no-undef\nconst webCrypto = nodeCrypto.webcrypto || globalThis.crypto\n/**\n * The SubtleCrypto API for low level crypto operations.\n * @type SubtleCrypto\n */\nconst subtleCrypto = webCrypto.subtle\nconst textEncoder = new TextEncoder()\n\n/**\n *\n * @param {*} length\n * @returns\n */\nfunction randomBytes(length) {\n  return webCrypto.getRandomValues(Buffer.alloc(length))\n}\n\nasync function md5(string) {\n  try {\n    return nodeCrypto.createHash('md5').update(string, 'utf-8').digest('hex')\n  } catch (e) {\n    // `createHash()` failed so we are probably not in Node.js, use the WebCrypto API instead.\n    // Note that the MD5 algorithm on WebCrypto is not available in Node.js.\n    // This is why we cannot just use WebCrypto in all environments.\n    const data = typeof string === 'string' ? textEncoder.encode(string) : string\n    const hash = await subtleCrypto.digest('MD5', data)\n    return Array.from(new Uint8Array(hash))\n      .map((b) => b.toString(16).padStart(2, '0'))\n      .join('')\n  }\n}\n\n// See AuthenticationMD5Password at https://www.postgresql.org/docs/current/static/protocol-flow.html\nasync function postgresMd5PasswordHash(user, password, salt) {\n  const inner = await md5(password + user)\n  const outer = await md5(Buffer.concat([Buffer.from(inner), salt]))\n  return 'md5' + outer\n}\n\n/**\n * Create a SHA-256 digest of the given data\n * @param {Buffer} data\n */\nasync function sha256(text) {\n  return await subtleCrypto.digest('SHA-256', text)\n}\n\nasync function hashByName(hashName, text) {\n  return await subtleCrypto.digest(hashName, text)\n}\n\n/**\n * Sign the message with the given key\n * @param {ArrayBuffer} keyBuffer\n * @param {string} msg\n */\nasync function hmacSha256(keyBuffer, msg) {\n  const key = await subtleCrypto.importKey('raw', keyBuffer, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign'])\n  return await subtleCrypto.sign('HMAC', key, textEncoder.encode(msg))\n}\n\n/**\n * Derive a key from the password and salt\n * @param {string} password\n * @param {Uint8Array} salt\n * @param {number} iterations\n */\nasync function deriveKey(password, salt, iterations) {\n  const key = await subtleCrypto.importKey('raw', textEncoder.encode(password), 'PBKDF2', false, ['deriveBits'])\n  const params = { name: 'PBKDF2', hash: 'SHA-256', salt: salt, iterations: iterations }\n  return await subtleCrypto.deriveBits(params, key, 32 * 8, ['deriveBits'])\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3V0aWxzLXdlYmNyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSwrREFBK0QsK0JBQStCO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9jcnlwdG8vdXRpbHMtd2ViY3J5cHRvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG5vZGVDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9zdGdyZXNNZDVQYXNzd29yZEhhc2gsXG4gIHJhbmRvbUJ5dGVzLFxuICBkZXJpdmVLZXksXG4gIHNoYTI1NixcbiAgaGFzaEJ5TmFtZSxcbiAgaG1hY1NoYTI1NixcbiAgbWQ1LFxufVxuXG4vKipcbiAqIFRoZSBXZWIgQ3J5cHRvIEFQSSAtIGdyYWJiZWQgZnJvbSB0aGUgTm9kZS5qcyBsaWJyYXJ5IG9yIHRoZSBnbG9iYWxcbiAqIEB0eXBlIENyeXB0b1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbmNvbnN0IHdlYkNyeXB0byA9IG5vZGVDcnlwdG8ud2ViY3J5cHRvIHx8IGdsb2JhbFRoaXMuY3J5cHRvXG4vKipcbiAqIFRoZSBTdWJ0bGVDcnlwdG8gQVBJIGZvciBsb3cgbGV2ZWwgY3J5cHRvIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSBTdWJ0bGVDcnlwdG9cbiAqL1xuY29uc3Qgc3VidGxlQ3J5cHRvID0gd2ViQ3J5cHRvLnN1YnRsZVxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG4gIHJldHVybiB3ZWJDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKEJ1ZmZlci5hbGxvYyhsZW5ndGgpKVxufVxuXG5hc3luYyBmdW5jdGlvbiBtZDUoc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5vZGVDcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKHN0cmluZywgJ3V0Zi04JykuZGlnZXN0KCdoZXgnKVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gYGNyZWF0ZUhhc2goKWAgZmFpbGVkIHNvIHdlIGFyZSBwcm9iYWJseSBub3QgaW4gTm9kZS5qcywgdXNlIHRoZSBXZWJDcnlwdG8gQVBJIGluc3RlYWQuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBNRDUgYWxnb3JpdGhtIG9uIFdlYkNyeXB0byBpcyBub3QgYXZhaWxhYmxlIGluIE5vZGUuanMuXG4gICAgLy8gVGhpcyBpcyB3aHkgd2UgY2Fubm90IGp1c3QgdXNlIFdlYkNyeXB0byBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICAgIGNvbnN0IGRhdGEgPSB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHRleHRFbmNvZGVyLmVuY29kZShzdHJpbmcpIDogc3RyaW5nXG4gICAgY29uc3QgaGFzaCA9IGF3YWl0IHN1YnRsZUNyeXB0by5kaWdlc3QoJ01ENScsIGRhdGEpXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaCkpXG4gICAgICAubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgLmpvaW4oJycpXG4gIH1cbn1cblxuLy8gU2VlIEF1dGhlbnRpY2F0aW9uTUQ1UGFzc3dvcmQgYXQgaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L3N0YXRpYy9wcm90b2NvbC1mbG93Lmh0bWxcbmFzeW5jIGZ1bmN0aW9uIHBvc3RncmVzTWQ1UGFzc3dvcmRIYXNoKHVzZXIsIHBhc3N3b3JkLCBzYWx0KSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgbWQ1KHBhc3N3b3JkICsgdXNlcilcbiAgY29uc3Qgb3V0ZXIgPSBhd2FpdCBtZDUoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oaW5uZXIpLCBzYWx0XSkpXG4gIHJldHVybiAnbWQ1JyArIG91dGVyXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgU0hBLTI1NiBkaWdlc3Qgb2YgdGhlIGdpdmVuIGRhdGFcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNoYTI1Nih0ZXh0KSB7XG4gIHJldHVybiBhd2FpdCBzdWJ0bGVDcnlwdG8uZGlnZXN0KCdTSEEtMjU2JywgdGV4dClcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFzaEJ5TmFtZShoYXNoTmFtZSwgdGV4dCkge1xuICByZXR1cm4gYXdhaXQgc3VidGxlQ3J5cHRvLmRpZ2VzdChoYXNoTmFtZSwgdGV4dClcbn1cblxuLyoqXG4gKiBTaWduIHRoZSBtZXNzYWdlIHdpdGggdGhlIGdpdmVuIGtleVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0ga2V5QnVmZmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhtYWNTaGEyNTYoa2V5QnVmZmVyLCBtc2cpIHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgc3VidGxlQ3J5cHRvLmltcG9ydEtleSgncmF3Jywga2V5QnVmZmVyLCB7IG5hbWU6ICdITUFDJywgaGFzaDogJ1NIQS0yNTYnIH0sIGZhbHNlLCBbJ3NpZ24nXSlcbiAgcmV0dXJuIGF3YWl0IHN1YnRsZUNyeXB0by5zaWduKCdITUFDJywga2V5LCB0ZXh0RW5jb2Rlci5lbmNvZGUobXNnKSlcbn1cblxuLyoqXG4gKiBEZXJpdmUgYSBrZXkgZnJvbSB0aGUgcGFzc3dvcmQgYW5kIHNhbHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzYWx0XG4gKiBAcGFyYW0ge251bWJlcn0gaXRlcmF0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVLZXkocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMpIHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgc3VidGxlQ3J5cHRvLmltcG9ydEtleSgncmF3JywgdGV4dEVuY29kZXIuZW5jb2RlKHBhc3N3b3JkKSwgJ1BCS0RGMicsIGZhbHNlLCBbJ2Rlcml2ZUJpdHMnXSlcbiAgY29uc3QgcGFyYW1zID0geyBuYW1lOiAnUEJLREYyJywgaGFzaDogJ1NIQS0yNTYnLCBzYWx0OiBzYWx0LCBpdGVyYXRpb25zOiBpdGVyYXRpb25zIH1cbiAgcmV0dXJuIGF3YWl0IHN1YnRsZUNyeXB0by5kZXJpdmVCaXRzKHBhcmFtcywga2V5LCAzMiAqIDgsIFsnZGVyaXZlQml0cyddKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split('.')[0]) < 15\nif (useLegacyCrypto) {\n  // We are on an old version of Node.js that requires legacy crypto utilities.\n  module.exports = __webpack_require__(/*! ./utils-legacy */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-legacy.js\")\n} else {\n  module.exports = __webpack_require__(/*! ./utils-webcrypto */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils-webcrypto.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0pBQTBDO0FBQzVDLEVBQUU7QUFDRixFQUFFLDRKQUE2QztBQUMvQyIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvY3J5cHRvL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1c2VMZWdhY3lDcnlwdG8gPSBwYXJzZUludChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPCAxNVxuaWYgKHVzZUxlZ2FjeUNyeXB0bykge1xuICAvLyBXZSBhcmUgb24gYW4gb2xkIHZlcnNpb24gb2YgTm9kZS5qcyB0aGF0IHJlcXVpcmVzIGxlZ2FjeSBjcnlwdG8gdXRpbGl0aWVzLlxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdXRpbHMtbGVnYWN5Jylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi91dGlscy13ZWJjcnlwdG8nKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/crypto/utils.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  // database host. defaults to localhost\n  host: 'localhost',\n\n  // database user's name\n  user: process.platform === 'win32' ? process.env.USERNAME : process.env.USER,\n\n  // name of database to connect\n  database: undefined,\n\n  // database user's password\n  password: null,\n\n  // a Postgres connection string to be used instead of setting individual connection items\n  // NOTE:  Setting this value will cause it to override any other value (such as database or user) defined\n  // in the defaults object.\n  connectionString: undefined,\n\n  // database port\n  port: 5432,\n\n  // number of rows to return at a time from a prepared statement's\n  // portal. 0 will return all rows at once\n  rows: 0,\n\n  // binary result mode\n  binary: false,\n\n  // Connection pool options - see https://github.com/brianc/node-pg-pool\n\n  // number of connections to use in connection pool\n  // 0 will disable connection pooling\n  max: 10,\n\n  // max milliseconds a client can go unused before it is removed\n  // from the pool and destroyed\n  idleTimeoutMillis: 30000,\n\n  client_encoding: '',\n\n  ssl: false,\n\n  application_name: undefined,\n\n  fallback_application_name: undefined,\n\n  options: undefined,\n\n  parseInputDatesAsUTC: false,\n\n  // max milliseconds any query using this connection will execute for before timing out in error.\n  // false=unlimited\n  statement_timeout: false,\n\n  // Abort any statement that waits longer than the specified duration in milliseconds while attempting to acquire a lock.\n  // false=unlimited\n  lock_timeout: false,\n\n  // Terminate any session with an open transaction that has been idle for longer than the specified duration in milliseconds\n  // false=unlimited\n  idle_in_transaction_session_timeout: false,\n\n  // max milliseconds to wait for query to complete (client side)\n  query_timeout: false,\n\n  connect_timeout: 0,\n\n  keepalives: 1,\n\n  keepalives_idle: 0,\n}\n\nconst pgTypes = __webpack_require__(/*! pg-types */ \"(api-node)/../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js\")\n// save default parsers\nconst parseBigInteger = pgTypes.getTypeParser(20, 'text')\nconst parseBigIntegerArray = pgTypes.getTypeParser(1016, 'text')\n\n// parse int8 so you can get your count values as actual numbers\nmodule.exports.__defineSetter__('parseInt8', function (val) {\n  pgTypes.setTypeParser(20, 'text', val ? pgTypes.getTypeParser(23, 'text') : parseBigInteger)\n  pgTypes.setTypeParser(1016, 'text', val ? pgTypes.getTypeParser(1007, 'text') : parseBigIntegerArray)\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsbUdBQVU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvZGVmYXVsdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkYXRhYmFzZSBob3N0LiBkZWZhdWx0cyB0byBsb2NhbGhvc3RcbiAgaG9zdDogJ2xvY2FsaG9zdCcsXG5cbiAgLy8gZGF0YWJhc2UgdXNlcidzIG5hbWVcbiAgdXNlcjogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IHByb2Nlc3MuZW52LlVTRVJOQU1FIDogcHJvY2Vzcy5lbnYuVVNFUixcblxuICAvLyBuYW1lIG9mIGRhdGFiYXNlIHRvIGNvbm5lY3RcbiAgZGF0YWJhc2U6IHVuZGVmaW5lZCxcblxuICAvLyBkYXRhYmFzZSB1c2VyJ3MgcGFzc3dvcmRcbiAgcGFzc3dvcmQ6IG51bGwsXG5cbiAgLy8gYSBQb3N0Z3JlcyBjb25uZWN0aW9uIHN0cmluZyB0byBiZSB1c2VkIGluc3RlYWQgb2Ygc2V0dGluZyBpbmRpdmlkdWFsIGNvbm5lY3Rpb24gaXRlbXNcbiAgLy8gTk9URTogIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGNhdXNlIGl0IHRvIG92ZXJyaWRlIGFueSBvdGhlciB2YWx1ZSAoc3VjaCBhcyBkYXRhYmFzZSBvciB1c2VyKSBkZWZpbmVkXG4gIC8vIGluIHRoZSBkZWZhdWx0cyBvYmplY3QuXG4gIGNvbm5lY3Rpb25TdHJpbmc6IHVuZGVmaW5lZCxcblxuICAvLyBkYXRhYmFzZSBwb3J0XG4gIHBvcnQ6IDU0MzIsXG5cbiAgLy8gbnVtYmVyIG9mIHJvd3MgdG8gcmV0dXJuIGF0IGEgdGltZSBmcm9tIGEgcHJlcGFyZWQgc3RhdGVtZW50J3NcbiAgLy8gcG9ydGFsLiAwIHdpbGwgcmV0dXJuIGFsbCByb3dzIGF0IG9uY2VcbiAgcm93czogMCxcblxuICAvLyBiaW5hcnkgcmVzdWx0IG1vZGVcbiAgYmluYXJ5OiBmYWxzZSxcblxuICAvLyBDb25uZWN0aW9uIHBvb2wgb3B0aW9ucyAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJpYW5jL25vZGUtcGctcG9vbFxuXG4gIC8vIG51bWJlciBvZiBjb25uZWN0aW9ucyB0byB1c2UgaW4gY29ubmVjdGlvbiBwb29sXG4gIC8vIDAgd2lsbCBkaXNhYmxlIGNvbm5lY3Rpb24gcG9vbGluZ1xuICBtYXg6IDEwLFxuXG4gIC8vIG1heCBtaWxsaXNlY29uZHMgYSBjbGllbnQgY2FuIGdvIHVudXNlZCBiZWZvcmUgaXQgaXMgcmVtb3ZlZFxuICAvLyBmcm9tIHRoZSBwb29sIGFuZCBkZXN0cm95ZWRcbiAgaWRsZVRpbWVvdXRNaWxsaXM6IDMwMDAwLFxuXG4gIGNsaWVudF9lbmNvZGluZzogJycsXG5cbiAgc3NsOiBmYWxzZSxcblxuICBhcHBsaWNhdGlvbl9uYW1lOiB1bmRlZmluZWQsXG5cbiAgZmFsbGJhY2tfYXBwbGljYXRpb25fbmFtZTogdW5kZWZpbmVkLFxuXG4gIG9wdGlvbnM6IHVuZGVmaW5lZCxcblxuICBwYXJzZUlucHV0RGF0ZXNBc1VUQzogZmFsc2UsXG5cbiAgLy8gbWF4IG1pbGxpc2Vjb25kcyBhbnkgcXVlcnkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIHdpbGwgZXhlY3V0ZSBmb3IgYmVmb3JlIHRpbWluZyBvdXQgaW4gZXJyb3IuXG4gIC8vIGZhbHNlPXVubGltaXRlZFxuICBzdGF0ZW1lbnRfdGltZW91dDogZmFsc2UsXG5cbiAgLy8gQWJvcnQgYW55IHN0YXRlbWVudCB0aGF0IHdhaXRzIGxvbmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoaWxlIGF0dGVtcHRpbmcgdG8gYWNxdWlyZSBhIGxvY2suXG4gIC8vIGZhbHNlPXVubGltaXRlZFxuICBsb2NrX3RpbWVvdXQ6IGZhbHNlLFxuXG4gIC8vIFRlcm1pbmF0ZSBhbnkgc2Vzc2lvbiB3aXRoIGFuIG9wZW4gdHJhbnNhY3Rpb24gdGhhdCBoYXMgYmVlbiBpZGxlIGZvciBsb25nZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAvLyBmYWxzZT11bmxpbWl0ZWRcbiAgaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXQ6IGZhbHNlLFxuXG4gIC8vIG1heCBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgcXVlcnkgdG8gY29tcGxldGUgKGNsaWVudCBzaWRlKVxuICBxdWVyeV90aW1lb3V0OiBmYWxzZSxcblxuICBjb25uZWN0X3RpbWVvdXQ6IDAsXG5cbiAga2VlcGFsaXZlczogMSxcblxuICBrZWVwYWxpdmVzX2lkbGU6IDAsXG59XG5cbmNvbnN0IHBnVHlwZXMgPSByZXF1aXJlKCdwZy10eXBlcycpXG4vLyBzYXZlIGRlZmF1bHQgcGFyc2Vyc1xuY29uc3QgcGFyc2VCaWdJbnRlZ2VyID0gcGdUeXBlcy5nZXRUeXBlUGFyc2VyKDIwLCAndGV4dCcpXG5jb25zdCBwYXJzZUJpZ0ludGVnZXJBcnJheSA9IHBnVHlwZXMuZ2V0VHlwZVBhcnNlcigxMDE2LCAndGV4dCcpXG5cbi8vIHBhcnNlIGludDggc28geW91IGNhbiBnZXQgeW91ciBjb3VudCB2YWx1ZXMgYXMgYWN0dWFsIG51bWJlcnNcbm1vZHVsZS5leHBvcnRzLl9fZGVmaW5lU2V0dGVyX18oJ3BhcnNlSW50OCcsIGZ1bmN0aW9uICh2YWwpIHtcbiAgcGdUeXBlcy5zZXRUeXBlUGFyc2VyKDIwLCAndGV4dCcsIHZhbCA/IHBnVHlwZXMuZ2V0VHlwZVBhcnNlcigyMywgJ3RleHQnKSA6IHBhcnNlQmlnSW50ZWdlcilcbiAgcGdUeXBlcy5zZXRUeXBlUGFyc2VyKDEwMTYsICd0ZXh0JywgdmFsID8gcGdUeXBlcy5nZXRUeXBlUGFyc2VyKDEwMDcsICd0ZXh0JykgOiBwYXJzZUJpZ0ludGVnZXJBcnJheSlcbn0pXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Client = __webpack_require__(/*! ./client */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/client.js\")\nconst defaults = __webpack_require__(/*! ./defaults */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js\")\nconst Connection = __webpack_require__(/*! ./connection */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection.js\")\nconst Result = __webpack_require__(/*! ./result */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\")\nconst Pool = __webpack_require__(/*! pg-pool */ \"(api-node)/../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js\")\nconst TypeOverrides = __webpack_require__(/*! ./type-overrides */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js\")\nconst { DatabaseError } = __webpack_require__(/*! pg-protocol */ \"(api-node)/../../node_modules/.pnpm/pg-protocol@1.10.3/node_modules/pg-protocol/dist/index.js\")\nconst { escapeIdentifier, escapeLiteral } = __webpack_require__(/*! ./utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\")\n\nconst poolFactory = (Client) => {\n  return class BoundPool extends Pool {\n    constructor(options) {\n      super(options, Client)\n    }\n  }\n}\n\nconst PG = function (clientConstructor) {\n  this.defaults = defaults\n  this.Client = clientConstructor\n  this.Query = this.Client.Query\n  this.Pool = poolFactory(this.Client)\n  this._pools = []\n  this.Connection = Connection\n  this.types = __webpack_require__(/*! pg-types */ \"(api-node)/../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js\")\n  this.DatabaseError = DatabaseError\n  this.TypeOverrides = TypeOverrides\n  this.escapeIdentifier = escapeIdentifier\n  this.escapeLiteral = escapeLiteral\n  this.Result = Result\n  this.utils = utils\n}\n\nif (typeof process.env.NODE_PG_FORCE_NATIVE !== 'undefined') {\n  module.exports = new PG(__webpack_require__(/*! ./native */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js\"))\n} else {\n  module.exports = new PG(Client)\n\n  // lazy require native module...the native module may not have installed\n  Object.defineProperty(module.exports, \"native\", ({\n    configurable: true,\n    enumerable: false,\n    get() {\n      let native = null\n      try {\n        native = new PG(__webpack_require__(/*! ./native */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js\"))\n      } catch (err) {\n        if (err.code !== 'MODULE_NOT_FOUND') {\n          throw err\n        }\n      }\n\n      // overwrite module.exports.native so that getter is never called again\n      Object.defineProperty(module.exports, \"native\", ({\n        value: native,\n      }))\n\n      return native\n    },\n  }))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLDZGQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLGlHQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLHFHQUFjO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyw2RkFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsMkZBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLDJHQUFTO0FBQzlCLHNCQUFzQixtQkFBTyxDQUFDLDZHQUFrQjtBQUNoRCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsa0hBQWE7QUFDL0MsUUFBUSxrQ0FBa0MsRUFBRSxtQkFBTyxDQUFDLDJGQUFTOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxtR0FBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLG1HQUFVO0FBQzVDLEVBQUU7QUFDRjs7QUFFQTtBQUNBLEVBQUUsaURBQWdEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBVTtBQUMxQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGlEQUFnRDtBQUN0RDtBQUNBLE9BQU8sRUFBQzs7QUFFUjtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUM7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpXG5jb25zdCBDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IFJlc3VsdCA9IHJlcXVpcmUoJy4vcmVzdWx0JylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBQb29sID0gcmVxdWlyZSgncGctcG9vbCcpXG5jb25zdCBUeXBlT3ZlcnJpZGVzID0gcmVxdWlyZSgnLi90eXBlLW92ZXJyaWRlcycpXG5jb25zdCB7IERhdGFiYXNlRXJyb3IgfSA9IHJlcXVpcmUoJ3BnLXByb3RvY29sJylcbmNvbnN0IHsgZXNjYXBlSWRlbnRpZmllciwgZXNjYXBlTGl0ZXJhbCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IHBvb2xGYWN0b3J5ID0gKENsaWVudCkgPT4ge1xuICByZXR1cm4gY2xhc3MgQm91bmRQb29sIGV4dGVuZHMgUG9vbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgc3VwZXIob3B0aW9ucywgQ2xpZW50KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBQRyA9IGZ1bmN0aW9uIChjbGllbnRDb25zdHJ1Y3Rvcikge1xuICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHNcbiAgdGhpcy5DbGllbnQgPSBjbGllbnRDb25zdHJ1Y3RvclxuICB0aGlzLlF1ZXJ5ID0gdGhpcy5DbGllbnQuUXVlcnlcbiAgdGhpcy5Qb29sID0gcG9vbEZhY3RvcnkodGhpcy5DbGllbnQpXG4gIHRoaXMuX3Bvb2xzID0gW11cbiAgdGhpcy5Db25uZWN0aW9uID0gQ29ubmVjdGlvblxuICB0aGlzLnR5cGVzID0gcmVxdWlyZSgncGctdHlwZXMnKVxuICB0aGlzLkRhdGFiYXNlRXJyb3IgPSBEYXRhYmFzZUVycm9yXG4gIHRoaXMuVHlwZU92ZXJyaWRlcyA9IFR5cGVPdmVycmlkZXNcbiAgdGhpcy5lc2NhcGVJZGVudGlmaWVyID0gZXNjYXBlSWRlbnRpZmllclxuICB0aGlzLmVzY2FwZUxpdGVyYWwgPSBlc2NhcGVMaXRlcmFsXG4gIHRoaXMuUmVzdWx0ID0gUmVzdWx0XG4gIHRoaXMudXRpbHMgPSB1dGlsc1xufVxuXG5pZiAodHlwZW9mIHByb2Nlc3MuZW52Lk5PREVfUEdfRk9SQ0VfTkFUSVZFICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5ldyBQRyhyZXF1aXJlKCcuL25hdGl2ZScpKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXcgUEcoQ2xpZW50KVxuXG4gIC8vIGxhenkgcmVxdWlyZSBuYXRpdmUgbW9kdWxlLi4udGhlIG5hdGl2ZSBtb2R1bGUgbWF5IG5vdCBoYXZlIGluc3RhbGxlZFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICduYXRpdmUnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGdldCgpIHtcbiAgICAgIGxldCBuYXRpdmUgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBuYXRpdmUgPSBuZXcgUEcocmVxdWlyZSgnLi9uYXRpdmUnKSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJ3cml0ZSBtb2R1bGUuZXhwb3J0cy5uYXRpdmUgc28gdGhhdCBnZXR0ZXIgaXMgbmV2ZXIgY2FsbGVkIGFnYWluXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICduYXRpdmUnLCB7XG4gICAgICAgIHZhbHVlOiBuYXRpdmUsXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbmF0aXZlXG4gICAgfSxcbiAgfSlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// eslint-disable-next-line\nvar Native\n// eslint-disable-next-line no-useless-catch\ntry {\n  // Wrap this `require()` in a try-catch to avoid upstream bundlers from complaining that this might not be available since it is an optional import\n  Native = __webpack_require__(/*! pg-native */ \"?1e74\")\n} catch (e) {\n  throw e\n}\nconst TypeOverrides = __webpack_require__(/*! ../type-overrides */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js\")\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst util = __webpack_require__(/*! util */ \"util\")\nconst ConnectionParameters = __webpack_require__(/*! ../connection-parameters */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/connection-parameters.js\")\n\nconst NativeQuery = __webpack_require__(/*! ./query */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js\")\n\nconst Client = (module.exports = function (config) {\n  EventEmitter.call(this)\n  config = config || {}\n\n  this._Promise = config.Promise || global.Promise\n  this._types = new TypeOverrides(config.types)\n\n  this.native = new Native({\n    types: this._types,\n  })\n\n  this._queryQueue = []\n  this._ending = false\n  this._connecting = false\n  this._connected = false\n  this._queryable = true\n\n  // keep these on the object for legacy reasons\n  // for the time being. TODO: deprecate all this jazz\n  const cp = (this.connectionParameters = new ConnectionParameters(config))\n  if (config.nativeConnectionString) cp.nativeConnectionString = config.nativeConnectionString\n  this.user = cp.user\n\n  // \"hiding\" the password so it doesn't show up in stack traces\n  // or if the client is console.logged\n  Object.defineProperty(this, 'password', {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: cp.password,\n  })\n  this.database = cp.database\n  this.host = cp.host\n  this.port = cp.port\n\n  // a hash to hold named queries\n  this.namedQueries = {}\n})\n\nClient.Query = NativeQuery\n\nutil.inherits(Client, EventEmitter)\n\nClient.prototype._errorAllQueries = function (err) {\n  const enqueueError = (query) => {\n    process.nextTick(() => {\n      query.native = this.native\n      query.handleError(err)\n    })\n  }\n\n  if (this._hasActiveQuery()) {\n    enqueueError(this._activeQuery)\n    this._activeQuery = null\n  }\n\n  this._queryQueue.forEach(enqueueError)\n  this._queryQueue.length = 0\n}\n\n// connect to the backend\n// pass an optional callback to be called once connected\n// or with an error if there was a connection error\nClient.prototype._connect = function (cb) {\n  const self = this\n\n  if (this._connecting) {\n    process.nextTick(() => cb(new Error('Client has already been connected. You cannot reuse a client.')))\n    return\n  }\n\n  this._connecting = true\n\n  this.connectionParameters.getLibpqConnectionString(function (err, conString) {\n    if (self.connectionParameters.nativeConnectionString) conString = self.connectionParameters.nativeConnectionString\n    if (err) return cb(err)\n    self.native.connect(conString, function (err) {\n      if (err) {\n        self.native.end()\n        return cb(err)\n      }\n\n      // set internal states to connected\n      self._connected = true\n\n      // handle connection errors from the native layer\n      self.native.on('error', function (err) {\n        self._queryable = false\n        self._errorAllQueries(err)\n        self.emit('error', err)\n      })\n\n      self.native.on('notification', function (msg) {\n        self.emit('notification', {\n          channel: msg.relname,\n          payload: msg.extra,\n        })\n      })\n\n      // signal we are connected now\n      self.emit('connect')\n      self._pulseQueryQueue(true)\n\n      cb()\n    })\n  })\n}\n\nClient.prototype.connect = function (callback) {\n  if (callback) {\n    this._connect(callback)\n    return\n  }\n\n  return new this._Promise((resolve, reject) => {\n    this._connect((error) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\n\n// send a query to the server\n// this method is highly overloaded to take\n// 1) string query, optional array of parameters, optional function callback\n// 2) object query with {\n//    string query\n//    optional array values,\n//    optional function callback instead of as a separate parameter\n//    optional string name to name & cache the query plan\n//    optional string rowMode = 'array' for an array of results\n//  }\nClient.prototype.query = function (config, values, callback) {\n  let query\n  let result\n  let readTimeout\n  let readTimeoutTimer\n  let queryCallback\n\n  if (config === null || config === undefined) {\n    throw new TypeError('Client was passed a null or undefined query')\n  } else if (typeof config.submit === 'function') {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n    result = query = config\n    // accept query(new Query(...), (err, res) => { }) style\n    if (typeof values === 'function') {\n      config.callback = values\n    }\n  } else {\n    readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n    query = new NativeQuery(config, values, callback)\n    if (!query.callback) {\n      let resolveOut, rejectOut\n      result = new this._Promise((resolve, reject) => {\n        resolveOut = resolve\n        rejectOut = reject\n      }).catch((err) => {\n        Error.captureStackTrace(err)\n        throw err\n      })\n      query.callback = (err, res) => (err ? rejectOut(err) : resolveOut(res))\n    }\n  }\n\n  if (readTimeout) {\n    queryCallback = query.callback\n\n    readTimeoutTimer = setTimeout(() => {\n      const error = new Error('Query read timeout')\n\n      process.nextTick(() => {\n        query.handleError(error, this.connection)\n      })\n\n      queryCallback(error)\n\n      // we already returned an error,\n      // just do nothing if query completes\n      query.callback = () => {}\n\n      // Remove from queue\n      const index = this._queryQueue.indexOf(query)\n      if (index > -1) {\n        this._queryQueue.splice(index, 1)\n      }\n\n      this._pulseQueryQueue()\n    }, readTimeout)\n\n    query.callback = (err, res) => {\n      clearTimeout(readTimeoutTimer)\n      queryCallback(err, res)\n    }\n  }\n\n  if (!this._queryable) {\n    query.native = this.native\n    process.nextTick(() => {\n      query.handleError(new Error('Client has encountered a connection error and is not queryable'))\n    })\n    return result\n  }\n\n  if (this._ending) {\n    query.native = this.native\n    process.nextTick(() => {\n      query.handleError(new Error('Client was closed and is not queryable'))\n    })\n    return result\n  }\n\n  this._queryQueue.push(query)\n  this._pulseQueryQueue()\n  return result\n}\n\n// disconnect from the backend server\nClient.prototype.end = function (cb) {\n  const self = this\n\n  this._ending = true\n\n  if (!this._connected) {\n    this.once('connect', this.end.bind(this, cb))\n  }\n  let result\n  if (!cb) {\n    result = new this._Promise(function (resolve, reject) {\n      cb = (err) => (err ? reject(err) : resolve())\n    })\n  }\n  this.native.end(function () {\n    self._errorAllQueries(new Error('Connection terminated'))\n\n    process.nextTick(() => {\n      self.emit('end')\n      if (cb) cb()\n    })\n  })\n  return result\n}\n\nClient.prototype._hasActiveQuery = function () {\n  return this._activeQuery && this._activeQuery.state !== 'error' && this._activeQuery.state !== 'end'\n}\n\nClient.prototype._pulseQueryQueue = function (initialConnection) {\n  if (!this._connected) {\n    return\n  }\n  if (this._hasActiveQuery()) {\n    return\n  }\n  const query = this._queryQueue.shift()\n  if (!query) {\n    if (!initialConnection) {\n      this.emit('drain')\n    }\n    return\n  }\n  this._activeQuery = query\n  query.submit(this)\n  const self = this\n  query.once('_done', function () {\n    self._pulseQueryQueue()\n  })\n}\n\n// attempt to cancel an in-progress query\nClient.prototype.cancel = function (query) {\n  if (this._activeQuery === query) {\n    this.native.cancel(function () {})\n  } else if (this._queryQueue.indexOf(query) !== -1) {\n    this._queryQueue.splice(this._queryQueue.indexOf(query), 1)\n  }\n}\n\nClient.prototype.ref = function () {}\nClient.prototype.unref = function () {}\n\nClient.prototype.setTypeParser = function (oid, format, parseFn) {\n  return this._types.setTypeParser(oid, format, parseFn)\n}\n\nClient.prototype.getTypeParser = function (oid, format) {\n  return this._types.getTypeParser(oid, format)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvbmF0aXZlL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHdCQUFXO0FBQzlCLEVBQUU7QUFDRjtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsOEdBQW1CO0FBQ2pELHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLDZCQUE2QixtQkFBTyxDQUFDLDRIQUEwQjs7QUFFL0Qsb0JBQW9CLG1CQUFPLENBQUMsa0dBQVM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hc2xhay9yZXBvcy9wbGFuLWVhdC1yZXBlYXQvbm9kZV9tb2R1bGVzLy5wbnBtL3BnQDguMTYuMy9ub2RlX21vZHVsZXMvcGcvbGliL25hdGl2ZS9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxudmFyIE5hdGl2ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2F0Y2hcbnRyeSB7XG4gIC8vIFdyYXAgdGhpcyBgcmVxdWlyZSgpYCBpbiBhIHRyeS1jYXRjaCB0byBhdm9pZCB1cHN0cmVhbSBidW5kbGVycyBmcm9tIGNvbXBsYWluaW5nIHRoYXQgdGhpcyBtaWdodCBub3QgYmUgYXZhaWxhYmxlIHNpbmNlIGl0IGlzIGFuIG9wdGlvbmFsIGltcG9ydFxuICBOYXRpdmUgPSByZXF1aXJlKCdwZy1uYXRpdmUnKVxufSBjYXRjaCAoZSkge1xuICB0aHJvdyBlXG59XG5jb25zdCBUeXBlT3ZlcnJpZGVzID0gcmVxdWlyZSgnLi4vdHlwZS1vdmVycmlkZXMnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBDb25uZWN0aW9uUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4uL2Nvbm5lY3Rpb24tcGFyYW1ldGVycycpXG5cbmNvbnN0IE5hdGl2ZVF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpXG5cbmNvbnN0IENsaWVudCA9IChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9XG5cbiAgdGhpcy5fUHJvbWlzZSA9IGNvbmZpZy5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlXG4gIHRoaXMuX3R5cGVzID0gbmV3IFR5cGVPdmVycmlkZXMoY29uZmlnLnR5cGVzKVxuXG4gIHRoaXMubmF0aXZlID0gbmV3IE5hdGl2ZSh7XG4gICAgdHlwZXM6IHRoaXMuX3R5cGVzLFxuICB9KVxuXG4gIHRoaXMuX3F1ZXJ5UXVldWUgPSBbXVxuICB0aGlzLl9lbmRpbmcgPSBmYWxzZVxuICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2VcbiAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgdGhpcy5fcXVlcnlhYmxlID0gdHJ1ZVxuXG4gIC8vIGtlZXAgdGhlc2Ugb24gdGhlIG9iamVjdCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgLy8gZm9yIHRoZSB0aW1lIGJlaW5nLiBUT0RPOiBkZXByZWNhdGUgYWxsIHRoaXMgamF6elxuICBjb25zdCBjcCA9ICh0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzID0gbmV3IENvbm5lY3Rpb25QYXJhbWV0ZXJzKGNvbmZpZykpXG4gIGlmIChjb25maWcubmF0aXZlQ29ubmVjdGlvblN0cmluZykgY3AubmF0aXZlQ29ubmVjdGlvblN0cmluZyA9IGNvbmZpZy5uYXRpdmVDb25uZWN0aW9uU3RyaW5nXG4gIHRoaXMudXNlciA9IGNwLnVzZXJcblxuICAvLyBcImhpZGluZ1wiIHRoZSBwYXNzd29yZCBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXNzd29yZCcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNwLnBhc3N3b3JkLFxuICB9KVxuICB0aGlzLmRhdGFiYXNlID0gY3AuZGF0YWJhc2VcbiAgdGhpcy5ob3N0ID0gY3AuaG9zdFxuICB0aGlzLnBvcnQgPSBjcC5wb3J0XG5cbiAgLy8gYSBoYXNoIHRvIGhvbGQgbmFtZWQgcXVlcmllc1xuICB0aGlzLm5hbWVkUXVlcmllcyA9IHt9XG59KVxuXG5DbGllbnQuUXVlcnkgPSBOYXRpdmVRdWVyeVxuXG51dGlsLmluaGVyaXRzKENsaWVudCwgRXZlbnRFbWl0dGVyKVxuXG5DbGllbnQucHJvdG90eXBlLl9lcnJvckFsbFF1ZXJpZXMgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGNvbnN0IGVucXVldWVFcnJvciA9IChxdWVyeSkgPT4ge1xuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgcXVlcnkubmF0aXZlID0gdGhpcy5uYXRpdmVcbiAgICAgIHF1ZXJ5LmhhbmRsZUVycm9yKGVycilcbiAgICB9KVxuICB9XG5cbiAgaWYgKHRoaXMuX2hhc0FjdGl2ZVF1ZXJ5KCkpIHtcbiAgICBlbnF1ZXVlRXJyb3IodGhpcy5fYWN0aXZlUXVlcnkpXG4gICAgdGhpcy5fYWN0aXZlUXVlcnkgPSBudWxsXG4gIH1cblxuICB0aGlzLl9xdWVyeVF1ZXVlLmZvckVhY2goZW5xdWV1ZUVycm9yKVxuICB0aGlzLl9xdWVyeVF1ZXVlLmxlbmd0aCA9IDBcbn1cblxuLy8gY29ubmVjdCB0byB0aGUgYmFja2VuZFxuLy8gcGFzcyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgb25jZSBjb25uZWN0ZWRcbi8vIG9yIHdpdGggYW4gZXJyb3IgaWYgdGhlcmUgd2FzIGEgY29ubmVjdGlvbiBlcnJvclxuQ2xpZW50LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uIChjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuXG4gIGlmICh0aGlzLl9jb25uZWN0aW5nKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYihuZXcgRXJyb3IoJ0NsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGNvbm5lY3RlZC4gWW91IGNhbm5vdCByZXVzZSBhIGNsaWVudC4nKSkpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZVxuXG4gIHRoaXMuY29ubmVjdGlvblBhcmFtZXRlcnMuZ2V0TGlicHFDb25uZWN0aW9uU3RyaW5nKGZ1bmN0aW9uIChlcnIsIGNvblN0cmluZykge1xuICAgIGlmIChzZWxmLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLm5hdGl2ZUNvbm5lY3Rpb25TdHJpbmcpIGNvblN0cmluZyA9IHNlbGYuY29ubmVjdGlvblBhcmFtZXRlcnMubmF0aXZlQ29ubmVjdGlvblN0cmluZ1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgc2VsZi5uYXRpdmUuY29ubmVjdChjb25TdHJpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgc2VsZi5uYXRpdmUuZW5kKClcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IGludGVybmFsIHN0YXRlcyB0byBjb25uZWN0ZWRcbiAgICAgIHNlbGYuX2Nvbm5lY3RlZCA9IHRydWVcblxuICAgICAgLy8gaGFuZGxlIGNvbm5lY3Rpb24gZXJyb3JzIGZyb20gdGhlIG5hdGl2ZSBsYXllclxuICAgICAgc2VsZi5uYXRpdmUub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzZWxmLl9xdWVyeWFibGUgPSBmYWxzZVxuICAgICAgICBzZWxmLl9lcnJvckFsbFF1ZXJpZXMoZXJyKVxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSlcblxuICAgICAgc2VsZi5uYXRpdmUub24oJ25vdGlmaWNhdGlvbicsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdub3RpZmljYXRpb24nLCB7XG4gICAgICAgICAgY2hhbm5lbDogbXNnLnJlbG5hbWUsXG4gICAgICAgICAgcGF5bG9hZDogbXNnLmV4dHJhLFxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgLy8gc2lnbmFsIHdlIGFyZSBjb25uZWN0ZWQgbm93XG4gICAgICBzZWxmLmVtaXQoJ2Nvbm5lY3QnKVxuICAgICAgc2VsZi5fcHVsc2VRdWVyeVF1ZXVlKHRydWUpXG5cbiAgICAgIGNiKClcbiAgICB9KVxuICB9KVxufVxuXG5DbGllbnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fY29ubmVjdChjYWxsYmFjaylcbiAgICByZXR1cm5cbiAgfVxuXG4gIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29ubmVjdCgoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG4vLyBzZW5kIGEgcXVlcnkgdG8gdGhlIHNlcnZlclxuLy8gdGhpcyBtZXRob2QgaXMgaGlnaGx5IG92ZXJsb2FkZWQgdG8gdGFrZVxuLy8gMSkgc3RyaW5nIHF1ZXJ5LCBvcHRpb25hbCBhcnJheSBvZiBwYXJhbWV0ZXJzLCBvcHRpb25hbCBmdW5jdGlvbiBjYWxsYmFja1xuLy8gMikgb2JqZWN0IHF1ZXJ5IHdpdGgge1xuLy8gICAgc3RyaW5nIHF1ZXJ5XG4vLyAgICBvcHRpb25hbCBhcnJheSB2YWx1ZXMsXG4vLyAgICBvcHRpb25hbCBmdW5jdGlvbiBjYWxsYmFjayBpbnN0ZWFkIG9mIGFzIGEgc2VwYXJhdGUgcGFyYW1ldGVyXG4vLyAgICBvcHRpb25hbCBzdHJpbmcgbmFtZSB0byBuYW1lICYgY2FjaGUgdGhlIHF1ZXJ5IHBsYW5cbi8vICAgIG9wdGlvbmFsIHN0cmluZyByb3dNb2RlID0gJ2FycmF5JyBmb3IgYW4gYXJyYXkgb2YgcmVzdWx0c1xuLy8gIH1cbkNsaWVudC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoY29uZmlnLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGxldCBxdWVyeVxuICBsZXQgcmVzdWx0XG4gIGxldCByZWFkVGltZW91dFxuICBsZXQgcmVhZFRpbWVvdXRUaW1lclxuICBsZXQgcXVlcnlDYWxsYmFja1xuXG4gIGlmIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDbGllbnQgd2FzIHBhc3NlZCBhIG51bGwgb3IgdW5kZWZpbmVkIHF1ZXJ5JylcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnLnN1Ym1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlYWRUaW1lb3V0ID0gY29uZmlnLnF1ZXJ5X3RpbWVvdXQgfHwgdGhpcy5jb25uZWN0aW9uUGFyYW1ldGVycy5xdWVyeV90aW1lb3V0XG4gICAgcmVzdWx0ID0gcXVlcnkgPSBjb25maWdcbiAgICAvLyBhY2NlcHQgcXVlcnkobmV3IFF1ZXJ5KC4uLiksIChlcnIsIHJlcykgPT4geyB9KSBzdHlsZVxuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25maWcuY2FsbGJhY2sgPSB2YWx1ZXNcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVhZFRpbWVvdXQgPSBjb25maWcucXVlcnlfdGltZW91dCB8fCB0aGlzLmNvbm5lY3Rpb25QYXJhbWV0ZXJzLnF1ZXJ5X3RpbWVvdXRcbiAgICBxdWVyeSA9IG5ldyBOYXRpdmVRdWVyeShjb25maWcsIHZhbHVlcywgY2FsbGJhY2spXG4gICAgaWYgKCFxdWVyeS5jYWxsYmFjaykge1xuICAgICAgbGV0IHJlc29sdmVPdXQsIHJlamVjdE91dFxuICAgICAgcmVzdWx0ID0gbmV3IHRoaXMuX1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlT3V0ID0gcmVzb2x2ZVxuICAgICAgICByZWplY3RPdXQgPSByZWplY3RcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyKVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgICBxdWVyeS5jYWxsYmFjayA9IChlcnIsIHJlcykgPT4gKGVyciA/IHJlamVjdE91dChlcnIpIDogcmVzb2x2ZU91dChyZXMpKVxuICAgIH1cbiAgfVxuXG4gIGlmIChyZWFkVGltZW91dCkge1xuICAgIHF1ZXJ5Q2FsbGJhY2sgPSBxdWVyeS5jYWxsYmFja1xuXG4gICAgcmVhZFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1F1ZXJ5IHJlYWQgdGltZW91dCcpXG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICBxdWVyeS5oYW5kbGVFcnJvcihlcnJvciwgdGhpcy5jb25uZWN0aW9uKVxuICAgICAgfSlcblxuICAgICAgcXVlcnlDYWxsYmFjayhlcnJvcilcblxuICAgICAgLy8gd2UgYWxyZWFkeSByZXR1cm5lZCBhbiBlcnJvcixcbiAgICAgIC8vIGp1c3QgZG8gbm90aGluZyBpZiBxdWVyeSBjb21wbGV0ZXNcbiAgICAgIHF1ZXJ5LmNhbGxiYWNrID0gKCkgPT4ge31cblxuICAgICAgLy8gUmVtb3ZlIGZyb20gcXVldWVcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcXVlcnlRdWV1ZS5pbmRleE9mKHF1ZXJ5KVxuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5fcXVlcnlRdWV1ZS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3B1bHNlUXVlcnlRdWV1ZSgpXG4gICAgfSwgcmVhZFRpbWVvdXQpXG5cbiAgICBxdWVyeS5jYWxsYmFjayA9IChlcnIsIHJlcykgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlYWRUaW1lb3V0VGltZXIpXG4gICAgICBxdWVyeUNhbGxiYWNrKGVyciwgcmVzKVxuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fcXVlcnlhYmxlKSB7XG4gICAgcXVlcnkubmF0aXZlID0gdGhpcy5uYXRpdmVcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgIHF1ZXJ5LmhhbmRsZUVycm9yKG5ldyBFcnJvcignQ2xpZW50IGhhcyBlbmNvdW50ZXJlZCBhIGNvbm5lY3Rpb24gZXJyb3IgYW5kIGlzIG5vdCBxdWVyeWFibGUnKSlcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmRpbmcpIHtcbiAgICBxdWVyeS5uYXRpdmUgPSB0aGlzLm5hdGl2ZVxuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgcXVlcnkuaGFuZGxlRXJyb3IobmV3IEVycm9yKCdDbGllbnQgd2FzIGNsb3NlZCBhbmQgaXMgbm90IHF1ZXJ5YWJsZScpKVxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdGhpcy5fcXVlcnlRdWV1ZS5wdXNoKHF1ZXJ5KVxuICB0aGlzLl9wdWxzZVF1ZXJ5UXVldWUoKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGRpc2Nvbm5lY3QgZnJvbSB0aGUgYmFja2VuZCBzZXJ2ZXJcbkNsaWVudC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgdGhpcy5fZW5kaW5nID0gdHJ1ZVxuXG4gIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgdGhpcy5vbmNlKCdjb25uZWN0JywgdGhpcy5lbmQuYmluZCh0aGlzLCBjYikpXG4gIH1cbiAgbGV0IHJlc3VsdFxuICBpZiAoIWNiKSB7XG4gICAgcmVzdWx0ID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgY2IgPSAoZXJyKSA9PiAoZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCkpXG4gICAgfSlcbiAgfVxuICB0aGlzLm5hdGl2ZS5lbmQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2Vycm9yQWxsUXVlcmllcyhuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGVybWluYXRlZCcpKVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICBzZWxmLmVtaXQoJ2VuZCcpXG4gICAgICBpZiAoY2IpIGNiKClcbiAgICB9KVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbkNsaWVudC5wcm90b3R5cGUuX2hhc0FjdGl2ZVF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fYWN0aXZlUXVlcnkgJiYgdGhpcy5fYWN0aXZlUXVlcnkuc3RhdGUgIT09ICdlcnJvcicgJiYgdGhpcy5fYWN0aXZlUXVlcnkuc3RhdGUgIT09ICdlbmQnXG59XG5cbkNsaWVudC5wcm90b3R5cGUuX3B1bHNlUXVlcnlRdWV1ZSA9IGZ1bmN0aW9uIChpbml0aWFsQ29ubmVjdGlvbikge1xuICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh0aGlzLl9oYXNBY3RpdmVRdWVyeSgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcXVlcnkgPSB0aGlzLl9xdWVyeVF1ZXVlLnNoaWZ0KClcbiAgaWYgKCFxdWVyeSkge1xuICAgIGlmICghaW5pdGlhbENvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl9hY3RpdmVRdWVyeSA9IHF1ZXJ5XG4gIHF1ZXJ5LnN1Ym1pdCh0aGlzKVxuICBjb25zdCBzZWxmID0gdGhpc1xuICBxdWVyeS5vbmNlKCdfZG9uZScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9wdWxzZVF1ZXJ5UXVldWUoKVxuICB9KVxufVxuXG4vLyBhdHRlbXB0IHRvIGNhbmNlbCBhbiBpbi1wcm9ncmVzcyBxdWVyeVxuQ2xpZW50LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgaWYgKHRoaXMuX2FjdGl2ZVF1ZXJ5ID09PSBxdWVyeSkge1xuICAgIHRoaXMubmF0aXZlLmNhbmNlbChmdW5jdGlvbiAoKSB7fSlcbiAgfSBlbHNlIGlmICh0aGlzLl9xdWVyeVF1ZXVlLmluZGV4T2YocXVlcnkpICE9PSAtMSkge1xuICAgIHRoaXMuX3F1ZXJ5UXVldWUuc3BsaWNlKHRoaXMuX3F1ZXJ5UXVldWUuaW5kZXhPZihxdWVyeSksIDEpXG4gIH1cbn1cblxuQ2xpZW50LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50LnByb3RvdHlwZS51bnJlZiA9IGZ1bmN0aW9uICgpIHt9XG5cbkNsaWVudC5wcm90b3R5cGUuc2V0VHlwZVBhcnNlciA9IGZ1bmN0aW9uIChvaWQsIGZvcm1hdCwgcGFyc2VGbikge1xuICByZXR1cm4gdGhpcy5fdHlwZXMuc2V0VHlwZVBhcnNlcihvaWQsIGZvcm1hdCwgcGFyc2VGbilcbn1cblxuQ2xpZW50LnByb3RvdHlwZS5nZXRUeXBlUGFyc2VyID0gZnVuY3Rpb24gKG9pZCwgZm9ybWF0KSB7XG4gIHJldHVybiB0aGlzLl90eXBlcy5nZXRUeXBlUGFyc2VyKG9pZCwgZm9ybWF0KVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./client */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/client.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvbmF0aXZlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osMElBQW9DIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9uYXRpdmUvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2xpZW50JylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/index.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst util = __webpack_require__(/*! util */ \"util\")\nconst utils = __webpack_require__(/*! ../utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\")\n\nconst NativeQuery = (module.exports = function (config, values, callback) {\n  EventEmitter.call(this)\n  config = utils.normalizeQueryConfig(config, values, callback)\n  this.text = config.text\n  this.values = config.values\n  this.name = config.name\n  this.queryMode = config.queryMode\n  this.callback = config.callback\n  this.state = 'new'\n  this._arrayMode = config.rowMode === 'array'\n\n  // if the 'row' event is listened for\n  // then emit them as they come in\n  // without setting singleRowMode to true\n  // this has almost no meaning because libpq\n  // reads all rows into memory before returning any\n  this._emitRowEvents = false\n  this.on(\n    'newListener',\n    function (event) {\n      if (event === 'row') this._emitRowEvents = true\n    }.bind(this)\n  )\n})\n\nutil.inherits(NativeQuery, EventEmitter)\n\nconst errorFieldMap = {\n  sqlState: 'code',\n  statementPosition: 'position',\n  messagePrimary: 'message',\n  context: 'where',\n  schemaName: 'schema',\n  tableName: 'table',\n  columnName: 'column',\n  dataTypeName: 'dataType',\n  constraintName: 'constraint',\n  sourceFile: 'file',\n  sourceLine: 'line',\n  sourceFunction: 'routine',\n}\n\nNativeQuery.prototype.handleError = function (err) {\n  // copy pq error fields into the error object\n  const fields = this.native.pq.resultErrorFields()\n  if (fields) {\n    for (const key in fields) {\n      const normalizedFieldName = errorFieldMap[key] || key\n      err[normalizedFieldName] = fields[key]\n    }\n  }\n  if (this.callback) {\n    this.callback(err)\n  } else {\n    this.emit('error', err)\n  }\n  this.state = 'error'\n}\n\nNativeQuery.prototype.then = function (onSuccess, onFailure) {\n  return this._getPromise().then(onSuccess, onFailure)\n}\n\nNativeQuery.prototype.catch = function (callback) {\n  return this._getPromise().catch(callback)\n}\n\nNativeQuery.prototype._getPromise = function () {\n  if (this._promise) return this._promise\n  this._promise = new Promise(\n    function (resolve, reject) {\n      this._once('end', resolve)\n      this._once('error', reject)\n    }.bind(this)\n  )\n  return this._promise\n}\n\nNativeQuery.prototype.submit = function (client) {\n  this.state = 'running'\n  const self = this\n  this.native = client.native\n  client.native.arrayMode = this._arrayMode\n\n  let after = function (err, rows, results) {\n    client.native.arrayMode = false\n    setImmediate(function () {\n      self.emit('_done')\n    })\n\n    // handle possible query error\n    if (err) {\n      return self.handleError(err)\n    }\n\n    // emit row events for each row in the result\n    if (self._emitRowEvents) {\n      if (results.length > 1) {\n        rows.forEach((rowOfRows, i) => {\n          rowOfRows.forEach((row) => {\n            self.emit('row', row, results[i])\n          })\n        })\n      } else {\n        rows.forEach(function (row) {\n          self.emit('row', row, results)\n        })\n      }\n    }\n\n    // handle successful result\n    self.state = 'end'\n    self.emit('end', results)\n    if (self.callback) {\n      self.callback(null, results)\n    }\n  }\n\n  if (process.domain) {\n    after = process.domain.bind(after)\n  }\n\n  // named query\n  if (this.name) {\n    if (this.name.length > 63) {\n      console.error('Warning! Postgres only supports 63 characters for query names.')\n      console.error('You supplied %s (%s)', this.name, this.name.length)\n      console.error('This can cause conflicts and silent errors executing queries')\n    }\n    const values = (this.values || []).map(utils.prepareValue)\n\n    // check if the client has already executed this named query\n    // if so...just execute it again - skip the planning phase\n    if (client.namedQueries[this.name]) {\n      if (this.text && client.namedQueries[this.name] !== this.text) {\n        const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n        return after(err)\n      }\n      return client.native.execute(this.name, values, after)\n    }\n    // plan the named query the first time, then execute it\n    return client.native.prepare(this.name, this.text, values.length, function (err) {\n      if (err) return after(err)\n      client.namedQueries[self.name] = self.text\n      return self.native.execute(self.name, values, after)\n    })\n  } else if (this.values) {\n    if (!Array.isArray(this.values)) {\n      const err = new Error('Query values must be an array')\n      return after(err)\n    }\n    const vals = this.values.map(utils.prepareValue)\n    client.native.query(this.text, vals, after)\n  } else if (this.queryMode === 'extended') {\n    client.native.query(this.text, [], after)\n  } else {\n    client.native.query(this.text, after)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvbmF0aXZlL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw0RkFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFVBQVU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9uYXRpdmUvcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5cbmNvbnN0IE5hdGl2ZVF1ZXJ5ID0gKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmZpZywgdmFsdWVzLCBjYWxsYmFjaykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKVxuICBjb25maWcgPSB1dGlscy5ub3JtYWxpemVRdWVyeUNvbmZpZyhjb25maWcsIHZhbHVlcywgY2FsbGJhY2spXG4gIHRoaXMudGV4dCA9IGNvbmZpZy50ZXh0XG4gIHRoaXMudmFsdWVzID0gY29uZmlnLnZhbHVlc1xuICB0aGlzLm5hbWUgPSBjb25maWcubmFtZVxuICB0aGlzLnF1ZXJ5TW9kZSA9IGNvbmZpZy5xdWVyeU1vZGVcbiAgdGhpcy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFja1xuICB0aGlzLnN0YXRlID0gJ25ldydcbiAgdGhpcy5fYXJyYXlNb2RlID0gY29uZmlnLnJvd01vZGUgPT09ICdhcnJheSdcblxuICAvLyBpZiB0aGUgJ3JvdycgZXZlbnQgaXMgbGlzdGVuZWQgZm9yXG4gIC8vIHRoZW4gZW1pdCB0aGVtIGFzIHRoZXkgY29tZSBpblxuICAvLyB3aXRob3V0IHNldHRpbmcgc2luZ2xlUm93TW9kZSB0byB0cnVlXG4gIC8vIHRoaXMgaGFzIGFsbW9zdCBubyBtZWFuaW5nIGJlY2F1c2UgbGlicHFcbiAgLy8gcmVhZHMgYWxsIHJvd3MgaW50byBtZW1vcnkgYmVmb3JlIHJldHVybmluZyBhbnlcbiAgdGhpcy5fZW1pdFJvd0V2ZW50cyA9IGZhbHNlXG4gIHRoaXMub24oXG4gICAgJ25ld0xpc3RlbmVyJyxcbiAgICBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCA9PT0gJ3JvdycpIHRoaXMuX2VtaXRSb3dFdmVudHMgPSB0cnVlXG4gICAgfS5iaW5kKHRoaXMpXG4gIClcbn0pXG5cbnV0aWwuaW5oZXJpdHMoTmF0aXZlUXVlcnksIEV2ZW50RW1pdHRlcilcblxuY29uc3QgZXJyb3JGaWVsZE1hcCA9IHtcbiAgc3FsU3RhdGU6ICdjb2RlJyxcbiAgc3RhdGVtZW50UG9zaXRpb246ICdwb3NpdGlvbicsXG4gIG1lc3NhZ2VQcmltYXJ5OiAnbWVzc2FnZScsXG4gIGNvbnRleHQ6ICd3aGVyZScsXG4gIHNjaGVtYU5hbWU6ICdzY2hlbWEnLFxuICB0YWJsZU5hbWU6ICd0YWJsZScsXG4gIGNvbHVtbk5hbWU6ICdjb2x1bW4nLFxuICBkYXRhVHlwZU5hbWU6ICdkYXRhVHlwZScsXG4gIGNvbnN0cmFpbnROYW1lOiAnY29uc3RyYWludCcsXG4gIHNvdXJjZUZpbGU6ICdmaWxlJyxcbiAgc291cmNlTGluZTogJ2xpbmUnLFxuICBzb3VyY2VGdW5jdGlvbjogJ3JvdXRpbmUnLFxufVxuXG5OYXRpdmVRdWVyeS5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIC8vIGNvcHkgcHEgZXJyb3IgZmllbGRzIGludG8gdGhlIGVycm9yIG9iamVjdFxuICBjb25zdCBmaWVsZHMgPSB0aGlzLm5hdGl2ZS5wcS5yZXN1bHRFcnJvckZpZWxkcygpXG4gIGlmIChmaWVsZHMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRGaWVsZE5hbWUgPSBlcnJvckZpZWxkTWFwW2tleV0gfHwga2V5XG4gICAgICBlcnJbbm9ybWFsaXplZEZpZWxkTmFtZV0gPSBmaWVsZHNba2V5XVxuICAgIH1cbiAgfVxuICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgIHRoaXMuY2FsbGJhY2soZXJyKVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gIH1cbiAgdGhpcy5zdGF0ZSA9ICdlcnJvcidcbn1cblxuTmF0aXZlUXVlcnkucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25TdWNjZXNzLCBvbkZhaWx1cmUpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFByb21pc2UoKS50aGVuKG9uU3VjY2Vzcywgb25GYWlsdXJlKVxufVxuXG5OYXRpdmVRdWVyeS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHRoaXMuX2dldFByb21pc2UoKS5jYXRjaChjYWxsYmFjaylcbn1cblxuTmF0aXZlUXVlcnkucHJvdG90eXBlLl9nZXRQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fcHJvbWlzZSkgcmV0dXJuIHRoaXMuX3Byb21pc2VcbiAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRoaXMuX29uY2UoJ2VuZCcsIHJlc29sdmUpXG4gICAgICB0aGlzLl9vbmNlKCdlcnJvcicsIHJlamVjdClcbiAgICB9LmJpbmQodGhpcylcbiAgKVxuICByZXR1cm4gdGhpcy5fcHJvbWlzZVxufVxuXG5OYXRpdmVRdWVyeS5wcm90b3R5cGUuc3VibWl0ID0gZnVuY3Rpb24gKGNsaWVudCkge1xuICB0aGlzLnN0YXRlID0gJ3J1bm5pbmcnXG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHRoaXMubmF0aXZlID0gY2xpZW50Lm5hdGl2ZVxuICBjbGllbnQubmF0aXZlLmFycmF5TW9kZSA9IHRoaXMuX2FycmF5TW9kZVxuXG4gIGxldCBhZnRlciA9IGZ1bmN0aW9uIChlcnIsIHJvd3MsIHJlc3VsdHMpIHtcbiAgICBjbGllbnQubmF0aXZlLmFycmF5TW9kZSA9IGZhbHNlXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZW1pdCgnX2RvbmUnKVxuICAgIH0pXG5cbiAgICAvLyBoYW5kbGUgcG9zc2libGUgcXVlcnkgZXJyb3JcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gc2VsZi5oYW5kbGVFcnJvcihlcnIpXG4gICAgfVxuXG4gICAgLy8gZW1pdCByb3cgZXZlbnRzIGZvciBlYWNoIHJvdyBpbiB0aGUgcmVzdWx0XG4gICAgaWYgKHNlbGYuX2VtaXRSb3dFdmVudHMpIHtcbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcm93cy5mb3JFYWNoKChyb3dPZlJvd3MsIGkpID0+IHtcbiAgICAgICAgICByb3dPZlJvd3MuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ3JvdycsIHJvdywgcmVzdWx0c1tpXSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3JvdycsIHJvdywgcmVzdWx0cylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgc3VjY2Vzc2Z1bCByZXN1bHRcbiAgICBzZWxmLnN0YXRlID0gJ2VuZCdcbiAgICBzZWxmLmVtaXQoJ2VuZCcsIHJlc3VsdHMpXG4gICAgaWYgKHNlbGYuY2FsbGJhY2spIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzdWx0cylcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5kb21haW4pIHtcbiAgICBhZnRlciA9IHByb2Nlc3MuZG9tYWluLmJpbmQoYWZ0ZXIpXG4gIH1cblxuICAvLyBuYW1lZCBxdWVyeVxuICBpZiAodGhpcy5uYW1lKSB7XG4gICAgaWYgKHRoaXMubmFtZS5sZW5ndGggPiA2Mykge1xuICAgICAgY29uc29sZS5lcnJvcignV2FybmluZyEgUG9zdGdyZXMgb25seSBzdXBwb3J0cyA2MyBjaGFyYWN0ZXJzIGZvciBxdWVyeSBuYW1lcy4nKVxuICAgICAgY29uc29sZS5lcnJvcignWW91IHN1cHBsaWVkICVzICglcyknLCB0aGlzLm5hbWUsIHRoaXMubmFtZS5sZW5ndGgpXG4gICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGNhbiBjYXVzZSBjb25mbGljdHMgYW5kIHNpbGVudCBlcnJvcnMgZXhlY3V0aW5nIHF1ZXJpZXMnKVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSAodGhpcy52YWx1ZXMgfHwgW10pLm1hcCh1dGlscy5wcmVwYXJlVmFsdWUpXG5cbiAgICAvLyBjaGVjayBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IGV4ZWN1dGVkIHRoaXMgbmFtZWQgcXVlcnlcbiAgICAvLyBpZiBzby4uLmp1c3QgZXhlY3V0ZSBpdCBhZ2FpbiAtIHNraXAgdGhlIHBsYW5uaW5nIHBoYXNlXG4gICAgaWYgKGNsaWVudC5uYW1lZFF1ZXJpZXNbdGhpcy5uYW1lXSkge1xuICAgICAgaWYgKHRoaXMudGV4dCAmJiBjbGllbnQubmFtZWRRdWVyaWVzW3RoaXMubmFtZV0gIT09IHRoaXMudGV4dCkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFByZXBhcmVkIHN0YXRlbWVudHMgbXVzdCBiZSB1bmlxdWUgLSAnJHt0aGlzLm5hbWV9JyB3YXMgdXNlZCBmb3IgYSBkaWZmZXJlbnQgc3RhdGVtZW50YClcbiAgICAgICAgcmV0dXJuIGFmdGVyKGVycilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbGllbnQubmF0aXZlLmV4ZWN1dGUodGhpcy5uYW1lLCB2YWx1ZXMsIGFmdGVyKVxuICAgIH1cbiAgICAvLyBwbGFuIHRoZSBuYW1lZCBxdWVyeSB0aGUgZmlyc3QgdGltZSwgdGhlbiBleGVjdXRlIGl0XG4gICAgcmV0dXJuIGNsaWVudC5uYXRpdmUucHJlcGFyZSh0aGlzLm5hbWUsIHRoaXMudGV4dCwgdmFsdWVzLmxlbmd0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGFmdGVyKGVycilcbiAgICAgIGNsaWVudC5uYW1lZFF1ZXJpZXNbc2VsZi5uYW1lXSA9IHNlbGYudGV4dFxuICAgICAgcmV0dXJuIHNlbGYubmF0aXZlLmV4ZWN1dGUoc2VsZi5uYW1lLCB2YWx1ZXMsIGFmdGVyKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAodGhpcy52YWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy52YWx1ZXMpKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1F1ZXJ5IHZhbHVlcyBtdXN0IGJlIGFuIGFycmF5JylcbiAgICAgIHJldHVybiBhZnRlcihlcnIpXG4gICAgfVxuICAgIGNvbnN0IHZhbHMgPSB0aGlzLnZhbHVlcy5tYXAodXRpbHMucHJlcGFyZVZhbHVlKVxuICAgIGNsaWVudC5uYXRpdmUucXVlcnkodGhpcy50ZXh0LCB2YWxzLCBhZnRlcilcbiAgfSBlbHNlIGlmICh0aGlzLnF1ZXJ5TW9kZSA9PT0gJ2V4dGVuZGVkJykge1xuICAgIGNsaWVudC5uYXRpdmUucXVlcnkodGhpcy50ZXh0LCBbXSwgYWZ0ZXIpXG4gIH0gZWxzZSB7XG4gICAgY2xpZW50Lm5hdGl2ZS5xdWVyeSh0aGlzLnRleHQsIGFmdGVyKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/native/query.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EventEmitter } = __webpack_require__(/*! events */ \"events\")\n\nconst Result = __webpack_require__(/*! ./result */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\")\n\nclass Query extends EventEmitter {\n  constructor(config, values, callback) {\n    super()\n\n    config = utils.normalizeQueryConfig(config, values, callback)\n\n    this.text = config.text\n    this.values = config.values\n    this.rows = config.rows\n    this.types = config.types\n    this.name = config.name\n    this.queryMode = config.queryMode\n    this.binary = config.binary\n    // use unique portal name each time\n    this.portal = config.portal || ''\n    this.callback = config.callback\n    this._rowMode = config.rowMode\n    if (process.domain && config.callback) {\n      this.callback = process.domain.bind(config.callback)\n    }\n    this._result = new Result(this._rowMode, this.types)\n\n    // potential for multiple results\n    this._results = this._result\n    this._canceledDueToError = false\n  }\n\n  requiresPreparation() {\n    if (this.queryMode === 'extended') {\n      return true\n    }\n\n    // named queries must always be prepared\n    if (this.name) {\n      return true\n    }\n    // always prepare if there are max number of rows expected per\n    // portal execution\n    if (this.rows) {\n      return true\n    }\n    // don't prepare empty text queries\n    if (!this.text) {\n      return false\n    }\n    // prepare if there are values\n    if (!this.values) {\n      return false\n    }\n    return this.values.length > 0\n  }\n\n  _checkForMultirow() {\n    // if we already have a result with a command property\n    // then we've already executed one query in a multi-statement simple query\n    // turn our results into an array of results\n    if (this._result.command) {\n      if (!Array.isArray(this._results)) {\n        this._results = [this._result]\n      }\n      this._result = new Result(this._rowMode, this._result._types)\n      this._results.push(this._result)\n    }\n  }\n\n  // associates row metadata from the supplied\n  // message with this query object\n  // metadata used when parsing row results\n  handleRowDescription(msg) {\n    this._checkForMultirow()\n    this._result.addFields(msg.fields)\n    this._accumulateRows = this.callback || !this.listeners('row').length\n  }\n\n  handleDataRow(msg) {\n    let row\n\n    if (this._canceledDueToError) {\n      return\n    }\n\n    try {\n      row = this._result.parseRow(msg.fields)\n    } catch (err) {\n      this._canceledDueToError = err\n      return\n    }\n\n    this.emit('row', row, this._result)\n    if (this._accumulateRows) {\n      this._result.addRow(row)\n    }\n  }\n\n  handleCommandComplete(msg, connection) {\n    this._checkForMultirow()\n    this._result.addCommandComplete(msg)\n    // need to sync after each command complete of a prepared statement\n    // if we were using a row count which results in multiple calls to _getRows\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  // if a named prepared statement is created with empty query text\n  // the backend will send an emptyQuery message but *not* a command complete message\n  // since we pipeline sync immediately after execute we don't need to do anything here\n  // unless we have rows specified, in which case we did not pipeline the initial sync call\n  handleEmptyQuery(connection) {\n    if (this.rows) {\n      connection.sync()\n    }\n  }\n\n  handleError(err, connection) {\n    // need to sync after error during a prepared statement\n    if (this._canceledDueToError) {\n      err = this._canceledDueToError\n      this._canceledDueToError = false\n    }\n    // if callback supplied do not emit error event as uncaught error\n    // events will bubble up to node process\n    if (this.callback) {\n      return this.callback(err)\n    }\n    this.emit('error', err)\n  }\n\n  handleReadyForQuery(con) {\n    if (this._canceledDueToError) {\n      return this.handleError(this._canceledDueToError, con)\n    }\n    if (this.callback) {\n      try {\n        this.callback(null, this._results)\n      } catch (err) {\n        process.nextTick(() => {\n          throw err\n        })\n      }\n    }\n    this.emit('end', this._results)\n  }\n\n  submit(connection) {\n    if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n      return new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    }\n    const previous = connection.parsedStatements[this.name]\n    if (this.text && previous && this.text !== previous) {\n      return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`)\n    }\n    if (this.values && !Array.isArray(this.values)) {\n      return new Error('Query values must be an array')\n    }\n    if (this.requiresPreparation()) {\n      // If we're using the extended query protocol we fire off several separate commands\n      // to the backend. On some versions of node & some operating system versions\n      // the network stack writes each message separately instead of buffering them together\n      // causing the client & network to send more slowly. Corking & uncorking the stream\n      // allows node to buffer up the messages internally before sending them all off at once.\n      // note: we're checking for existence of cork/uncork because some versions of streams\n      // might not have this (cloudflare?)\n      connection.stream.cork && connection.stream.cork()\n      try {\n        this.prepare(connection)\n      } finally {\n        // while unlikely for this.prepare to throw, if it does & we don't uncork this stream\n        // this client becomes unresponsive, so put in finally block \"just in case\"\n        connection.stream.uncork && connection.stream.uncork()\n      }\n    } else {\n      connection.query(this.text)\n    }\n    return null\n  }\n\n  hasBeenParsed(connection) {\n    return this.name && connection.parsedStatements[this.name]\n  }\n\n  handlePortalSuspended(connection) {\n    this._getRows(connection, this.rows)\n  }\n\n  _getRows(connection, rows) {\n    connection.execute({\n      portal: this.portal,\n      rows: rows,\n    })\n    // if we're not reading pages of rows send the sync command\n    // to indicate the pipeline is finished\n    if (!rows) {\n      connection.sync()\n    } else {\n      // otherwise flush the call out to read more rows\n      connection.flush()\n    }\n  }\n\n  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n  prepare(connection) {\n    // TODO refactor this poor encapsulation\n    if (!this.hasBeenParsed(connection)) {\n      connection.parse({\n        text: this.text,\n        name: this.name,\n        types: this.types,\n      })\n    }\n\n    // because we're mapping user supplied values to\n    // postgres wire protocol compatible values it could\n    // throw an exception, so try/catch this section\n    try {\n      connection.bind({\n        portal: this.portal,\n        statement: this.name,\n        values: this.values,\n        binary: this.binary,\n        valueMapper: utils.prepareValue,\n      })\n    } catch (err) {\n      this.handleError(err, connection)\n      return\n    }\n\n    connection.describe({\n      type: 'P',\n      name: this.portal || '',\n    })\n\n    this._getRows(connection, this.rows)\n  }\n\n  handleCopyInResponse(connection) {\n    connection.sendCopyFail('No source stream defined')\n  }\n\n  handleCopyData(msg, connection) {\n    // noop\n  }\n}\n\nmodule.exports = Query\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFekMsZUFBZSxtQkFBTyxDQUFDLDZGQUFVO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQywyRkFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgRXZlbnRFbWl0dGVyIH0gPSByZXF1aXJlKCdldmVudHMnKVxuXG5jb25zdCBSZXN1bHQgPSByZXF1aXJlKCcuL3Jlc3VsdCcpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5jbGFzcyBRdWVyeSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKClcblxuICAgIGNvbmZpZyA9IHV0aWxzLm5vcm1hbGl6ZVF1ZXJ5Q29uZmlnKGNvbmZpZywgdmFsdWVzLCBjYWxsYmFjaylcblxuICAgIHRoaXMudGV4dCA9IGNvbmZpZy50ZXh0XG4gICAgdGhpcy52YWx1ZXMgPSBjb25maWcudmFsdWVzXG4gICAgdGhpcy5yb3dzID0gY29uZmlnLnJvd3NcbiAgICB0aGlzLnR5cGVzID0gY29uZmlnLnR5cGVzXG4gICAgdGhpcy5uYW1lID0gY29uZmlnLm5hbWVcbiAgICB0aGlzLnF1ZXJ5TW9kZSA9IGNvbmZpZy5xdWVyeU1vZGVcbiAgICB0aGlzLmJpbmFyeSA9IGNvbmZpZy5iaW5hcnlcbiAgICAvLyB1c2UgdW5pcXVlIHBvcnRhbCBuYW1lIGVhY2ggdGltZVxuICAgIHRoaXMucG9ydGFsID0gY29uZmlnLnBvcnRhbCB8fCAnJ1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgICB0aGlzLl9yb3dNb2RlID0gY29uZmlnLnJvd01vZGVcbiAgICBpZiAocHJvY2Vzcy5kb21haW4gJiYgY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gcHJvY2Vzcy5kb21haW4uYmluZChjb25maWcuY2FsbGJhY2spXG4gICAgfVxuICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBSZXN1bHQodGhpcy5fcm93TW9kZSwgdGhpcy50eXBlcylcblxuICAgIC8vIHBvdGVudGlhbCBmb3IgbXVsdGlwbGUgcmVzdWx0c1xuICAgIHRoaXMuX3Jlc3VsdHMgPSB0aGlzLl9yZXN1bHRcbiAgICB0aGlzLl9jYW5jZWxlZER1ZVRvRXJyb3IgPSBmYWxzZVxuICB9XG5cbiAgcmVxdWlyZXNQcmVwYXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5xdWVyeU1vZGUgPT09ICdleHRlbmRlZCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gbmFtZWQgcXVlcmllcyBtdXN0IGFsd2F5cyBiZSBwcmVwYXJlZFxuICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFsd2F5cyBwcmVwYXJlIGlmIHRoZXJlIGFyZSBtYXggbnVtYmVyIG9mIHJvd3MgZXhwZWN0ZWQgcGVyXG4gICAgLy8gcG9ydGFsIGV4ZWN1dGlvblxuICAgIGlmICh0aGlzLnJvd3MpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGRvbid0IHByZXBhcmUgZW1wdHkgdGV4dCBxdWVyaWVzXG4gICAgaWYgKCF0aGlzLnRleHQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBwcmVwYXJlIGlmIHRoZXJlIGFyZSB2YWx1ZXNcbiAgICBpZiAoIXRoaXMudmFsdWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCA+IDBcbiAgfVxuXG4gIF9jaGVja0Zvck11bHRpcm93KCkge1xuICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHJlc3VsdCB3aXRoIGEgY29tbWFuZCBwcm9wZXJ0eVxuICAgIC8vIHRoZW4gd2UndmUgYWxyZWFkeSBleGVjdXRlZCBvbmUgcXVlcnkgaW4gYSBtdWx0aS1zdGF0ZW1lbnQgc2ltcGxlIHF1ZXJ5XG4gICAgLy8gdHVybiBvdXIgcmVzdWx0cyBpbnRvIGFuIGFycmF5IG9mIHJlc3VsdHNcbiAgICBpZiAodGhpcy5fcmVzdWx0LmNvbW1hbmQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9yZXN1bHRzKSkge1xuICAgICAgICB0aGlzLl9yZXN1bHRzID0gW3RoaXMuX3Jlc3VsdF1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBSZXN1bHQodGhpcy5fcm93TW9kZSwgdGhpcy5fcmVzdWx0Ll90eXBlcylcbiAgICAgIHRoaXMuX3Jlc3VsdHMucHVzaCh0aGlzLl9yZXN1bHQpXG4gICAgfVxuICB9XG5cbiAgLy8gYXNzb2NpYXRlcyByb3cgbWV0YWRhdGEgZnJvbSB0aGUgc3VwcGxpZWRcbiAgLy8gbWVzc2FnZSB3aXRoIHRoaXMgcXVlcnkgb2JqZWN0XG4gIC8vIG1ldGFkYXRhIHVzZWQgd2hlbiBwYXJzaW5nIHJvdyByZXN1bHRzXG4gIGhhbmRsZVJvd0Rlc2NyaXB0aW9uKG1zZykge1xuICAgIHRoaXMuX2NoZWNrRm9yTXVsdGlyb3coKVxuICAgIHRoaXMuX3Jlc3VsdC5hZGRGaWVsZHMobXNnLmZpZWxkcylcbiAgICB0aGlzLl9hY2N1bXVsYXRlUm93cyA9IHRoaXMuY2FsbGJhY2sgfHwgIXRoaXMubGlzdGVuZXJzKCdyb3cnKS5sZW5ndGhcbiAgfVxuXG4gIGhhbmRsZURhdGFSb3cobXNnKSB7XG4gICAgbGV0IHJvd1xuXG4gICAgaWYgKHRoaXMuX2NhbmNlbGVkRHVlVG9FcnJvcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJvdyA9IHRoaXMuX3Jlc3VsdC5wYXJzZVJvdyhtc2cuZmllbGRzKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fY2FuY2VsZWREdWVUb0Vycm9yID0gZXJyXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3JvdycsIHJvdywgdGhpcy5fcmVzdWx0KVxuICAgIGlmICh0aGlzLl9hY2N1bXVsYXRlUm93cykge1xuICAgICAgdGhpcy5fcmVzdWx0LmFkZFJvdyhyb3cpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ29tbWFuZENvbXBsZXRlKG1zZywgY29ubmVjdGlvbikge1xuICAgIHRoaXMuX2NoZWNrRm9yTXVsdGlyb3coKVxuICAgIHRoaXMuX3Jlc3VsdC5hZGRDb21tYW5kQ29tcGxldGUobXNnKVxuICAgIC8vIG5lZWQgdG8gc3luYyBhZnRlciBlYWNoIGNvbW1hbmQgY29tcGxldGUgb2YgYSBwcmVwYXJlZCBzdGF0ZW1lbnRcbiAgICAvLyBpZiB3ZSB3ZXJlIHVzaW5nIGEgcm93IGNvdW50IHdoaWNoIHJlc3VsdHMgaW4gbXVsdGlwbGUgY2FsbHMgdG8gX2dldFJvd3NcbiAgICBpZiAodGhpcy5yb3dzKSB7XG4gICAgICBjb25uZWN0aW9uLnN5bmMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGEgbmFtZWQgcHJlcGFyZWQgc3RhdGVtZW50IGlzIGNyZWF0ZWQgd2l0aCBlbXB0eSBxdWVyeSB0ZXh0XG4gIC8vIHRoZSBiYWNrZW5kIHdpbGwgc2VuZCBhbiBlbXB0eVF1ZXJ5IG1lc3NhZ2UgYnV0ICpub3QqIGEgY29tbWFuZCBjb21wbGV0ZSBtZXNzYWdlXG4gIC8vIHNpbmNlIHdlIHBpcGVsaW5lIHN5bmMgaW1tZWRpYXRlbHkgYWZ0ZXIgZXhlY3V0ZSB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmVcbiAgLy8gdW5sZXNzIHdlIGhhdmUgcm93cyBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2Ugd2UgZGlkIG5vdCBwaXBlbGluZSB0aGUgaW5pdGlhbCBzeW5jIGNhbGxcbiAgaGFuZGxlRW1wdHlRdWVyeShjb25uZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMucm93cykge1xuICAgICAgY29ubmVjdGlvbi5zeW5jKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVFcnJvcihlcnIsIGNvbm5lY3Rpb24pIHtcbiAgICAvLyBuZWVkIHRvIHN5bmMgYWZ0ZXIgZXJyb3IgZHVyaW5nIGEgcHJlcGFyZWQgc3RhdGVtZW50XG4gICAgaWYgKHRoaXMuX2NhbmNlbGVkRHVlVG9FcnJvcikge1xuICAgICAgZXJyID0gdGhpcy5fY2FuY2VsZWREdWVUb0Vycm9yXG4gICAgICB0aGlzLl9jYW5jZWxlZER1ZVRvRXJyb3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBpZiBjYWxsYmFjayBzdXBwbGllZCBkbyBub3QgZW1pdCBlcnJvciBldmVudCBhcyB1bmNhdWdodCBlcnJvclxuICAgIC8vIGV2ZW50cyB3aWxsIGJ1YmJsZSB1cCB0byBub2RlIHByb2Nlc3NcbiAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICB9XG5cbiAgaGFuZGxlUmVhZHlGb3JRdWVyeShjb24pIHtcbiAgICBpZiAodGhpcy5fY2FuY2VsZWREdWVUb0Vycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVFcnJvcih0aGlzLl9jYW5jZWxlZER1ZVRvRXJyb3IsIGNvbilcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgdGhpcy5fcmVzdWx0cylcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbWl0KCdlbmQnLCB0aGlzLl9yZXN1bHRzKVxuICB9XG5cbiAgc3VibWl0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHRoaXMudGV4dCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHRoaXMubmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0EgcXVlcnkgbXVzdCBoYXZlIGVpdGhlciB0ZXh0IG9yIGEgbmFtZS4gU3VwcGx5aW5nIG5laXRoZXIgaXMgdW5zdXBwb3J0ZWQuJylcbiAgICB9XG4gICAgY29uc3QgcHJldmlvdXMgPSBjb25uZWN0aW9uLnBhcnNlZFN0YXRlbWVudHNbdGhpcy5uYW1lXVxuICAgIGlmICh0aGlzLnRleHQgJiYgcHJldmlvdXMgJiYgdGhpcy50ZXh0ICE9PSBwcmV2aW91cykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUHJlcGFyZWQgc3RhdGVtZW50cyBtdXN0IGJlIHVuaXF1ZSAtICcke3RoaXMubmFtZX0nIHdhcyB1c2VkIGZvciBhIGRpZmZlcmVudCBzdGF0ZW1lbnRgKVxuICAgIH1cbiAgICBpZiAodGhpcy52YWx1ZXMgJiYgIUFycmF5LmlzQXJyYXkodGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdRdWVyeSB2YWx1ZXMgbXVzdCBiZSBhbiBhcnJheScpXG4gICAgfVxuICAgIGlmICh0aGlzLnJlcXVpcmVzUHJlcGFyYXRpb24oKSkge1xuICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIGV4dGVuZGVkIHF1ZXJ5IHByb3RvY29sIHdlIGZpcmUgb2ZmIHNldmVyYWwgc2VwYXJhdGUgY29tbWFuZHNcbiAgICAgIC8vIHRvIHRoZSBiYWNrZW5kLiBPbiBzb21lIHZlcnNpb25zIG9mIG5vZGUgJiBzb21lIG9wZXJhdGluZyBzeXN0ZW0gdmVyc2lvbnNcbiAgICAgIC8vIHRoZSBuZXR3b3JrIHN0YWNrIHdyaXRlcyBlYWNoIG1lc3NhZ2Ugc2VwYXJhdGVseSBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyB0aGVtIHRvZ2V0aGVyXG4gICAgICAvLyBjYXVzaW5nIHRoZSBjbGllbnQgJiBuZXR3b3JrIHRvIHNlbmQgbW9yZSBzbG93bHkuIENvcmtpbmcgJiB1bmNvcmtpbmcgdGhlIHN0cmVhbVxuICAgICAgLy8gYWxsb3dzIG5vZGUgdG8gYnVmZmVyIHVwIHRoZSBtZXNzYWdlcyBpbnRlcm5hbGx5IGJlZm9yZSBzZW5kaW5nIHRoZW0gYWxsIG9mZiBhdCBvbmNlLlxuICAgICAgLy8gbm90ZTogd2UncmUgY2hlY2tpbmcgZm9yIGV4aXN0ZW5jZSBvZiBjb3JrL3VuY29yayBiZWNhdXNlIHNvbWUgdmVyc2lvbnMgb2Ygc3RyZWFtc1xuICAgICAgLy8gbWlnaHQgbm90IGhhdmUgdGhpcyAoY2xvdWRmbGFyZT8pXG4gICAgICBjb25uZWN0aW9uLnN0cmVhbS5jb3JrICYmIGNvbm5lY3Rpb24uc3RyZWFtLmNvcmsoKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5wcmVwYXJlKGNvbm5lY3Rpb24pXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyB3aGlsZSB1bmxpa2VseSBmb3IgdGhpcy5wcmVwYXJlIHRvIHRocm93LCBpZiBpdCBkb2VzICYgd2UgZG9uJ3QgdW5jb3JrIHRoaXMgc3RyZWFtXG4gICAgICAgIC8vIHRoaXMgY2xpZW50IGJlY29tZXMgdW5yZXNwb25zaXZlLCBzbyBwdXQgaW4gZmluYWxseSBibG9jayBcImp1c3QgaW4gY2FzZVwiXG4gICAgICAgIGNvbm5lY3Rpb24uc3RyZWFtLnVuY29yayAmJiBjb25uZWN0aW9uLnN0cmVhbS51bmNvcmsoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0aW9uLnF1ZXJ5KHRoaXMudGV4dClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGhhc0JlZW5QYXJzZWQoY29ubmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLm5hbWUgJiYgY29ubmVjdGlvbi5wYXJzZWRTdGF0ZW1lbnRzW3RoaXMubmFtZV1cbiAgfVxuXG4gIGhhbmRsZVBvcnRhbFN1c3BlbmRlZChjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5fZ2V0Um93cyhjb25uZWN0aW9uLCB0aGlzLnJvd3MpXG4gIH1cblxuICBfZ2V0Um93cyhjb25uZWN0aW9uLCByb3dzKSB7XG4gICAgY29ubmVjdGlvbi5leGVjdXRlKHtcbiAgICAgIHBvcnRhbDogdGhpcy5wb3J0YWwsXG4gICAgICByb3dzOiByb3dzLFxuICAgIH0pXG4gICAgLy8gaWYgd2UncmUgbm90IHJlYWRpbmcgcGFnZXMgb2Ygcm93cyBzZW5kIHRoZSBzeW5jIGNvbW1hbmRcbiAgICAvLyB0byBpbmRpY2F0ZSB0aGUgcGlwZWxpbmUgaXMgZmluaXNoZWRcbiAgICBpZiAoIXJvd3MpIHtcbiAgICAgIGNvbm5lY3Rpb24uc3luYygpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBmbHVzaCB0aGUgY2FsbCBvdXQgdG8gcmVhZCBtb3JlIHJvd3NcbiAgICAgIGNvbm5lY3Rpb24uZmx1c2goKVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHA6Ly9kZXZlbG9wZXIucG9zdGdyZXNxbC5vcmcvcGdkb2NzL3Bvc3RncmVzL3Byb3RvY29sLWZsb3cuaHRtbCNQUk9UT0NPTC1GTE9XLUVYVC1RVUVSWVxuICBwcmVwYXJlKGNvbm5lY3Rpb24pIHtcbiAgICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMgcG9vciBlbmNhcHN1bGF0aW9uXG4gICAgaWYgKCF0aGlzLmhhc0JlZW5QYXJzZWQoY29ubmVjdGlvbikpIHtcbiAgICAgIGNvbm5lY3Rpb24ucGFyc2Uoe1xuICAgICAgICB0ZXh0OiB0aGlzLnRleHQsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgbWFwcGluZyB1c2VyIHN1cHBsaWVkIHZhbHVlcyB0b1xuICAgIC8vIHBvc3RncmVzIHdpcmUgcHJvdG9jb2wgY29tcGF0aWJsZSB2YWx1ZXMgaXQgY291bGRcbiAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIHRyeS9jYXRjaCB0aGlzIHNlY3Rpb25cbiAgICB0cnkge1xuICAgICAgY29ubmVjdGlvbi5iaW5kKHtcbiAgICAgICAgcG9ydGFsOiB0aGlzLnBvcnRhbCxcbiAgICAgICAgc3RhdGVtZW50OiB0aGlzLm5hbWUsXG4gICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMsXG4gICAgICAgIGJpbmFyeTogdGhpcy5iaW5hcnksXG4gICAgICAgIHZhbHVlTWFwcGVyOiB1dGlscy5wcmVwYXJlVmFsdWUsXG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnIsIGNvbm5lY3Rpb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLmRlc2NyaWJlKHtcbiAgICAgIHR5cGU6ICdQJyxcbiAgICAgIG5hbWU6IHRoaXMucG9ydGFsIHx8ICcnLFxuICAgIH0pXG5cbiAgICB0aGlzLl9nZXRSb3dzKGNvbm5lY3Rpb24sIHRoaXMucm93cylcbiAgfVxuXG4gIGhhbmRsZUNvcHlJblJlc3BvbnNlKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLnNlbmRDb3B5RmFpbCgnTm8gc291cmNlIHN0cmVhbSBkZWZpbmVkJylcbiAgfVxuXG4gIGhhbmRsZUNvcHlEYXRhKG1zZywgY29ubmVjdGlvbikge1xuICAgIC8vIG5vb3BcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/query.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst types = __webpack_require__(/*! pg-types */ \"(api-node)/../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js\")\n\nconst matchRegexp = /^([A-Za-z]+)(?: (\\d+))?(?: (\\d+))?/\n\n// result object returned from query\n// in the 'end' event and also\n// passed as second argument to provided callback\nclass Result {\n  constructor(rowMode, types) {\n    this.command = null\n    this.rowCount = null\n    this.oid = null\n    this.rows = []\n    this.fields = []\n    this._parsers = undefined\n    this._types = types\n    this.RowCtor = null\n    this.rowAsArray = rowMode === 'array'\n    if (this.rowAsArray) {\n      this.parseRow = this._parseRowAsArray\n    }\n    this._prebuiltEmptyResultObject = null\n  }\n\n  // adds a command complete message\n  addCommandComplete(msg) {\n    let match\n    if (msg.text) {\n      // pure javascript\n      match = matchRegexp.exec(msg.text)\n    } else {\n      // native bindings\n      match = matchRegexp.exec(msg.command)\n    }\n    if (match) {\n      this.command = match[1]\n      if (match[3]) {\n        // COMMAND OID ROWS\n        this.oid = parseInt(match[2], 10)\n        this.rowCount = parseInt(match[3], 10)\n      } else if (match[2]) {\n        // COMMAND ROWS\n        this.rowCount = parseInt(match[2], 10)\n      }\n    }\n  }\n\n  _parseRowAsArray(rowData) {\n    const row = new Array(rowData.length)\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i]\n      if (rawValue !== null) {\n        row[i] = this._parsers[i](rawValue)\n      } else {\n        row[i] = null\n      }\n    }\n    return row\n  }\n\n  parseRow(rowData) {\n    const row = { ...this._prebuiltEmptyResultObject }\n    for (let i = 0, len = rowData.length; i < len; i++) {\n      const rawValue = rowData[i]\n      const field = this.fields[i].name\n      if (rawValue !== null) {\n        const v = this.fields[i].format === 'binary' ? Buffer.from(rawValue) : rawValue\n        row[field] = this._parsers[i](v)\n      } else {\n        row[field] = null\n      }\n    }\n    return row\n  }\n\n  addRow(row) {\n    this.rows.push(row)\n  }\n\n  addFields(fieldDescriptions) {\n    // clears field definitions\n    // multiple query statements in 1 action can result in multiple sets\n    // of rowDescriptions...eg: 'select NOW(); select 1::int;'\n    // you need to reset the fields\n    this.fields = fieldDescriptions\n    if (this.fields.length) {\n      this._parsers = new Array(fieldDescriptions.length)\n    }\n\n    const row = {}\n\n    for (let i = 0; i < fieldDescriptions.length; i++) {\n      const desc = fieldDescriptions[i]\n      row[desc.name] = null\n\n      if (this._types) {\n        this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text')\n      } else {\n        this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text')\n      }\n    }\n\n    this._prebuiltEmptyResultObject = { ...row }\n  }\n}\n\nmodule.exports = Result\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvcmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGNBQWMsbUJBQU8sQ0FBQyxtR0FBVTs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQiwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi9yZXN1bHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgncGctdHlwZXMnKVxuXG5jb25zdCBtYXRjaFJlZ2V4cCA9IC9eKFtBLVphLXpdKykoPzogKFxcZCspKT8oPzogKFxcZCspKT8vXG5cbi8vIHJlc3VsdCBvYmplY3QgcmV0dXJuZWQgZnJvbSBxdWVyeVxuLy8gaW4gdGhlICdlbmQnIGV2ZW50IGFuZCBhbHNvXG4vLyBwYXNzZWQgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHByb3ZpZGVkIGNhbGxiYWNrXG5jbGFzcyBSZXN1bHQge1xuICBjb25zdHJ1Y3Rvcihyb3dNb2RlLCB0eXBlcykge1xuICAgIHRoaXMuY29tbWFuZCA9IG51bGxcbiAgICB0aGlzLnJvd0NvdW50ID0gbnVsbFxuICAgIHRoaXMub2lkID0gbnVsbFxuICAgIHRoaXMucm93cyA9IFtdXG4gICAgdGhpcy5maWVsZHMgPSBbXVxuICAgIHRoaXMuX3BhcnNlcnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl90eXBlcyA9IHR5cGVzXG4gICAgdGhpcy5Sb3dDdG9yID0gbnVsbFxuICAgIHRoaXMucm93QXNBcnJheSA9IHJvd01vZGUgPT09ICdhcnJheSdcbiAgICBpZiAodGhpcy5yb3dBc0FycmF5KSB7XG4gICAgICB0aGlzLnBhcnNlUm93ID0gdGhpcy5fcGFyc2VSb3dBc0FycmF5XG4gICAgfVxuICAgIHRoaXMuX3ByZWJ1aWx0RW1wdHlSZXN1bHRPYmplY3QgPSBudWxsXG4gIH1cblxuICAvLyBhZGRzIGEgY29tbWFuZCBjb21wbGV0ZSBtZXNzYWdlXG4gIGFkZENvbW1hbmRDb21wbGV0ZShtc2cpIHtcbiAgICBsZXQgbWF0Y2hcbiAgICBpZiAobXNnLnRleHQpIHtcbiAgICAgIC8vIHB1cmUgamF2YXNjcmlwdFxuICAgICAgbWF0Y2ggPSBtYXRjaFJlZ2V4cC5leGVjKG1zZy50ZXh0KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuYXRpdmUgYmluZGluZ3NcbiAgICAgIG1hdGNoID0gbWF0Y2hSZWdleHAuZXhlYyhtc2cuY29tbWFuZClcbiAgICB9XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0aGlzLmNvbW1hbmQgPSBtYXRjaFsxXVxuICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgIC8vIENPTU1BTkQgT0lEIFJPV1NcbiAgICAgICAgdGhpcy5vaWQgPSBwYXJzZUludChtYXRjaFsyXSwgMTApXG4gICAgICAgIHRoaXMucm93Q291bnQgPSBwYXJzZUludChtYXRjaFszXSwgMTApXG4gICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIENPTU1BTkQgUk9XU1xuICAgICAgICB0aGlzLnJvd0NvdW50ID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVJvd0FzQXJyYXkocm93RGF0YSkge1xuICAgIGNvbnN0IHJvdyA9IG5ldyBBcnJheShyb3dEYXRhLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcm93RGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcmF3VmFsdWUgPSByb3dEYXRhW2ldXG4gICAgICBpZiAocmF3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcm93W2ldID0gdGhpcy5fcGFyc2Vyc1tpXShyYXdWYWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvd1tpXSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd1xuICB9XG5cbiAgcGFyc2VSb3cocm93RGF0YSkge1xuICAgIGNvbnN0IHJvdyA9IHsgLi4udGhpcy5fcHJlYnVpbHRFbXB0eVJlc3VsdE9iamVjdCB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJvd0RhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcm93RGF0YVtpXVxuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1tpXS5uYW1lXG4gICAgICBpZiAocmF3VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuZmllbGRzW2ldLmZvcm1hdCA9PT0gJ2JpbmFyeScgPyBCdWZmZXIuZnJvbShyYXdWYWx1ZSkgOiByYXdWYWx1ZVxuICAgICAgICByb3dbZmllbGRdID0gdGhpcy5fcGFyc2Vyc1tpXSh2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93W2ZpZWxkXSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd1xuICB9XG5cbiAgYWRkUm93KHJvdykge1xuICAgIHRoaXMucm93cy5wdXNoKHJvdylcbiAgfVxuXG4gIGFkZEZpZWxkcyhmaWVsZERlc2NyaXB0aW9ucykge1xuICAgIC8vIGNsZWFycyBmaWVsZCBkZWZpbml0aW9uc1xuICAgIC8vIG11bHRpcGxlIHF1ZXJ5IHN0YXRlbWVudHMgaW4gMSBhY3Rpb24gY2FuIHJlc3VsdCBpbiBtdWx0aXBsZSBzZXRzXG4gICAgLy8gb2Ygcm93RGVzY3JpcHRpb25zLi4uZWc6ICdzZWxlY3QgTk9XKCk7IHNlbGVjdCAxOjppbnQ7J1xuICAgIC8vIHlvdSBuZWVkIHRvIHJlc2V0IHRoZSBmaWVsZHNcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkRGVzY3JpcHRpb25zXG4gICAgaWYgKHRoaXMuZmllbGRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcGFyc2VycyA9IG5ldyBBcnJheShmaWVsZERlc2NyaXB0aW9ucy5sZW5ndGgpXG4gICAgfVxuXG4gICAgY29uc3Qgcm93ID0ge31cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGREZXNjcmlwdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBmaWVsZERlc2NyaXB0aW9uc1tpXVxuICAgICAgcm93W2Rlc2MubmFtZV0gPSBudWxsXG5cbiAgICAgIGlmICh0aGlzLl90eXBlcykge1xuICAgICAgICB0aGlzLl9wYXJzZXJzW2ldID0gdGhpcy5fdHlwZXMuZ2V0VHlwZVBhcnNlcihkZXNjLmRhdGFUeXBlSUQsIGRlc2MuZm9ybWF0IHx8ICd0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcnNlcnNbaV0gPSB0eXBlcy5nZXRUeXBlUGFyc2VyKGRlc2MuZGF0YVR5cGVJRCwgZGVzYy5mb3JtYXQgfHwgJ3RleHQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ByZWJ1aWx0RW1wdHlSZXN1bHRPYmplY3QgPSB7IC4uLnJvdyB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/result.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { getStream, getSecureStream } = getStreamFuncs()\n\nmodule.exports = {\n  /**\n   * Get a socket stream compatible with the current runtime environment.\n   * @returns {Duplex}\n   */\n  getStream,\n  /**\n   * Get a TLS secured socket, compatible with the current environment,\n   * using the socket and other settings given in `options`.\n   * @returns {Duplex}\n   */\n  getSecureStream,\n}\n\n/**\n * The stream functions that work in Node.js\n */\nfunction getNodejsStreamFuncs() {\n  function getStream(ssl) {\n    const net = __webpack_require__(/*! net */ \"net\")\n    return new net.Socket()\n  }\n\n  function getSecureStream(options) {\n    const tls = __webpack_require__(/*! tls */ \"tls\")\n    return tls.connect(options)\n  }\n  return {\n    getStream,\n    getSecureStream,\n  }\n}\n\n/**\n * The stream functions that work in Cloudflare Workers\n */\nfunction getCloudflareStreamFuncs() {\n  function getStream(ssl) {\n    const { CloudflareSocket } = __webpack_require__(/*! pg-cloudflare */ \"(api-node)/../../node_modules/.pnpm/pg-cloudflare@1.2.7/node_modules/pg-cloudflare/dist/empty.js\")\n    return new CloudflareSocket(ssl)\n  }\n\n  function getSecureStream(options) {\n    options.socket.startTls(options)\n    return options.socket\n  }\n  return {\n    getStream,\n    getSecureStream,\n  }\n}\n\n/**\n * Are we running in a Cloudflare Worker?\n *\n * @returns true if the code is currently running inside a Cloudflare Worker.\n */\nfunction isCloudflareRuntime() {\n  // Since 2022-03-21 the `global_navigator` compatibility flag is on for Cloudflare Workers\n  // which means that `navigator.userAgent` will be defined.\n  // eslint-disable-next-line no-undef\n  if (typeof navigator === 'object' && navigator !== null && typeof navigator.userAgent === 'string') {\n    // eslint-disable-next-line no-undef\n    return navigator.userAgent === 'Cloudflare-Workers'\n  }\n  // In case `navigator` or `navigator.userAgent` is not defined then try a more sneaky approach\n  if (typeof Response === 'function') {\n    const resp = new Response(null, { cf: { thing: true } })\n    if (typeof resp.cf === 'object' && resp.cf !== null && resp.cf.thing) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction getStreamFuncs() {\n  if (isCloudflareRuntime()) {\n    return getCloudflareStreamFuncs()\n  }\n  return getNodejsStreamFuncs()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsNkJBQTZCOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdCQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxnQkFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLHVIQUFlO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2FzbGFrL3JlcG9zL3BsYW4tZWF0LXJlcGVhdC9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZ2V0U3RyZWFtLCBnZXRTZWN1cmVTdHJlYW0gfSA9IGdldFN0cmVhbUZ1bmNzKClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzb2NrZXQgc3RyZWFtIGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICAgKiBAcmV0dXJucyB7RHVwbGV4fVxuICAgKi9cbiAgZ2V0U3RyZWFtLFxuICAvKipcbiAgICogR2V0IGEgVExTIHNlY3VyZWQgc29ja2V0LCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQsXG4gICAqIHVzaW5nIHRoZSBzb2NrZXQgYW5kIG90aGVyIHNldHRpbmdzIGdpdmVuIGluIGBvcHRpb25zYC5cbiAgICogQHJldHVybnMge0R1cGxleH1cbiAgICovXG4gIGdldFNlY3VyZVN0cmVhbSxcbn1cblxuLyoqXG4gKiBUaGUgc3RyZWFtIGZ1bmN0aW9ucyB0aGF0IHdvcmsgaW4gTm9kZS5qc1xuICovXG5mdW5jdGlvbiBnZXROb2RlanNTdHJlYW1GdW5jcygpIHtcbiAgZnVuY3Rpb24gZ2V0U3RyZWFtKHNzbCkge1xuICAgIGNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpXG4gICAgcmV0dXJuIG5ldyBuZXQuU29ja2V0KClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY3VyZVN0cmVhbShvcHRpb25zKSB7XG4gICAgY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJylcbiAgICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucylcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFN0cmVhbSxcbiAgICBnZXRTZWN1cmVTdHJlYW0sXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgc3RyZWFtIGZ1bmN0aW9ucyB0aGF0IHdvcmsgaW4gQ2xvdWRmbGFyZSBXb3JrZXJzXG4gKi9cbmZ1bmN0aW9uIGdldENsb3VkZmxhcmVTdHJlYW1GdW5jcygpIHtcbiAgZnVuY3Rpb24gZ2V0U3RyZWFtKHNzbCkge1xuICAgIGNvbnN0IHsgQ2xvdWRmbGFyZVNvY2tldCB9ID0gcmVxdWlyZSgncGctY2xvdWRmbGFyZScpXG4gICAgcmV0dXJuIG5ldyBDbG91ZGZsYXJlU29ja2V0KHNzbClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY3VyZVN0cmVhbShvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5zb2NrZXQuc3RhcnRUbHMob3B0aW9ucylcbiAgICByZXR1cm4gb3B0aW9ucy5zb2NrZXRcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFN0cmVhbSxcbiAgICBnZXRTZWN1cmVTdHJlYW0sXG4gIH1cbn1cblxuLyoqXG4gKiBBcmUgd2UgcnVubmluZyBpbiBhIENsb3VkZmxhcmUgV29ya2VyP1xuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGNvZGUgaXMgY3VycmVudGx5IHJ1bm5pbmcgaW5zaWRlIGEgQ2xvdWRmbGFyZSBXb3JrZXIuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRmbGFyZVJ1bnRpbWUoKSB7XG4gIC8vIFNpbmNlIDIwMjItMDMtMjEgdGhlIGBnbG9iYWxfbmF2aWdhdG9yYCBjb21wYXRpYmlsaXR5IGZsYWcgaXMgb24gZm9yIENsb3VkZmxhcmUgV29ya2Vyc1xuICAvLyB3aGljaCBtZWFucyB0aGF0IGBuYXZpZ2F0b3IudXNlckFnZW50YCB3aWxsIGJlIGRlZmluZWQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yICE9PSBudWxsICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnQ2xvdWRmbGFyZS1Xb3JrZXJzJ1xuICB9XG4gIC8vIEluIGNhc2UgYG5hdmlnYXRvcmAgb3IgYG5hdmlnYXRvci51c2VyQWdlbnRgIGlzIG5vdCBkZWZpbmVkIHRoZW4gdHJ5IGEgbW9yZSBzbmVha3kgYXBwcm9hY2hcbiAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobnVsbCwgeyBjZjogeyB0aGluZzogdHJ1ZSB9IH0pXG4gICAgaWYgKHR5cGVvZiByZXNwLmNmID09PSAnb2JqZWN0JyAmJiByZXNwLmNmICE9PSBudWxsICYmIHJlc3AuY2YudGhpbmcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRTdHJlYW1GdW5jcygpIHtcbiAgaWYgKGlzQ2xvdWRmbGFyZVJ1bnRpbWUoKSkge1xuICAgIHJldHVybiBnZXRDbG91ZGZsYXJlU3RyZWFtRnVuY3MoKVxuICB9XG4gIHJldHVybiBnZXROb2RlanNTdHJlYW1GdW5jcygpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/stream.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst types = __webpack_require__(/*! pg-types */ \"(api-node)/../../node_modules/.pnpm/pg-types@2.2.0/node_modules/pg-types/index.js\")\n\nfunction TypeOverrides(userTypes) {\n  this._types = userTypes || types\n  this.text = {}\n  this.binary = {}\n}\n\nTypeOverrides.prototype.getOverrides = function (format) {\n  switch (format) {\n    case 'text':\n      return this.text\n    case 'binary':\n      return this.binary\n    default:\n      return {}\n  }\n}\n\nTypeOverrides.prototype.setTypeParser = function (oid, format, parseFn) {\n  if (typeof format === 'function') {\n    parseFn = format\n    format = 'text'\n  }\n  this.getOverrides(format)[oid] = parseFn\n}\n\nTypeOverrides.prototype.getTypeParser = function (oid, format) {\n  format = format || 'text'\n  return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format)\n}\n\nmodule.exports = TypeOverrides\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvdHlwZS1vdmVycmlkZXMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosY0FBYyxtQkFBTyxDQUFDLG1HQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnL2xpYi90eXBlLW92ZXJyaWRlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCdwZy10eXBlcycpXG5cbmZ1bmN0aW9uIFR5cGVPdmVycmlkZXModXNlclR5cGVzKSB7XG4gIHRoaXMuX3R5cGVzID0gdXNlclR5cGVzIHx8IHR5cGVzXG4gIHRoaXMudGV4dCA9IHt9XG4gIHRoaXMuYmluYXJ5ID0ge31cbn1cblxuVHlwZU92ZXJyaWRlcy5wcm90b3R5cGUuZ2V0T3ZlcnJpZGVzID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgcmV0dXJuIHRoaXMudGV4dFxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHt9XG4gIH1cbn1cblxuVHlwZU92ZXJyaWRlcy5wcm90b3R5cGUuc2V0VHlwZVBhcnNlciA9IGZ1bmN0aW9uIChvaWQsIGZvcm1hdCwgcGFyc2VGbikge1xuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcnNlRm4gPSBmb3JtYXRcbiAgICBmb3JtYXQgPSAndGV4dCdcbiAgfVxuICB0aGlzLmdldE92ZXJyaWRlcyhmb3JtYXQpW29pZF0gPSBwYXJzZUZuXG59XG5cblR5cGVPdmVycmlkZXMucHJvdG90eXBlLmdldFR5cGVQYXJzZXIgPSBmdW5jdGlvbiAob2lkLCBmb3JtYXQpIHtcbiAgZm9ybWF0ID0gZm9ybWF0IHx8ICd0ZXh0J1xuICByZXR1cm4gdGhpcy5nZXRPdmVycmlkZXMoZm9ybWF0KVtvaWRdIHx8IHRoaXMuX3R5cGVzLmdldFR5cGVQYXJzZXIob2lkLCBmb3JtYXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZU92ZXJyaWRlc1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/type-overrides.js\n");

/***/ }),

/***/ "(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst defaults = __webpack_require__(/*! ./defaults */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/defaults.js\")\n\nconst util = __webpack_require__(/*! util */ \"util\")\nconst { isDate } = util.types || util // Node 8 doesn't have `util.types`\n\nfunction escapeElement(elementRepresentation) {\n  const escaped = elementRepresentation.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')\n\n  return '\"' + escaped + '\"'\n}\n\n// convert a JS array to a postgres array literal\n// uses comma separator so won't work for types like box that use\n// a different array separator.\nfunction arrayString(val) {\n  let result = '{'\n  for (let i = 0; i < val.length; i++) {\n    if (i > 0) {\n      result = result + ','\n    }\n    if (val[i] === null || typeof val[i] === 'undefined') {\n      result = result + 'NULL'\n    } else if (Array.isArray(val[i])) {\n      result = result + arrayString(val[i])\n    } else if (ArrayBuffer.isView(val[i])) {\n      let item = val[i]\n      if (!(item instanceof Buffer)) {\n        const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength)\n        if (buf.length === item.byteLength) {\n          item = buf\n        } else {\n          item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength)\n        }\n      }\n      result += '\\\\\\\\x' + item.toString('hex')\n    } else {\n      result += escapeElement(prepareValue(val[i]))\n    }\n  }\n  result = result + '}'\n  return result\n}\n\n// converts values from javascript types\n// to their 'raw' counterparts for use as a postgres parameter\n// note: you can override this function to provide your own conversion mechanism\n// for complex types, etc...\nconst prepareValue = function (val, seen) {\n  // null and undefined are both null for postgres\n  if (val == null) {\n    return null\n  }\n  if (typeof val === 'object') {\n    if (val instanceof Buffer) {\n      return val\n    }\n    if (ArrayBuffer.isView(val)) {\n      const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength)\n      if (buf.length === val.byteLength) {\n        return buf\n      }\n      return buf.slice(val.byteOffset, val.byteOffset + val.byteLength) // Node.js v4 does not support those Buffer.from params\n    }\n    if (isDate(val)) {\n      if (defaults.parseInputDatesAsUTC) {\n        return dateToStringUTC(val)\n      } else {\n        return dateToString(val)\n      }\n    }\n    if (Array.isArray(val)) {\n      return arrayString(val)\n    }\n\n    return prepareObject(val, seen)\n  }\n  return val.toString()\n}\n\nfunction prepareObject(val, seen) {\n  if (val && typeof val.toPostgres === 'function') {\n    seen = seen || []\n    if (seen.indexOf(val) !== -1) {\n      throw new Error('circular reference detected while preparing \"' + val + '\" for query')\n    }\n    seen.push(val)\n\n    return prepareValue(val.toPostgres(prepareValue), seen)\n  }\n  return JSON.stringify(val)\n}\n\nfunction dateToString(date) {\n  let offset = -date.getTimezoneOffset()\n\n  let year = date.getFullYear()\n  const isBCYear = year < 1\n  if (isBCYear) year = Math.abs(year) + 1 // negative years are 1 off their BC representation\n\n  let ret =\n    String(year).padStart(4, '0') +\n    '-' +\n    String(date.getMonth() + 1).padStart(2, '0') +\n    '-' +\n    String(date.getDate()).padStart(2, '0') +\n    'T' +\n    String(date.getHours()).padStart(2, '0') +\n    ':' +\n    String(date.getMinutes()).padStart(2, '0') +\n    ':' +\n    String(date.getSeconds()).padStart(2, '0') +\n    '.' +\n    String(date.getMilliseconds()).padStart(3, '0')\n\n  if (offset < 0) {\n    ret += '-'\n    offset *= -1\n  } else {\n    ret += '+'\n  }\n\n  ret += String(Math.floor(offset / 60)).padStart(2, '0') + ':' + String(offset % 60).padStart(2, '0')\n  if (isBCYear) ret += ' BC'\n  return ret\n}\n\nfunction dateToStringUTC(date) {\n  let year = date.getUTCFullYear()\n  const isBCYear = year < 1\n  if (isBCYear) year = Math.abs(year) + 1 // negative years are 1 off their BC representation\n\n  let ret =\n    String(year).padStart(4, '0') +\n    '-' +\n    String(date.getUTCMonth() + 1).padStart(2, '0') +\n    '-' +\n    String(date.getUTCDate()).padStart(2, '0') +\n    'T' +\n    String(date.getUTCHours()).padStart(2, '0') +\n    ':' +\n    String(date.getUTCMinutes()).padStart(2, '0') +\n    ':' +\n    String(date.getUTCSeconds()).padStart(2, '0') +\n    '.' +\n    String(date.getUTCMilliseconds()).padStart(3, '0')\n\n  ret += '+00:00'\n  if (isBCYear) ret += ' BC'\n  return ret\n}\n\nfunction normalizeQueryConfig(config, values, callback) {\n  // can take in strings or config objects\n  config = typeof config === 'string' ? { text: config } : config\n  if (values) {\n    if (typeof values === 'function') {\n      config.callback = values\n    } else {\n      config.values = values\n    }\n  }\n  if (callback) {\n    config.callback = callback\n  }\n  return config\n}\n\n// Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\nconst escapeIdentifier = function (str) {\n  return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n}\n\nconst escapeLiteral = function (str) {\n  let hasBackslash = false\n  let escaped = \"'\"\n\n  if (str == null) {\n    return \"''\"\n  }\n\n  if (typeof str !== 'string') {\n    return \"''\"\n  }\n\n  for (let i = 0; i < str.length; i++) {\n    const c = str[i]\n    if (c === \"'\") {\n      escaped += c + c\n    } else if (c === '\\\\') {\n      escaped += c + c\n      hasBackslash = true\n    } else {\n      escaped += c\n    }\n  }\n\n  escaped += \"'\"\n\n  if (hasBackslash === true) {\n    escaped = ' E' + escaped\n  }\n\n  return escaped\n}\n\nmodule.exports = {\n  prepareValue: function prepareValueWrapper(value) {\n    // this ensures that extra arguments do not get passed into prepareValue\n    // by accident, eg: from calling values.map(utils.prepareValue)\n    return prepareValue(value)\n  },\n  normalizeQueryConfig,\n  escapeIdentifier,\n  escapeLiteral,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosaUJBQWlCLG1CQUFPLENBQUMsaUdBQVk7O0FBRXJDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixRQUFRLFNBQVM7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hc2xhay9yZXBvcy9wbGFuLWVhdC1yZXBlYXQvbm9kZV9tb2R1bGVzLy5wbnBtL3BnQDguMTYuMy9ub2RlX21vZHVsZXMvcGcvbGliL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKVxuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCB7IGlzRGF0ZSB9ID0gdXRpbC50eXBlcyB8fCB1dGlsIC8vIE5vZGUgOCBkb2Vzbid0IGhhdmUgYHV0aWwudHlwZXNgXG5cbmZ1bmN0aW9uIGVzY2FwZUVsZW1lbnQoZWxlbWVudFJlcHJlc2VudGF0aW9uKSB7XG4gIGNvbnN0IGVzY2FwZWQgPSBlbGVtZW50UmVwcmVzZW50YXRpb24ucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcblxuICByZXR1cm4gJ1wiJyArIGVzY2FwZWQgKyAnXCInXG59XG5cbi8vIGNvbnZlcnQgYSBKUyBhcnJheSB0byBhIHBvc3RncmVzIGFycmF5IGxpdGVyYWxcbi8vIHVzZXMgY29tbWEgc2VwYXJhdG9yIHNvIHdvbid0IHdvcmsgZm9yIHR5cGVzIGxpa2UgYm94IHRoYXQgdXNlXG4vLyBhIGRpZmZlcmVudCBhcnJheSBzZXBhcmF0b3IuXG5mdW5jdGlvbiBhcnJheVN0cmluZyh2YWwpIHtcbiAgbGV0IHJlc3VsdCA9ICd7J1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgJywnXG4gICAgfVxuICAgIGlmICh2YWxbaV0gPT09IG51bGwgfHwgdHlwZW9mIHZhbFtpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArICdOVUxMJ1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWxbaV0pKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyBhcnJheVN0cmluZyh2YWxbaV0pXG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsW2ldKSkge1xuICAgICAgbGV0IGl0ZW0gPSB2YWxbaV1cbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKGl0ZW0uYnVmZmVyLCBpdGVtLmJ5dGVPZmZzZXQsIGl0ZW0uYnl0ZUxlbmd0aClcbiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IGl0ZW0uYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGl0ZW0gPSBidWZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtID0gYnVmLnNsaWNlKGl0ZW0uYnl0ZU9mZnNldCwgaXRlbS5ieXRlT2Zmc2V0ICsgaXRlbS5ieXRlTGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gJ1xcXFxcXFxceCcgKyBpdGVtLnRvU3RyaW5nKCdoZXgnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZXNjYXBlRWxlbWVudChwcmVwYXJlVmFsdWUodmFsW2ldKSlcbiAgICB9XG4gIH1cbiAgcmVzdWx0ID0gcmVzdWx0ICsgJ30nXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gY29udmVydHMgdmFsdWVzIGZyb20gamF2YXNjcmlwdCB0eXBlc1xuLy8gdG8gdGhlaXIgJ3JhdycgY291bnRlcnBhcnRzIGZvciB1c2UgYXMgYSBwb3N0Z3JlcyBwYXJhbWV0ZXJcbi8vIG5vdGU6IHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBwcm92aWRlIHlvdXIgb3duIGNvbnZlcnNpb24gbWVjaGFuaXNtXG4vLyBmb3IgY29tcGxleCB0eXBlcywgZXRjLi4uXG5jb25zdCBwcmVwYXJlVmFsdWUgPSBmdW5jdGlvbiAodmFsLCBzZWVuKSB7XG4gIC8vIG51bGwgYW5kIHVuZGVmaW5lZCBhcmUgYm90aCBudWxsIGZvciBwb3N0Z3Jlc1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWwpKSB7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbSh2YWwuYnVmZmVyLCB2YWwuYnl0ZU9mZnNldCwgdmFsLmJ5dGVMZW5ndGgpXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gdmFsLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZlxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSh2YWwuYnl0ZU9mZnNldCwgdmFsLmJ5dGVPZmZzZXQgKyB2YWwuYnl0ZUxlbmd0aCkgLy8gTm9kZS5qcyB2NCBkb2VzIG5vdCBzdXBwb3J0IHRob3NlIEJ1ZmZlci5mcm9tIHBhcmFtc1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbCkpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5wYXJzZUlucHV0RGF0ZXNBc1VUQykge1xuICAgICAgICByZXR1cm4gZGF0ZVRvU3RyaW5nVVRDKHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRlVG9TdHJpbmcodmFsKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gYXJyYXlTdHJpbmcodmFsKVxuICAgIH1cblxuICAgIHJldHVybiBwcmVwYXJlT2JqZWN0KHZhbCwgc2VlbilcbiAgfVxuICByZXR1cm4gdmFsLnRvU3RyaW5nKClcbn1cblxuZnVuY3Rpb24gcHJlcGFyZU9iamVjdCh2YWwsIHNlZW4pIHtcbiAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsLnRvUG9zdGdyZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzZWVuID0gc2VlbiB8fCBbXVxuICAgIGlmIChzZWVuLmluZGV4T2YodmFsKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIHdoaWxlIHByZXBhcmluZyBcIicgKyB2YWwgKyAnXCIgZm9yIHF1ZXJ5JylcbiAgICB9XG4gICAgc2Vlbi5wdXNoKHZhbClcblxuICAgIHJldHVybiBwcmVwYXJlVmFsdWUodmFsLnRvUG9zdGdyZXMocHJlcGFyZVZhbHVlKSwgc2VlbilcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKVxufVxuXG5mdW5jdGlvbiBkYXRlVG9TdHJpbmcoZGF0ZSkge1xuICBsZXQgb2Zmc2V0ID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKVxuXG4gIGxldCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpXG4gIGNvbnN0IGlzQkNZZWFyID0geWVhciA8IDFcbiAgaWYgKGlzQkNZZWFyKSB5ZWFyID0gTWF0aC5hYnMoeWVhcikgKyAxIC8vIG5lZ2F0aXZlIHllYXJzIGFyZSAxIG9mZiB0aGVpciBCQyByZXByZXNlbnRhdGlvblxuXG4gIGxldCByZXQgPVxuICAgIFN0cmluZyh5ZWFyKS5wYWRTdGFydCg0LCAnMCcpICtcbiAgICAnLScgK1xuICAgIFN0cmluZyhkYXRlLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCAnMCcpICtcbiAgICAnLScgK1xuICAgIFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgJzAnKSArXG4gICAgJ1QnICtcbiAgICBTdHJpbmcoZGF0ZS5nZXRIb3VycygpKS5wYWRTdGFydCgyLCAnMCcpICtcbiAgICAnOicgK1xuICAgIFN0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSkucGFkU3RhcnQoMiwgJzAnKSArXG4gICAgJzonICtcbiAgICBTdHJpbmcoZGF0ZS5nZXRTZWNvbmRzKCkpLnBhZFN0YXJ0KDIsICcwJykgK1xuICAgICcuJyArXG4gICAgU3RyaW5nKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpLnBhZFN0YXJ0KDMsICcwJylcblxuICBpZiAob2Zmc2V0IDwgMCkge1xuICAgIHJldCArPSAnLSdcbiAgICBvZmZzZXQgKj0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXQgKz0gJysnXG4gIH1cblxuICByZXQgKz0gU3RyaW5nKE1hdGguZmxvb3Iob2Zmc2V0IC8gNjApKS5wYWRTdGFydCgyLCAnMCcpICsgJzonICsgU3RyaW5nKG9mZnNldCAlIDYwKS5wYWRTdGFydCgyLCAnMCcpXG4gIGlmIChpc0JDWWVhcikgcmV0ICs9ICcgQkMnXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gZGF0ZVRvU3RyaW5nVVRDKGRhdGUpIHtcbiAgbGV0IHllYXIgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcbiAgY29uc3QgaXNCQ1llYXIgPSB5ZWFyIDwgMVxuICBpZiAoaXNCQ1llYXIpIHllYXIgPSBNYXRoLmFicyh5ZWFyKSArIDEgLy8gbmVnYXRpdmUgeWVhcnMgYXJlIDEgb2ZmIHRoZWlyIEJDIHJlcHJlc2VudGF0aW9uXG5cbiAgbGV0IHJldCA9XG4gICAgU3RyaW5nKHllYXIpLnBhZFN0YXJ0KDQsICcwJykgK1xuICAgICctJyArXG4gICAgU3RyaW5nKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsICcwJykgK1xuICAgICctJyArXG4gICAgU3RyaW5nKGRhdGUuZ2V0VVRDRGF0ZSgpKS5wYWRTdGFydCgyLCAnMCcpICtcbiAgICAnVCcgK1xuICAgIFN0cmluZyhkYXRlLmdldFVUQ0hvdXJzKCkpLnBhZFN0YXJ0KDIsICcwJykgK1xuICAgICc6JyArXG4gICAgU3RyaW5nKGRhdGUuZ2V0VVRDTWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpICtcbiAgICAnOicgK1xuICAgIFN0cmluZyhkYXRlLmdldFVUQ1NlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKSArXG4gICAgJy4nICtcbiAgICBTdHJpbmcoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKSkucGFkU3RhcnQoMywgJzAnKVxuXG4gIHJldCArPSAnKzAwOjAwJ1xuICBpZiAoaXNCQ1llYXIpIHJldCArPSAnIEJDJ1xuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVF1ZXJ5Q29uZmlnKGNvbmZpZywgdmFsdWVzLCBjYWxsYmFjaykge1xuICAvLyBjYW4gdGFrZSBpbiBzdHJpbmdzIG9yIGNvbmZpZyBvYmplY3RzXG4gIGNvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8geyB0ZXh0OiBjb25maWcgfSA6IGNvbmZpZ1xuICBpZiAodmFsdWVzKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbmZpZy5jYWxsYmFjayA9IHZhbHVlc1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcudmFsdWVzID0gdmFsdWVzXG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNvbmZpZy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cbiAgcmV0dXJuIGNvbmZpZ1xufVxuXG4vLyBQb3J0ZWQgZnJvbSBQb3N0Z3JlU1FMIDkuMi40IHNvdXJjZSBjb2RlIGluIHNyYy9pbnRlcmZhY2VzL2xpYnBxL2ZlLWV4ZWMuY1xuY29uc3QgZXNjYXBlSWRlbnRpZmllciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuICdcIicgKyBzdHIucmVwbGFjZSgvXCIvZywgJ1wiXCInKSArICdcIidcbn1cblxuY29uc3QgZXNjYXBlTGl0ZXJhbCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgbGV0IGhhc0JhY2tzbGFzaCA9IGZhbHNlXG4gIGxldCBlc2NhcGVkID0gXCInXCJcblxuICBpZiAoc3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gXCInJ1wiXG4gIH1cblxuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gXCInJ1wiXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGMgPSBzdHJbaV1cbiAgICBpZiAoYyA9PT0gXCInXCIpIHtcbiAgICAgIGVzY2FwZWQgKz0gYyArIGNcbiAgICB9IGVsc2UgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgZXNjYXBlZCArPSBjICsgY1xuICAgICAgaGFzQmFja3NsYXNoID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBlc2NhcGVkICs9IGNcbiAgICB9XG4gIH1cblxuICBlc2NhcGVkICs9IFwiJ1wiXG5cbiAgaWYgKGhhc0JhY2tzbGFzaCA9PT0gdHJ1ZSkge1xuICAgIGVzY2FwZWQgPSAnIEUnICsgZXNjYXBlZFxuICB9XG5cbiAgcmV0dXJuIGVzY2FwZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByZXBhcmVWYWx1ZTogZnVuY3Rpb24gcHJlcGFyZVZhbHVlV3JhcHBlcih2YWx1ZSkge1xuICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IGV4dHJhIGFyZ3VtZW50cyBkbyBub3QgZ2V0IHBhc3NlZCBpbnRvIHByZXBhcmVWYWx1ZVxuICAgIC8vIGJ5IGFjY2lkZW50LCBlZzogZnJvbSBjYWxsaW5nIHZhbHVlcy5tYXAodXRpbHMucHJlcGFyZVZhbHVlKVxuICAgIHJldHVybiBwcmVwYXJlVmFsdWUodmFsdWUpXG4gIH0sXG4gIG5vcm1hbGl6ZVF1ZXJ5Q29uZmlnLFxuICBlc2NhcGVJZGVudGlmaWVyLFxuICBlc2NhcGVMaXRlcmFsLFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/utils.js\n");

/***/ })

};
;