"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@prisma+client-runtime-utils@7.1.0";
exports.ids = ["vendor-chunks/@prisma+client-runtime-utils@7.1.0"];
exports.modules = {

/***/ "(api-node)/../../node_modules/.pnpm/@prisma+client-runtime-utils@7.1.0/node_modules/@prisma/client-runtime-utils/dist/index.js":
/*!***************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@prisma+client-runtime-utils@7.1.0/node_modules/@prisma/client-runtime-utils/dist/index.js ***!
  \***************************************************************************************************************************/
/***/ ((module) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  AnyNull: () => AnyNull,\n  AnyNullClass: () => AnyNullClass,\n  DbNull: () => DbNull,\n  DbNullClass: () => DbNullClass,\n  Decimal: () => Decimal,\n  JsonNull: () => JsonNull,\n  JsonNullClass: () => JsonNullClass,\n  NullTypes: () => NullTypes,\n  ObjectEnumValue: () => ObjectEnumValue,\n  PrismaClientInitializationError: () => PrismaClientInitializationError,\n  PrismaClientKnownRequestError: () => PrismaClientKnownRequestError,\n  PrismaClientRustError: () => PrismaClientRustError,\n  PrismaClientRustPanicError: () => PrismaClientRustPanicError,\n  PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError,\n  PrismaClientValidationError: () => PrismaClientValidationError,\n  Sql: () => Sql,\n  empty: () => empty,\n  hasBatchIndex: () => hasBatchIndex,\n  isAnyNull: () => isAnyNull,\n  isDbNull: () => isDbNull,\n  isJsonNull: () => isJsonNull,\n  join: () => join,\n  raw: () => raw,\n  sql: () => sql\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/errors/ErrorWithBatchIndex.ts\nfunction hasBatchIndex(value) {\n  return typeof value[\"batchRequestIdx\"] === \"number\";\n}\n\n// src/errors/setClassName.ts\nfunction setClassName(classObject, name) {\n  Object.defineProperty(classObject, \"name\", {\n    value: name,\n    configurable: true\n  });\n}\n\n// src/errors/PrismaClientInitializationError.ts\nvar PrismaClientInitializationError = class _PrismaClientInitializationError extends Error {\n  clientVersion;\n  errorCode;\n  retryable;\n  constructor(message, clientVersion, errorCode) {\n    super(message);\n    this.name = \"PrismaClientInitializationError\";\n    this.clientVersion = clientVersion;\n    this.errorCode = errorCode;\n    Error.captureStackTrace(_PrismaClientInitializationError);\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientInitializationError\";\n  }\n};\nsetClassName(PrismaClientInitializationError, \"PrismaClientInitializationError\");\n\n// src/errors/PrismaClientKnownRequestError.ts\nvar PrismaClientKnownRequestError = class extends Error {\n  code;\n  meta;\n  clientVersion;\n  batchRequestIdx;\n  constructor(message, { code, clientVersion, meta, batchRequestIdx }) {\n    super(message);\n    this.name = \"PrismaClientKnownRequestError\";\n    this.code = code;\n    this.clientVersion = clientVersion;\n    this.meta = meta;\n    Object.defineProperty(this, \"batchRequestIdx\", {\n      value: batchRequestIdx,\n      enumerable: false,\n      writable: true\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientKnownRequestError\";\n  }\n};\nsetClassName(PrismaClientKnownRequestError, \"PrismaClientKnownRequestError\");\n\n// src/errors/log.ts\nfunction getBacktrace(log3) {\n  if (log3.fields?.message) {\n    let str = log3.fields?.message;\n    if (log3.fields?.file) {\n      str += ` in ${log3.fields.file}`;\n      if (log3.fields?.line) {\n        str += `:${log3.fields.line}`;\n      }\n      if (log3.fields?.column) {\n        str += `:${log3.fields.column}`;\n      }\n    }\n    if (log3.fields?.reason) {\n      str += `\n${log3.fields?.reason}`;\n    }\n    return str;\n  }\n  return \"Unknown error\";\n}\nfunction isPanic(err) {\n  return err.fields?.message === \"PANIC\";\n}\n\n// src/errors/PrismaClientRustError.ts\nvar PrismaClientRustError = class extends Error {\n  clientVersion;\n  _isPanic;\n  constructor({ clientVersion, error }) {\n    const backtrace = getBacktrace(error);\n    super(backtrace ?? \"Unknown error\");\n    this._isPanic = isPanic(error);\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustError\";\n  }\n  isPanic() {\n    return this._isPanic;\n  }\n};\nsetClassName(PrismaClientRustError, \"PrismaClientRustError\");\n\n// src/errors/PrismaClientRustPanicError.ts\nvar PrismaClientRustPanicError = class extends Error {\n  clientVersion;\n  constructor(message, clientVersion) {\n    super(message);\n    this.name = \"PrismaClientRustPanicError\";\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientRustPanicError\";\n  }\n};\nsetClassName(PrismaClientRustPanicError, \"PrismaClientRustPanicError\");\n\n// src/errors/PrismaClientUnknownRequestError.ts\nvar PrismaClientUnknownRequestError = class extends Error {\n  clientVersion;\n  batchRequestIdx;\n  constructor(message, { clientVersion, batchRequestIdx }) {\n    super(message);\n    this.name = \"PrismaClientUnknownRequestError\";\n    this.clientVersion = clientVersion;\n    Object.defineProperty(this, \"batchRequestIdx\", {\n      value: batchRequestIdx,\n      writable: true,\n      enumerable: false\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientUnknownRequestError\";\n  }\n};\nsetClassName(PrismaClientUnknownRequestError, \"PrismaClientUnknownRequestError\");\n\n// src/errors/PrismaClientValidationError.ts\nvar PrismaClientValidationError = class extends Error {\n  name = \"PrismaClientValidationError\";\n  clientVersion;\n  constructor(message, { clientVersion }) {\n    super(message);\n    this.clientVersion = clientVersion;\n  }\n  get [Symbol.toStringTag]() {\n    return \"PrismaClientValidationError\";\n  }\n};\nsetClassName(PrismaClientValidationError, \"PrismaClientValidationError\");\n\n// src/nullTypes.ts\nvar secret = Symbol();\nvar representations = /* @__PURE__ */ new WeakMap();\nvar ObjectEnumValue = class {\n  constructor(arg) {\n    if (arg === secret) {\n      representations.set(this, `Prisma.${this._getName()}`);\n    } else {\n      representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);\n    }\n  }\n  _getName() {\n    return this.constructor.name;\n  }\n  toString() {\n    return representations.get(this);\n  }\n};\nfunction setClassName2(classObject, name) {\n  Object.defineProperty(classObject, \"name\", {\n    value: name,\n    configurable: true\n  });\n}\nvar NullTypesEnumValue = class extends ObjectEnumValue {\n  _getNamespace() {\n    return \"NullTypes\";\n  }\n};\nvar DbNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_DbNull;\n};\nsetClassName2(DbNullClass, \"DbNull\");\nvar JsonNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_JsonNull;\n};\nsetClassName2(JsonNullClass, \"JsonNull\");\nvar AnyNullClass = class extends NullTypesEnumValue {\n  // Phantom private property to prevent structural type equality\n  // eslint-disable-next-line no-unused-private-class-members\n  #_brand_AnyNull;\n};\nsetClassName2(AnyNullClass, \"AnyNull\");\nvar NullTypes = {\n  DbNull: DbNullClass,\n  JsonNull: JsonNullClass,\n  AnyNull: AnyNullClass\n};\nvar DbNull = new DbNullClass(secret);\nvar JsonNull = new JsonNullClass(secret);\nvar AnyNull = new AnyNullClass(secret);\nfunction isDbNull(value) {\n  return value === DbNull;\n}\nfunction isJsonNull(value) {\n  return value === JsonNull;\n}\nfunction isAnyNull(value) {\n  return value === AnyNull;\n}\n\n// ../../node_modules/.pnpm/decimal.js@10.5.0/node_modules/decimal.js/decimal.mjs\nvar EXP_LIMIT = 9e15;\nvar MAX_DIGITS = 1e9;\nvar NUMERALS = \"0123456789abcdef\";\nvar LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\";\nvar PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\";\nvar DEFAULTS = {\n  // These values must be integers within the stated ranges (inclusive).\n  // Most of these values can be changed at run-time using the `Decimal.config` method.\n  // The maximum number of significant digits of the result of a calculation or base conversion.\n  // E.g. `Decimal.config({ precision: 20 });`\n  precision: 20,\n  // 1 to MAX_DIGITS\n  // The rounding mode used when rounding to `precision`.\n  //\n  // ROUND_UP         0 Away from zero.\n  // ROUND_DOWN       1 Towards zero.\n  // ROUND_CEIL       2 Towards +Infinity.\n  // ROUND_FLOOR      3 Towards -Infinity.\n  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n  //\n  // E.g.\n  // `Decimal.rounding = 4;`\n  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n  rounding: 4,\n  // 0 to 8\n  // The modulo mode used when calculating the modulus: a mod n.\n  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n  // The remainder (r) is calculated as: r = a - n * q.\n  //\n  // UP         0 The remainder is positive if the dividend is negative, else is negative.\n  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n  // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n  // HALF_EVEN  6 The IEEE 754 remainder function.\n  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n  //\n  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n  // division (9) are commonly used for the modulus operation. The other rounding modes can also\n  // be used, but they may not give useful results.\n  modulo: 1,\n  // 0 to 9\n  // The exponent value at and beneath which `toString` returns exponential notation.\n  // JavaScript numbers: -7\n  toExpNeg: -7,\n  // 0 to -EXP_LIMIT\n  // The exponent value at and above which `toString` returns exponential notation.\n  // JavaScript numbers: 21\n  toExpPos: 21,\n  // 0 to EXP_LIMIT\n  // The minimum exponent value, beneath which underflow to zero occurs.\n  // JavaScript numbers: -324  (5e-324)\n  minE: -EXP_LIMIT,\n  // -1 to -EXP_LIMIT\n  // The maximum exponent value, above which overflow to Infinity occurs.\n  // JavaScript numbers: 308  (1.7976931348623157e+308)\n  maxE: EXP_LIMIT,\n  // 1 to EXP_LIMIT\n  // Whether to use cryptographically-secure random number generation, if available.\n  crypto: false\n  // true/false\n};\nvar inexact;\nvar quadrant;\nvar external = true;\nvar decimalError = \"[DecimalError] \";\nvar invalidArgument = decimalError + \"Invalid argument: \";\nvar precisionLimitExceeded = decimalError + \"Precision limit exceeded\";\nvar cryptoUnavailable = decimalError + \"crypto unavailable\";\nvar tag = \"[object Decimal]\";\nvar mathfloor = Math.floor;\nvar mathpow = Math.pow;\nvar isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i;\nvar isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i;\nvar isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i;\nvar isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\nvar BASE = 1e7;\nvar LOG_BASE = 7;\nvar MAX_SAFE_INTEGER = 9007199254740991;\nvar LN10_PRECISION = LN10.length - 1;\nvar PI_PRECISION = PI.length - 1;\nvar P = { toStringTag: tag };\nP.absoluteValue = P.abs = function() {\n  var x = new this.constructor(this);\n  if (x.s < 0) x.s = 1;\n  return finalise(x);\n};\nP.ceil = function() {\n  return finalise(new this.constructor(this), this.e + 1, 2);\n};\nP.clampedTo = P.clamp = function(min2, max2) {\n  var k, x = this, Ctor = x.constructor;\n  min2 = new Ctor(min2);\n  max2 = new Ctor(max2);\n  if (!min2.s || !max2.s) return new Ctor(NaN);\n  if (min2.gt(max2)) throw Error(invalidArgument + max2);\n  k = x.cmp(min2);\n  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);\n};\nP.comparedTo = P.cmp = function(y) {\n  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n  if (!xd || !yd) {\n    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n  }\n  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n  if (xs !== ys) return xs;\n  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n  xdL = xd.length;\n  ydL = yd.length;\n  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\n    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n  }\n  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\nP.cosine = P.cos = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.d) return new Ctor(NaN);\n  if (!x.d[0]) return new Ctor(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\nP.cubeRoot = P.cbrt = function() {\n  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  external = false;\n  s = x.s * mathpow(x.s * x, 1 / 3);\n  if (!s || Math.abs(s) == 1 / 0) {\n    n = digitsToString(x.d);\n    e = x.e;\n    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n    s = mathpow(n, 1 / 3);\n    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n    r.s = x.s;\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    t3 = t.times(t).times(t);\n    t3plusx = t3.plus(x);\n    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.decimalPlaces = P.dp = function() {\n  var w, d = this.d, n = NaN;\n  if (d) {\n    w = d.length - 1;\n    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n    w = d[w];\n    if (w) for (; w % 10 == 0; w /= 10) n--;\n    if (n < 0) n = 0;\n  }\n  return n;\n};\nP.dividedBy = P.div = function(y) {\n  return divide(this, new this.constructor(y));\n};\nP.dividedToIntegerBy = P.divToInt = function(y) {\n  var x = this, Ctor = x.constructor;\n  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\nP.equals = P.eq = function(y) {\n  return this.cmp(y) === 0;\n};\nP.floor = function() {\n  return finalise(new this.constructor(this), this.e + 1, 3);\n};\nP.greaterThan = P.gt = function(y) {\n  return this.cmp(y) > 0;\n};\nP.greaterThanOrEqualTo = P.gte = function(y) {\n  var k = this.cmp(y);\n  return k == 1 || k === 0;\n};\nP.hyperbolicCosine = P.cosh = function() {\n  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n  if (x.isZero()) return one;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    n = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    n = \"2.3283064365386962890625e-10\";\n  }\n  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n  var cosh2_x, i = k, d8 = new Ctor(8);\n  for (; i--; ) {\n    cosh2_x = x.times(x);\n    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n  }\n  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.hyperbolicSine = P.sinh = function() {\n  var k, pr, rm, len, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n  Ctor.rounding = 1;\n  len = x.d.length;\n  if (len < 3) {\n    x = taylorSeries(Ctor, 2, x, x, true);\n  } else {\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x, true);\n    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for (; k--; ) {\n      sinh2_x = x.times(x);\n      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n    }\n  }\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(x, pr, rm, true);\n};\nP.hyperbolicTangent = P.tanh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(x.s);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 7;\n  Ctor.rounding = 1;\n  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\nP.inverseCosine = P.acos = function() {\n  var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n  if (k !== -1) {\n    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n  }\n  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseHyperbolicCosine = P.acosh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n  if (!x.isFinite()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).minus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicSine = P.asinh = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite() || x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n  Ctor.rounding = 1;\n  external = false;\n  x = x.times(x).plus(1).sqrt().plus(x);\n  external = true;\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.ln();\n};\nP.inverseHyperbolicTangent = P.atanh = function() {\n  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  xsd = x.sd();\n  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n  Ctor.precision = wpr = xsd - x.e;\n  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n  Ctor.precision = pr + 4;\n  Ctor.rounding = 1;\n  x = x.ln();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(0.5);\n};\nP.inverseSine = P.asin = function() {\n  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n  if (x.isZero()) return new Ctor(x);\n  k = x.abs().cmp(1);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (k !== -1) {\n    if (k === 0) {\n      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n      halfPi.s = x.s;\n      return halfPi;\n    }\n    return new Ctor(NaN);\n  }\n  Ctor.precision = pr + 6;\n  Ctor.rounding = 1;\n  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return x.times(2);\n};\nP.inverseTangent = P.atan = function() {\n  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n  if (!x.isFinite()) {\n    if (!x.s) return new Ctor(NaN);\n    if (pr + 4 <= PI_PRECISION) {\n      r = getPi(Ctor, pr + 4, rm).times(0.5);\n      r.s = x.s;\n      return r;\n    }\n  } else if (x.isZero()) {\n    return new Ctor(x);\n  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n    r = getPi(Ctor, pr + 4, rm).times(0.25);\n    r.s = x.s;\n    return r;\n  }\n  Ctor.precision = wpr = pr + 10;\n  Ctor.rounding = 1;\n  k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\n  external = false;\n  j = Math.ceil(wpr / LOG_BASE);\n  n = 1;\n  x2 = x.times(x);\n  r = new Ctor(x);\n  px = x;\n  for (; i !== -1; ) {\n    px = px.times(x2);\n    t = r.minus(px.div(n += 2));\n    px = px.times(x2);\n    r = t.plus(px.div(n += 2));\n    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;\n  }\n  if (k) r = r.times(2 << k - 1);\n  external = true;\n  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\nP.isFinite = function() {\n  return !!this.d;\n};\nP.isInteger = P.isInt = function() {\n  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\nP.isNaN = function() {\n  return !this.s;\n};\nP.isNegative = P.isNeg = function() {\n  return this.s < 0;\n};\nP.isPositive = P.isPos = function() {\n  return this.s > 0;\n};\nP.isZero = function() {\n  return !!this.d && this.d[0] === 0;\n};\nP.lessThan = P.lt = function(y) {\n  return this.cmp(y) < 0;\n};\nP.lessThanOrEqualTo = P.lte = function(y) {\n  return this.cmp(y) < 1;\n};\nP.logarithm = P.log = function(base) {\n  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n  if (base == null) {\n    base = new Ctor(10);\n    isBase10 = true;\n  } else {\n    base = new Ctor(base);\n    d = base.d;\n    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n    isBase10 = base.eq(10);\n  }\n  d = arg.d;\n  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n  }\n  if (isBase10) {\n    if (d.length > 1) {\n      inf = true;\n    } else {\n      for (k = d[0]; k % 10 === 0; ) k /= 10;\n      inf = k !== 1;\n    }\n  }\n  external = false;\n  sd = pr + guard;\n  num = naturalLogarithm(arg, sd);\n  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n  r = divide(num, denominator, sd, 1);\n  if (checkRoundingDigits(r.d, k = pr, rm)) {\n    do {\n      sd += 10;\n      num = naturalLogarithm(arg, sd);\n      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n      r = divide(num, denominator, sd, 1);\n      if (!inf) {\n        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n          r = finalise(r, pr + 1, 0);\n        }\n        break;\n      }\n    } while (checkRoundingDigits(r.d, k += 10, rm));\n  }\n  external = true;\n  return finalise(r, pr, rm);\n};\nP.minus = P.sub = function(y) {\n  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s) y = new Ctor(NaN);\n    else if (x.d) y.s = -y.s;\n    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.plus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (yd[0]) y.s = -y.s;\n    else if (xd[0]) y = new Ctor(x);\n    else return new Ctor(rm === 3 ? -0 : 0);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  e = mathfloor(y.e / LOG_BASE);\n  xe = mathfloor(x.e / LOG_BASE);\n  xd = xd.slice();\n  k = xe - e;\n  if (k) {\n    xLTy = k < 0;\n    if (xLTy) {\n      d = xd;\n      k = -k;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = xe;\n      len = xd.length;\n    }\n    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n    if (k > i) {\n      k = i;\n      d.length = 1;\n    }\n    d.reverse();\n    for (i = k; i--; ) d.push(0);\n    d.reverse();\n  } else {\n    i = xd.length;\n    len = yd.length;\n    xLTy = i < len;\n    if (xLTy) len = i;\n    for (i = 0; i < len; i++) {\n      if (xd[i] != yd[i]) {\n        xLTy = xd[i] < yd[i];\n        break;\n      }\n    }\n    k = 0;\n  }\n  if (xLTy) {\n    d = xd;\n    xd = yd;\n    yd = d;\n    y.s = -y.s;\n  }\n  len = xd.length;\n  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\n  for (i = yd.length; i > k; ) {\n    if (xd[--i] < yd[i]) {\n      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;\n      --xd[j];\n      xd[i] += BASE;\n    }\n    xd[i] -= yd[i];\n  }\n  for (; xd[--len] === 0; ) xd.pop();\n  for (; xd[0] === 0; xd.shift()) --e;\n  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.modulo = P.mod = function(y) {\n  var q, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n  if (!y.d || x.d && !x.d[0]) {\n    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n  }\n  external = false;\n  if (Ctor.modulo == 9) {\n    q = divide(x, y.abs(), 0, 3, 1);\n    q.s *= y.s;\n  } else {\n    q = divide(x, y, 0, Ctor.modulo, 1);\n  }\n  q = q.times(y);\n  external = true;\n  return x.minus(q);\n};\nP.naturalExponential = P.exp = function() {\n  return naturalExponential(this);\n};\nP.naturalLogarithm = P.ln = function() {\n  return naturalLogarithm(this);\n};\nP.negated = P.neg = function() {\n  var x = new this.constructor(this);\n  x.s = -x.s;\n  return finalise(x);\n};\nP.plus = P.add = function(y) {\n  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n  y = new Ctor(y);\n  if (!x.d || !y.d) {\n    if (!x.s || !y.s) y = new Ctor(NaN);\n    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n    return y;\n  }\n  if (x.s != y.s) {\n    y.s = -y.s;\n    return x.minus(y);\n  }\n  xd = x.d;\n  yd = y.d;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (!xd[0] || !yd[0]) {\n    if (!yd[0]) y = new Ctor(x);\n    return external ? finalise(y, pr, rm) : y;\n  }\n  k = mathfloor(x.e / LOG_BASE);\n  e = mathfloor(y.e / LOG_BASE);\n  xd = xd.slice();\n  i = k - e;\n  if (i) {\n    if (i < 0) {\n      d = xd;\n      i = -i;\n      len = yd.length;\n    } else {\n      d = yd;\n      e = k;\n      len = xd.length;\n    }\n    k = Math.ceil(pr / LOG_BASE);\n    len = k > len ? k + 1 : len + 1;\n    if (i > len) {\n      i = len;\n      d.length = 1;\n    }\n    d.reverse();\n    for (; i--; ) d.push(0);\n    d.reverse();\n  }\n  len = xd.length;\n  i = yd.length;\n  if (len - i < 0) {\n    i = len;\n    d = yd;\n    yd = xd;\n    xd = d;\n  }\n  for (carry = 0; i; ) {\n    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n    xd[i] %= BASE;\n  }\n  if (carry) {\n    xd.unshift(carry);\n    ++e;\n  }\n  for (len = xd.length; xd[--len] == 0; ) xd.pop();\n  y.d = xd;\n  y.e = getBase10Exponent(xd, e);\n  return external ? finalise(y, pr, rm) : y;\n};\nP.precision = P.sd = function(z) {\n  var k, x = this;\n  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n  if (x.d) {\n    k = getPrecision(x.d);\n    if (z && x.e + 1 > k) k = x.e + 1;\n  } else {\n    k = NaN;\n  }\n  return k;\n};\nP.round = function() {\n  var x = this, Ctor = x.constructor;\n  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\nP.sine = P.sin = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n  Ctor.rounding = 1;\n  x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\nP.squareRoot = P.sqrt = function() {\n  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n  if (s !== 1 || !d || !d[0]) {\n    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n  }\n  external = false;\n  s = Math.sqrt(+x);\n  if (s == 0 || s == 1 / 0) {\n    n = digitsToString(d);\n    if ((n.length + e) % 2 == 0) n += \"0\";\n    s = Math.sqrt(n);\n    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n    if (s == 1 / 0) {\n      n = \"5e\" + e;\n    } else {\n      n = s.toExponential();\n      n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n    }\n    r = new Ctor(n);\n  } else {\n    r = new Ctor(s.toString());\n  }\n  sd = (e = Ctor.precision) + 3;\n  for (; ; ) {\n    t = r;\n    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n      n = n.slice(sd - 3, sd + 1);\n      if (n == \"9999\" || !rep && n == \"4999\") {\n        if (!rep) {\n          finalise(t, e + 1, 0);\n          if (t.times(t).eq(x)) {\n            r = t;\n            break;\n          }\n        }\n        sd += 4;\n        rep = 1;\n      } else {\n        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n          finalise(r, e + 1, 1);\n          m = !r.times(r).eq(x);\n        }\n        break;\n      }\n    }\n  }\n  external = true;\n  return finalise(r, e, Ctor.rounding, m);\n};\nP.tangent = P.tan = function() {\n  var pr, rm, x = this, Ctor = x.constructor;\n  if (!x.isFinite()) return new Ctor(NaN);\n  if (x.isZero()) return new Ctor(x);\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  Ctor.precision = pr + 10;\n  Ctor.rounding = 1;\n  x = x.sin();\n  x.s = 1;\n  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n  Ctor.precision = pr;\n  Ctor.rounding = rm;\n  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\nP.times = P.mul = function(y) {\n  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n  y.s *= x.s;\n  if (!xd || !xd[0] || !yd || !yd[0]) {\n    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n  }\n  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n  xdL = xd.length;\n  ydL = yd.length;\n  if (xdL < ydL) {\n    r = xd;\n    xd = yd;\n    yd = r;\n    rL = xdL;\n    xdL = ydL;\n    ydL = rL;\n  }\n  r = [];\n  rL = xdL + ydL;\n  for (i = rL; i--; ) r.push(0);\n  for (i = ydL; --i >= 0; ) {\n    carry = 0;\n    for (k = xdL + i; k > i; ) {\n      t = r[k] + yd[i] * xd[k - i - 1] + carry;\n      r[k--] = t % BASE | 0;\n      carry = t / BASE | 0;\n    }\n    r[k] = (r[k] + carry) % BASE | 0;\n  }\n  for (; !r[--rL]; ) r.pop();\n  if (carry) ++e;\n  else r.shift();\n  y.d = r;\n  y.e = getBase10Exponent(r, e);\n  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\nP.toBinary = function(sd, rm) {\n  return toStringBinary(this, 2, sd, rm);\n};\nP.toDecimalPlaces = P.toDP = function(dp, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (dp === void 0) return x;\n  checkInt32(dp, 0, MAX_DIGITS);\n  if (rm === void 0) rm = Ctor.rounding;\n  else checkInt32(rm, 0, 8);\n  return finalise(x, dp + x.e + 1, rm);\n};\nP.toExponential = function(dp, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x, true);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), dp + 1, rm);\n    str = finiteToString(x, true, dp + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFixed = function(dp, rm) {\n  var str, y, x = this, Ctor = x.constructor;\n  if (dp === void 0) {\n    str = finiteToString(x);\n  } else {\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    y = finalise(new Ctor(x), dp + x.e + 1, rm);\n    str = finiteToString(y, false, dp + y.e + 1);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toFraction = function(maxD) {\n  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n  if (!xd) return new Ctor(x);\n  n1 = d0 = new Ctor(1);\n  d1 = n0 = new Ctor(0);\n  d = new Ctor(d1);\n  e = d.e = getPrecision(xd) - x.e - 1;\n  k = e % LOG_BASE;\n  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n  if (maxD == null) {\n    maxD = e > 0 ? d : n1;\n  } else {\n    n = new Ctor(maxD);\n    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n    maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n  }\n  external = false;\n  n = new Ctor(digitsToString(xd));\n  pr = Ctor.precision;\n  Ctor.precision = e = xd.length * LOG_BASE * 2;\n  for (; ; ) {\n    q = divide(n, d, 0, 1, 1);\n    d2 = d0.plus(q.times(d1));\n    if (d2.cmp(maxD) == 1) break;\n    d0 = d1;\n    d1 = d2;\n    d2 = n1;\n    n1 = n0.plus(q.times(d2));\n    n0 = d2;\n    d2 = d;\n    d = n.minus(q.times(d2));\n    n = d2;\n  }\n  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n  n0 = n0.plus(d2.times(n1));\n  d0 = d0.plus(d2.times(d1));\n  n0.s = n1.s = x.s;\n  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\n  Ctor.precision = pr;\n  external = true;\n  return r;\n};\nP.toHexadecimal = P.toHex = function(sd, rm) {\n  return toStringBinary(this, 16, sd, rm);\n};\nP.toNearest = function(y, rm) {\n  var x = this, Ctor = x.constructor;\n  x = new Ctor(x);\n  if (y == null) {\n    if (!x.d) return x;\n    y = new Ctor(1);\n    rm = Ctor.rounding;\n  } else {\n    y = new Ctor(y);\n    if (rm === void 0) {\n      rm = Ctor.rounding;\n    } else {\n      checkInt32(rm, 0, 8);\n    }\n    if (!x.d) return y.s ? x : y;\n    if (!y.d) {\n      if (y.s) y.s = x.s;\n      return y;\n    }\n  }\n  if (y.d[0]) {\n    external = false;\n    x = divide(x, y, 0, rm, 1).times(y);\n    external = true;\n    finalise(x);\n  } else {\n    y.s = x.s;\n    x = y;\n  }\n  return x;\n};\nP.toNumber = function() {\n  return +this;\n};\nP.toOctal = function(sd, rm) {\n  return toStringBinary(this, 8, sd, rm);\n};\nP.toPower = P.pow = function(y) {\n  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n  x = new Ctor(x);\n  if (x.eq(1)) return x;\n  pr = Ctor.precision;\n  rm = Ctor.rounding;\n  if (y.eq(1)) return finalise(x, pr, rm);\n  e = mathfloor(y.e / LOG_BASE);\n  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n    r = intPow(Ctor, x, k, pr);\n    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n  }\n  s = x.s;\n  if (s < 0) {\n    if (e < y.d.length - 1) return new Ctor(NaN);\n    if ((y.d[e] & 1) == 0) s = 1;\n    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n      x.s = s;\n      return x;\n    }\n  }\n  k = mathpow(+x, yn);\n  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n  external = false;\n  Ctor.rounding = x.s = 1;\n  k = Math.min(12, (e + \"\").length);\n  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n  if (r.d) {\n    r = finalise(r, pr + 5, 1);\n    if (checkRoundingDigits(r.d, pr, rm)) {\n      e = pr + 10;\n      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n        r = finalise(r, pr + 1, 0);\n      }\n    }\n  }\n  r.s = s;\n  external = true;\n  Ctor.rounding = rm;\n  return finalise(r, pr, rm);\n};\nP.toPrecision = function(sd, rm) {\n  var str, x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    x = finalise(new Ctor(x), sd, rm);\n    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n  }\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.toSignificantDigits = P.toSD = function(sd, rm) {\n  var x = this, Ctor = x.constructor;\n  if (sd === void 0) {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  } else {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n  }\n  return finalise(new Ctor(x), sd, rm);\n};\nP.toString = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\nP.truncated = P.trunc = function() {\n  return finalise(new this.constructor(this), this.e + 1, 1);\n};\nP.valueOf = P.toJSON = function() {\n  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n  return x.isNeg() ? \"-\" + str : str;\n};\nfunction digitsToString(d) {\n  var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n  if (indexOfLastWord > 0) {\n    str += w;\n    for (i = 1; i < indexOfLastWord; i++) {\n      ws = d[i] + \"\";\n      k = LOG_BASE - ws.length;\n      if (k) str += getZeroString(k);\n      str += ws;\n    }\n    w = d[i];\n    ws = w + \"\";\n    k = LOG_BASE - ws.length;\n    if (k) str += getZeroString(k);\n  } else if (w === 0) {\n    return \"0\";\n  }\n  for (; w % 10 === 0; ) w /= 10;\n  return str + w;\n}\nfunction checkInt32(i, min2, max2) {\n  if (i !== ~~i || i < min2 || i > max2) {\n    throw Error(invalidArgument + i);\n  }\n}\nfunction checkRoundingDigits(d, i, rm, repeating) {\n  var di, k, r, rd;\n  for (k = d[0]; k >= 10; k /= 10) --i;\n  if (--i < 0) {\n    i += LOG_BASE;\n    di = 0;\n  } else {\n    di = Math.ceil((i + 1) / LOG_BASE);\n    i %= LOG_BASE;\n  }\n  k = mathpow(10, LOG_BASE - i);\n  rd = d[di] % k | 0;\n  if (repeating == null) {\n    if (i < 3) {\n      if (i == 0) rd = rd / 100 | 0;\n      else if (i == 1) rd = rd / 10 | 0;\n      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;\n    } else {\n      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n    }\n  } else {\n    if (i < 4) {\n      if (i == 0) rd = rd / 1e3 | 0;\n      else if (i == 1) rd = rd / 100 | 0;\n      else if (i == 2) rd = rd / 10 | 0;\n      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n    } else {\n      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;\n    }\n  }\n  return r;\n}\nfunction convertBase(str, baseIn, baseOut) {\n  var j, arr = [0], arrL, i = 0, strL = str.length;\n  for (; i < strL; ) {\n    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;\n    arr[0] += NUMERALS.indexOf(str.charAt(i++));\n    for (j = 0; j < arr.length; j++) {\n      if (arr[j] > baseOut - 1) {\n        if (arr[j + 1] === void 0) arr[j + 1] = 0;\n        arr[j + 1] += arr[j] / baseOut | 0;\n        arr[j] %= baseOut;\n      }\n    }\n  }\n  return arr.reverse();\n}\nfunction cosine(Ctor, x) {\n  var k, len, y;\n  if (x.isZero()) return x;\n  len = x.d.length;\n  if (len < 32) {\n    k = Math.ceil(len / 3);\n    y = (1 / tinyPow(4, k)).toString();\n  } else {\n    k = 16;\n    y = \"2.3283064365386962890625e-10\";\n  }\n  Ctor.precision += k;\n  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n  for (var i = k; i--; ) {\n    var cos2x = x.times(x);\n    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n  }\n  Ctor.precision -= k;\n  return x;\n}\nvar divide = /* @__PURE__ */ function() {\n  function multiplyInteger(x, k, base) {\n    var temp, carry = 0, i = x.length;\n    for (x = x.slice(); i--; ) {\n      temp = x[i] * k + carry;\n      x[i] = temp % base | 0;\n      carry = temp / base | 0;\n    }\n    if (carry) x.unshift(carry);\n    return x;\n  }\n  function compare(a, b, aL, bL) {\n    var i, r;\n    if (aL != bL) {\n      r = aL > bL ? 1 : -1;\n    } else {\n      for (i = r = 0; i < aL; i++) {\n        if (a[i] != b[i]) {\n          r = a[i] > b[i] ? 1 : -1;\n          break;\n        }\n      }\n    }\n    return r;\n  }\n  function subtract(a, b, aL, base) {\n    var i = 0;\n    for (; aL--; ) {\n      a[aL] -= i;\n      i = a[aL] < b[aL] ? 1 : 0;\n      a[aL] = i * base + a[aL] - b[aL];\n    }\n    for (; !a[0] && a.length > 1; ) a.shift();\n  }\n  return function(x, y, pr, rm, dp, base) {\n    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n      return new Ctor(\n        // Return NaN if either NaN, or both Infinity or 0.\n        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0\n        )\n      );\n    }\n    if (base) {\n      logBase = 1;\n      e = x.e - y.e;\n    } else {\n      base = BASE;\n      logBase = LOG_BASE;\n      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n    }\n    yL = yd.length;\n    xL = xd.length;\n    q = new Ctor(sign2);\n    qd = q.d = [];\n    for (i = 0; yd[i] == (xd[i] || 0); i++) ;\n    if (yd[i] > (xd[i] || 0)) e--;\n    if (pr == null) {\n      sd = pr = Ctor.precision;\n      rm = Ctor.rounding;\n    } else if (dp) {\n      sd = pr + (x.e - y.e) + 1;\n    } else {\n      sd = pr;\n    }\n    if (sd < 0) {\n      qd.push(1);\n      more = true;\n    } else {\n      sd = sd / logBase + 2 | 0;\n      i = 0;\n      if (yL == 1) {\n        k = 0;\n        yd = yd[0];\n        sd++;\n        for (; (i < xL || k) && sd--; i++) {\n          t = k * base + (xd[i] || 0);\n          qd[i] = t / yd | 0;\n          k = t % yd | 0;\n        }\n        more = k || i < xL;\n      } else {\n        k = base / (yd[0] + 1) | 0;\n        if (k > 1) {\n          yd = multiplyInteger(yd, k, base);\n          xd = multiplyInteger(xd, k, base);\n          yL = yd.length;\n          xL = xd.length;\n        }\n        xi = yL;\n        rem = xd.slice(0, yL);\n        remL = rem.length;\n        for (; remL < yL; ) rem[remL++] = 0;\n        yz = yd.slice();\n        yz.unshift(0);\n        yd0 = yd[0];\n        if (yd[1] >= base / 2) ++yd0;\n        do {\n          k = 0;\n          cmp = compare(yd, rem, yL, remL);\n          if (cmp < 0) {\n            rem0 = rem[0];\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n            k = rem0 / yd0 | 0;\n            if (k > 1) {\n              if (k >= base) k = base - 1;\n              prod = multiplyInteger(yd, k, base);\n              prodL = prod.length;\n              remL = rem.length;\n              cmp = compare(prod, rem, prodL, remL);\n              if (cmp == 1) {\n                k--;\n                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n              }\n            } else {\n              if (k == 0) cmp = k = 1;\n              prod = yd.slice();\n            }\n            prodL = prod.length;\n            if (prodL < remL) prod.unshift(0);\n            subtract(rem, prod, remL, base);\n            if (cmp == -1) {\n              remL = rem.length;\n              cmp = compare(yd, rem, yL, remL);\n              if (cmp < 1) {\n                k++;\n                subtract(rem, yL < remL ? yz : yd, remL, base);\n              }\n            }\n            remL = rem.length;\n          } else if (cmp === 0) {\n            k++;\n            rem = [0];\n          }\n          qd[i++] = k;\n          if (cmp && rem[0]) {\n            rem[remL++] = xd[xi] || 0;\n          } else {\n            rem = [xd[xi]];\n            remL = 1;\n          }\n        } while ((xi++ < xL || rem[0] !== void 0) && sd--);\n        more = rem[0] !== void 0;\n      }\n      if (!qd[0]) qd.shift();\n    }\n    if (logBase == 1) {\n      q.e = e;\n      inexact = more;\n    } else {\n      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\n      q.e = i + e * logBase - 1;\n      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n    }\n    return q;\n  };\n}();\nfunction finalise(x, sd, rm, isTruncated) {\n  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n  out: if (sd != null) {\n    xd = x.d;\n    if (!xd) return x;\n    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\n    i = sd - digits;\n    if (i < 0) {\n      i += LOG_BASE;\n      j = sd;\n      w = xd[xdi = 0];\n      rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n    } else {\n      xdi = Math.ceil((i + 1) / LOG_BASE);\n      k = xd.length;\n      if (xdi >= k) {\n        if (isTruncated) {\n          for (; k++ <= xdi; ) xd.push(0);\n          w = rd = 0;\n          digits = 1;\n          i %= LOG_BASE;\n          j = i - LOG_BASE + 1;\n        } else {\n          break out;\n        }\n      } else {\n        w = k = xd[xdi];\n        for (digits = 1; k >= 10; k /= 10) digits++;\n        i %= LOG_BASE;\n        j = i - LOG_BASE + digits;\n        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n      }\n    }\n    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.\n    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n    if (sd < 1 || !xd[0]) {\n      xd.length = 0;\n      if (roundUp) {\n        sd -= x.e + 1;\n        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n        x.e = -sd || 0;\n      } else {\n        xd[0] = x.e = 0;\n      }\n      return x;\n    }\n    if (i == 0) {\n      xd.length = xdi;\n      k = 1;\n      xdi--;\n    } else {\n      xd.length = xdi + 1;\n      k = mathpow(10, LOG_BASE - i);\n      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n    }\n    if (roundUp) {\n      for (; ; ) {\n        if (xdi == 0) {\n          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\n          j = xd[0] += k;\n          for (k = 1; j >= 10; j /= 10) k++;\n          if (i != k) {\n            x.e++;\n            if (xd[0] == BASE) xd[0] = 1;\n          }\n          break;\n        } else {\n          xd[xdi] += k;\n          if (xd[xdi] != BASE) break;\n          xd[xdi--] = 0;\n          k = 1;\n        }\n      }\n    }\n    for (i = xd.length; xd[--i] === 0; ) xd.pop();\n  }\n  if (external) {\n    if (x.e > Ctor.maxE) {\n      x.d = null;\n      x.e = NaN;\n    } else if (x.e < Ctor.minE) {\n      x.e = 0;\n      x.d = [0];\n    }\n  }\n  return x;\n}\nfunction finiteToString(x, isExp, sd) {\n  if (!x.isFinite()) return nonFiniteToString(x);\n  var k, e = x.e, str = digitsToString(x.d), len = str.length;\n  if (isExp) {\n    if (sd && (k = sd - len) > 0) {\n      str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n    } else if (len > 1) {\n      str = str.charAt(0) + \".\" + str.slice(1);\n    }\n    str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n  } else if (e < 0) {\n    str = \"0.\" + getZeroString(-e - 1) + str;\n    if (sd && (k = sd - len) > 0) str += getZeroString(k);\n  } else if (e >= len) {\n    str += getZeroString(e + 1 - len);\n    if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n  } else {\n    if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n    if (sd && (k = sd - len) > 0) {\n      if (e + 1 === len) str += \".\";\n      str += getZeroString(k);\n    }\n  }\n  return str;\n}\nfunction getBase10Exponent(digits, e) {\n  var w = digits[0];\n  for (e *= LOG_BASE; w >= 10; w /= 10) e++;\n  return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n  if (sd > LN10_PRECISION) {\n    external = true;\n    if (pr) Ctor.precision = pr;\n    throw Error(precisionLimitExceeded);\n  }\n  return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n  return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n  var w = digits.length - 1, len = w * LOG_BASE + 1;\n  w = digits[w];\n  if (w) {\n    for (; w % 10 == 0; w /= 10) len--;\n    for (w = digits[0]; w >= 10; w /= 10) len++;\n  }\n  return len;\n}\nfunction getZeroString(k) {\n  var zs = \"\";\n  for (; k--; ) zs += \"0\";\n  return zs;\n}\nfunction intPow(Ctor, x, n, pr) {\n  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);\n  external = false;\n  for (; ; ) {\n    if (n % 2) {\n      r = r.times(x);\n      if (truncate(r.d, k)) isTruncated = true;\n    }\n    n = mathfloor(n / 2);\n    if (n === 0) {\n      n = r.d.length - 1;\n      if (isTruncated && r.d[n] === 0) ++r.d[n];\n      break;\n    }\n    x = x.times(x);\n    truncate(x.d, k);\n  }\n  external = true;\n  return r;\n}\nfunction isOdd(n) {\n  return n.d[n.d.length - 1] & 1;\n}\nfunction maxOrMin(Ctor, args, n) {\n  var k, y, x = new Ctor(args[0]), i = 0;\n  for (; ++i < args.length; ) {\n    y = new Ctor(args[i]);\n    if (!y.s) {\n      x = y;\n      break;\n    }\n    k = x.cmp(y);\n    if (k === n || k === 0 && x.s === n) {\n      x = y;\n    }\n  }\n  return x;\n}\nfunction naturalExponential(x, sd) {\n  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (!x.d || !x.d[0] || x.e > 17) {\n    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  t = new Ctor(0.03125);\n  while (x.e > -2) {\n    x = x.times(t);\n    k += 5;\n  }\n  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n  wpr += guard;\n  denominator = pow2 = sum2 = new Ctor(1);\n  Ctor.precision = wpr;\n  for (; ; ) {\n    pow2 = finalise(pow2.times(x), wpr, 1);\n    denominator = denominator.times(++i);\n    t = sum2.plus(divide(pow2, denominator, wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      j = k;\n      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);\n      if (sd == null) {\n        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += 10;\n          denominator = pow2 = t = new Ctor(1);\n          i = 0;\n          rep++;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n  }\n}\nfunction naturalLogarithm(y, sd) {\n  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n  }\n  if (sd == null) {\n    external = false;\n    wpr = pr;\n  } else {\n    wpr = sd;\n  }\n  Ctor.precision = wpr += guard;\n  c = digitsToString(xd);\n  c0 = c.charAt(0);\n  if (Math.abs(e = x.e) < 15e14) {\n    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\n      x = x.times(y);\n      c = digitsToString(x.d);\n      c0 = c.charAt(0);\n      n++;\n    }\n    e = x.e;\n    if (c0 > 1) {\n      x = new Ctor(\"0.\" + c);\n      e++;\n    } else {\n      x = new Ctor(c0 + \".\" + c.slice(1));\n    }\n  } else {\n    t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n    x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n    Ctor.precision = pr;\n    return sd == null ? finalise(x, pr, rm, external = true) : x;\n  }\n  x1 = x;\n  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n  x2 = finalise(x.times(x), wpr, 1);\n  denominator = 3;\n  for (; ; ) {\n    numerator = finalise(numerator.times(x2), wpr, 1);\n    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {\n      sum2 = sum2.times(2);\n      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n      sum2 = divide(sum2, new Ctor(n), wpr, 1);\n      if (sd == null) {\n        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {\n          Ctor.precision = wpr += guard;\n          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n          x2 = finalise(x.times(x), wpr, 1);\n          denominator = rep = 1;\n        } else {\n          return finalise(sum2, Ctor.precision = pr, rm, external = true);\n        }\n      } else {\n        Ctor.precision = pr;\n        return sum2;\n      }\n    }\n    sum2 = t;\n    denominator += 2;\n  }\n}\nfunction nonFiniteToString(x) {\n  return String(x.s * x.s / 0);\n}\nfunction parseDecimal(x, str) {\n  var e, i, len;\n  if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n  if ((i = str.search(/e/i)) > 0) {\n    if (e < 0) e = i;\n    e += +str.slice(i + 1);\n    str = str.substring(0, i);\n  } else if (e < 0) {\n    e = str.length;\n  }\n  for (i = 0; str.charCodeAt(i) === 48; i++) ;\n  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;\n  str = str.slice(i, len);\n  if (str) {\n    len -= i;\n    x.e = e = e - i - 1;\n    x.d = [];\n    i = (e + 1) % LOG_BASE;\n    if (e < 0) i += LOG_BASE;\n    if (i < len) {\n      if (i) x.d.push(+str.slice(0, i));\n      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));\n      str = str.slice(i);\n      i = LOG_BASE - str.length;\n    } else {\n      i -= len;\n    }\n    for (; i--; ) str += \"0\";\n    x.d.push(+str);\n    if (external) {\n      if (x.e > x.constructor.maxE) {\n        x.d = null;\n        x.e = NaN;\n      } else if (x.e < x.constructor.minE) {\n        x.e = 0;\n        x.d = [0];\n      }\n    }\n  } else {\n    x.e = 0;\n    x.d = [0];\n  }\n  return x;\n}\nfunction parseOther(x, str) {\n  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n  if (str.indexOf(\"_\") > -1) {\n    str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n    if (isDecimal.test(str)) return parseDecimal(x, str);\n  } else if (str === \"Infinity\" || str === \"NaN\") {\n    if (!+str) x.s = NaN;\n    x.e = NaN;\n    x.d = null;\n    return x;\n  }\n  if (isHex.test(str)) {\n    base = 16;\n    str = str.toLowerCase();\n  } else if (isBinary.test(str)) {\n    base = 2;\n  } else if (isOctal.test(str)) {\n    base = 8;\n  } else {\n    throw Error(invalidArgument + str);\n  }\n  i = str.search(/p/i);\n  if (i > 0) {\n    p = +str.slice(i + 1);\n    str = str.substring(2, i);\n  } else {\n    str = str.slice(2);\n  }\n  i = str.indexOf(\".\");\n  isFloat = i >= 0;\n  Ctor = x.constructor;\n  if (isFloat) {\n    str = str.replace(\".\", \"\");\n    len = str.length;\n    i = len - i;\n    divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n  }\n  xd = convertBase(str, base, BASE);\n  xe = xd.length - 1;\n  for (i = xe; xd[i] === 0; --i) xd.pop();\n  if (i < 0) return new Ctor(x.s * 0);\n  x.e = getBase10Exponent(xd, xe);\n  x.d = xd;\n  external = false;\n  if (isFloat) x = divide(x, divisor, len * 4);\n  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n  external = true;\n  return x;\n}\nfunction sine(Ctor, x) {\n  var k, len = x.d.length;\n  if (len < 3) {\n    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n  }\n  k = 1.4 * Math.sqrt(len);\n  k = k > 16 ? 16 : k | 0;\n  x = x.times(1 / tinyPow(5, k));\n  x = taylorSeries(Ctor, 2, x, x);\n  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n  for (; k--; ) {\n    sin2_x = x.times(x);\n    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n  }\n  return x;\n}\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n  external = false;\n  x2 = x.times(x);\n  u = new Ctor(y);\n  for (; ; ) {\n    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n    u = isHyperbolic ? y.plus(t) : y.minus(t);\n    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n    t = u.plus(y);\n    if (t.d[k] !== void 0) {\n      for (j = k; t.d[j] === u.d[j] && j--; ) ;\n      if (j == -1) break;\n    }\n    j = u;\n    u = y;\n    y = t;\n    t = j;\n    i++;\n  }\n  external = true;\n  t.d.length = k + 1;\n  return t;\n}\nfunction tinyPow(b, e) {\n  var n = b;\n  while (--e) n *= b;\n  return n;\n}\nfunction toLessThanHalfPi(Ctor, x) {\n  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n  x = x.abs();\n  if (x.lte(halfPi)) {\n    quadrant = isNeg ? 4 : 1;\n    return x;\n  }\n  t = x.divToInt(pi);\n  if (t.isZero()) {\n    quadrant = isNeg ? 3 : 2;\n  } else {\n    x = x.minus(t.times(pi));\n    if (x.lte(halfPi)) {\n      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n      return x;\n    }\n    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n  }\n  return x.minus(pi).abs();\n}\nfunction toStringBinary(x, baseOut, sd, rm) {\n  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n  if (isExp) {\n    checkInt32(sd, 1, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n  } else {\n    sd = Ctor.precision;\n    rm = Ctor.rounding;\n  }\n  if (!x.isFinite()) {\n    str = nonFiniteToString(x);\n  } else {\n    str = finiteToString(x);\n    i = str.indexOf(\".\");\n    if (isExp) {\n      base = 2;\n      if (baseOut == 16) {\n        sd = sd * 4 - 3;\n      } else if (baseOut == 8) {\n        sd = sd * 3 - 2;\n      }\n    } else {\n      base = baseOut;\n    }\n    if (i >= 0) {\n      str = str.replace(\".\", \"\");\n      y = new Ctor(1);\n      y.e = str.length - i;\n      y.d = convertBase(finiteToString(y), 10, base);\n      y.e = y.d.length;\n    }\n    xd = convertBase(str, 10, base);\n    e = len = xd.length;\n    for (; xd[--len] == 0; ) xd.pop();\n    if (!xd[0]) {\n      str = isExp ? \"0p+0\" : \"0\";\n    } else {\n      if (i < 0) {\n        e--;\n      } else {\n        x = new Ctor(x);\n        x.d = xd;\n        x.e = e;\n        x = divide(x, y, sd, rm, 0, base);\n        xd = x.d;\n        e = x.e;\n        roundUp = inexact;\n      }\n      i = xd[sd];\n      k = base / 2;\n      roundUp = roundUp || xd[sd + 1] !== void 0;\n      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n      xd.length = sd;\n      if (roundUp) {\n        for (; ++xd[--sd] > base - 1; ) {\n          xd[sd] = 0;\n          if (!sd) {\n            ++e;\n            xd.unshift(1);\n          }\n        }\n      }\n      for (len = xd.length; !xd[len - 1]; --len) ;\n      for (i = 0, str = \"\"; i < len; i++) str += NUMERALS.charAt(xd[i]);\n      if (isExp) {\n        if (len > 1) {\n          if (baseOut == 16 || baseOut == 8) {\n            i = baseOut == 16 ? 4 : 3;\n            for (--len; len % i; len++) str += \"0\";\n            xd = convertBase(str, base, baseOut);\n            for (len = xd.length; !xd[len - 1]; --len) ;\n            for (i = 1, str = \"1.\"; i < len; i++) str += NUMERALS.charAt(xd[i]);\n          } else {\n            str = str.charAt(0) + \".\" + str.slice(1);\n          }\n        }\n        str = str + (e < 0 ? \"p\" : \"p+\") + e;\n      } else if (e < 0) {\n        for (; ++e; ) str = \"0\" + str;\n        str = \"0.\" + str;\n      } else {\n        if (++e > len) for (e -= len; e--; ) str += \"0\";\n        else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n      }\n    }\n    str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n  }\n  return x.s < 0 ? \"-\" + str : str;\n}\nfunction truncate(arr, len) {\n  if (arr.length > len) {\n    arr.length = len;\n    return true;\n  }\n}\nfunction abs(x) {\n  return new this(x).abs();\n}\nfunction acos(x) {\n  return new this(x).acos();\n}\nfunction acosh(x) {\n  return new this(x).acosh();\n}\nfunction add(x, y) {\n  return new this(x).plus(y);\n}\nfunction asin(x) {\n  return new this(x).asin();\n}\nfunction asinh(x) {\n  return new this(x).asinh();\n}\nfunction atan(x) {\n  return new this(x).atan();\n}\nfunction atanh(x) {\n  return new this(x).atanh();\n}\nfunction atan2(y, x) {\n  y = new this(y);\n  x = new this(x);\n  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n  if (!y.s || !x.s) {\n    r = new this(NaN);\n  } else if (!y.d && !x.d) {\n    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n    r.s = y.s;\n  } else if (!x.d || y.isZero()) {\n    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n    r.s = y.s;\n  } else if (!y.d || x.isZero()) {\n    r = getPi(this, wpr, 1).times(0.5);\n    r.s = y.s;\n  } else if (x.s < 0) {\n    this.precision = wpr;\n    this.rounding = 1;\n    r = this.atan(divide(y, x, wpr, 1));\n    x = getPi(this, wpr, 1);\n    this.precision = pr;\n    this.rounding = rm;\n    r = y.s < 0 ? r.minus(x) : r.plus(x);\n  } else {\n    r = this.atan(divide(y, x, wpr, 1));\n  }\n  return r;\n}\nfunction cbrt(x) {\n  return new this(x).cbrt();\n}\nfunction ceil(x) {\n  return finalise(x = new this(x), x.e + 1, 2);\n}\nfunction clamp(x, min2, max2) {\n  return new this(x).clamp(min2, max2);\n}\nfunction config(obj) {\n  if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n  var i, p, v, useDefaults = obj.defaults === true, ps = [\n    \"precision\",\n    1,\n    MAX_DIGITS,\n    \"rounding\",\n    0,\n    8,\n    \"toExpNeg\",\n    -EXP_LIMIT,\n    0,\n    \"toExpPos\",\n    0,\n    EXP_LIMIT,\n    \"maxE\",\n    0,\n    EXP_LIMIT,\n    \"minE\",\n    -EXP_LIMIT,\n    0,\n    \"modulo\",\n    0,\n    9\n  ];\n  for (i = 0; i < ps.length; i += 3) {\n    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n      else throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n  if ((v = obj[p]) !== void 0) {\n    if (v === true || v === false || v === 0 || v === 1) {\n      if (v) {\n        if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n          this[p] = true;\n        } else {\n          throw Error(cryptoUnavailable);\n        }\n      } else {\n        this[p] = false;\n      }\n    } else {\n      throw Error(invalidArgument + p + \": \" + v);\n    }\n  }\n  return this;\n}\nfunction cos(x) {\n  return new this(x).cos();\n}\nfunction cosh(x) {\n  return new this(x).cosh();\n}\nfunction clone(obj) {\n  var i, p, ps;\n  function Decimal2(v) {\n    var e, i2, t, x = this;\n    if (!(x instanceof Decimal2)) return new Decimal2(v);\n    x.constructor = Decimal2;\n    if (isDecimalInstance(v)) {\n      x.s = v.s;\n      if (external) {\n        if (!v.d || v.e > Decimal2.maxE) {\n          x.e = NaN;\n          x.d = null;\n        } else if (v.e < Decimal2.minE) {\n          x.e = 0;\n          x.d = [0];\n        } else {\n          x.e = v.e;\n          x.d = v.d.slice();\n        }\n      } else {\n        x.e = v.e;\n        x.d = v.d ? v.d.slice() : v.d;\n      }\n      return;\n    }\n    t = typeof v;\n    if (t === \"number\") {\n      if (v === 0) {\n        x.s = 1 / v < 0 ? -1 : 1;\n        x.e = 0;\n        x.d = [0];\n        return;\n      }\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      if (v === ~~v && v < 1e7) {\n        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;\n        if (external) {\n          if (e > Decimal2.maxE) {\n            x.e = NaN;\n            x.d = null;\n          } else if (e < Decimal2.minE) {\n            x.e = 0;\n            x.d = [0];\n          } else {\n            x.e = e;\n            x.d = [v];\n          }\n        } else {\n          x.e = e;\n          x.d = [v];\n        }\n        return;\n      }\n      if (v * 0 !== 0) {\n        if (!v) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return;\n      }\n      return parseDecimal(x, v.toString());\n    }\n    if (t === \"string\") {\n      if ((i2 = v.charCodeAt(0)) === 45) {\n        v = v.slice(1);\n        x.s = -1;\n      } else {\n        if (i2 === 43) v = v.slice(1);\n        x.s = 1;\n      }\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n    }\n    if (t === \"bigint\") {\n      if (v < 0) {\n        v = -v;\n        x.s = -1;\n      } else {\n        x.s = 1;\n      }\n      return parseDecimal(x, v.toString());\n    }\n    throw Error(invalidArgument + v);\n  }\n  Decimal2.prototype = P;\n  Decimal2.ROUND_UP = 0;\n  Decimal2.ROUND_DOWN = 1;\n  Decimal2.ROUND_CEIL = 2;\n  Decimal2.ROUND_FLOOR = 3;\n  Decimal2.ROUND_HALF_UP = 4;\n  Decimal2.ROUND_HALF_DOWN = 5;\n  Decimal2.ROUND_HALF_EVEN = 6;\n  Decimal2.ROUND_HALF_CEIL = 7;\n  Decimal2.ROUND_HALF_FLOOR = 8;\n  Decimal2.EUCLID = 9;\n  Decimal2.config = Decimal2.set = config;\n  Decimal2.clone = clone;\n  Decimal2.isDecimal = isDecimalInstance;\n  Decimal2.abs = abs;\n  Decimal2.acos = acos;\n  Decimal2.acosh = acosh;\n  Decimal2.add = add;\n  Decimal2.asin = asin;\n  Decimal2.asinh = asinh;\n  Decimal2.atan = atan;\n  Decimal2.atanh = atanh;\n  Decimal2.atan2 = atan2;\n  Decimal2.cbrt = cbrt;\n  Decimal2.ceil = ceil;\n  Decimal2.clamp = clamp;\n  Decimal2.cos = cos;\n  Decimal2.cosh = cosh;\n  Decimal2.div = div;\n  Decimal2.exp = exp;\n  Decimal2.floor = floor;\n  Decimal2.hypot = hypot;\n  Decimal2.ln = ln;\n  Decimal2.log = log;\n  Decimal2.log10 = log10;\n  Decimal2.log2 = log2;\n  Decimal2.max = max;\n  Decimal2.min = min;\n  Decimal2.mod = mod;\n  Decimal2.mul = mul;\n  Decimal2.pow = pow;\n  Decimal2.random = random;\n  Decimal2.round = round;\n  Decimal2.sign = sign;\n  Decimal2.sin = sin;\n  Decimal2.sinh = sinh;\n  Decimal2.sqrt = sqrt;\n  Decimal2.sub = sub;\n  Decimal2.sum = sum;\n  Decimal2.tan = tan;\n  Decimal2.tanh = tanh;\n  Decimal2.trunc = trunc;\n  if (obj === void 0) obj = {};\n  if (obj) {\n    if (obj.defaults !== true) {\n      ps = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"];\n      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n    }\n  }\n  Decimal2.config(obj);\n  return Decimal2;\n}\nfunction div(x, y) {\n  return new this(x).div(y);\n}\nfunction exp(x) {\n  return new this(x).exp();\n}\nfunction floor(x) {\n  return finalise(x = new this(x), x.e + 1, 3);\n}\nfunction hypot() {\n  var i, n, t = new this(0);\n  external = false;\n  for (i = 0; i < arguments.length; ) {\n    n = new this(arguments[i++]);\n    if (!n.d) {\n      if (n.s) {\n        external = true;\n        return new this(1 / 0);\n      }\n      t = n;\n    } else if (t.d) {\n      t = t.plus(n.times(n));\n    }\n  }\n  external = true;\n  return t.sqrt();\n}\nfunction isDecimalInstance(obj) {\n  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\nfunction ln(x) {\n  return new this(x).ln();\n}\nfunction log(x, y) {\n  return new this(x).log(y);\n}\nfunction log2(x) {\n  return new this(x).log(2);\n}\nfunction log10(x) {\n  return new this(x).log(10);\n}\nfunction max() {\n  return maxOrMin(this, arguments, -1);\n}\nfunction min() {\n  return maxOrMin(this, arguments, 1);\n}\nfunction mod(x, y) {\n  return new this(x).mod(y);\n}\nfunction mul(x, y) {\n  return new this(x).mul(y);\n}\nfunction pow(x, y) {\n  return new this(x).pow(y);\n}\nfunction random(sd) {\n  var d, e, k, n, i = 0, r = new this(1), rd = [];\n  if (sd === void 0) sd = this.precision;\n  else checkInt32(sd, 1, MAX_DIGITS);\n  k = Math.ceil(sd / LOG_BASE);\n  if (!this.crypto) {\n    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;\n  } else if (crypto.getRandomValues) {\n    d = crypto.getRandomValues(new Uint32Array(k));\n    for (; i < k; ) {\n      n = d[i];\n      if (n >= 429e7) {\n        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n      } else {\n        rd[i++] = n % 1e7;\n      }\n    }\n  } else if (crypto.randomBytes) {\n    d = crypto.randomBytes(k *= 4);\n    for (; i < k; ) {\n      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);\n      if (n >= 214e7) {\n        crypto.randomBytes(4).copy(d, i);\n      } else {\n        rd.push(n % 1e7);\n        i += 4;\n      }\n    }\n    i = k / 4;\n  } else {\n    throw Error(cryptoUnavailable);\n  }\n  k = rd[--i];\n  sd %= LOG_BASE;\n  if (k && sd) {\n    n = mathpow(10, LOG_BASE - sd);\n    rd[i] = (k / n | 0) * n;\n  }\n  for (; rd[i] === 0; i--) rd.pop();\n  if (i < 0) {\n    e = 0;\n    rd = [0];\n  } else {\n    e = -1;\n    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\n    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\n    if (k < LOG_BASE) e -= LOG_BASE - k;\n  }\n  r.e = e;\n  r.d = rd;\n  return r;\n}\nfunction round(x) {\n  return finalise(x = new this(x), x.e + 1, this.rounding);\n}\nfunction sign(x) {\n  x = new this(x);\n  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\nfunction sin(x) {\n  return new this(x).sin();\n}\nfunction sinh(x) {\n  return new this(x).sinh();\n}\nfunction sqrt(x) {\n  return new this(x).sqrt();\n}\nfunction sub(x, y) {\n  return new this(x).sub(y);\n}\nfunction sum() {\n  var i = 0, args = arguments, x = new this(args[i]);\n  external = false;\n  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);\n  external = true;\n  return finalise(x, this.precision, this.rounding);\n}\nfunction tan(x) {\n  return new this(x).tan();\n}\nfunction tanh(x) {\n  return new this(x).tanh();\n}\nfunction trunc(x) {\n  return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\nvar Decimal = P.constructor = clone(DEFAULTS);\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n\n// ../../node_modules/.pnpm/sql-template-tag@5.2.1/node_modules/sql-template-tag/dist/index.js\nvar Sql = class _Sql {\n  constructor(rawStrings, rawValues) {\n    if (rawStrings.length - 1 !== rawValues.length) {\n      if (rawStrings.length === 0) {\n        throw new TypeError(\"Expected at least 1 string\");\n      }\n      throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);\n    }\n    const valuesLength = rawValues.reduce((len, value) => len + (value instanceof _Sql ? value.values.length : 1), 0);\n    this.values = new Array(valuesLength);\n    this.strings = new Array(valuesLength + 1);\n    this.strings[0] = rawStrings[0];\n    let i = 0, pos = 0;\n    while (i < rawValues.length) {\n      const child = rawValues[i++];\n      const rawString = rawStrings[i];\n      if (child instanceof _Sql) {\n        this.strings[pos] += child.strings[0];\n        let childIndex = 0;\n        while (childIndex < child.values.length) {\n          this.values[pos++] = child.values[childIndex++];\n          this.strings[pos] = child.strings[childIndex];\n        }\n        this.strings[pos] += rawString;\n      } else {\n        this.values[pos++] = child;\n        this.strings[pos] = rawString;\n      }\n    }\n  }\n  get sql() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `?${this.strings[i++]}`;\n    return value;\n  }\n  get statement() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `:${i}${this.strings[i++]}`;\n    return value;\n  }\n  get text() {\n    const len = this.strings.length;\n    let i = 1;\n    let value = this.strings[0];\n    while (i < len)\n      value += `$${i}${this.strings[i++]}`;\n    return value;\n  }\n  inspect() {\n    return {\n      sql: this.sql,\n      statement: this.statement,\n      text: this.text,\n      values: this.values\n    };\n  }\n};\nfunction join(values, separator = \",\", prefix = \"\", suffix = \"\") {\n  if (values.length === 0) {\n    throw new TypeError(\"Expected `join([])` to be called with an array of multiple elements, but got an empty array\");\n  }\n  return new Sql([prefix, ...Array(values.length - 1).fill(separator), suffix], values);\n}\nfunction raw(value) {\n  return new Sql([value], []);\n}\nvar empty = raw(\"\");\nfunction sql(strings, ...values) {\n  return new Sql(strings, values);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n/*! Bundled license information:\n\ndecimal.js/decimal.mjs:\n  (*!\n   *  decimal.js v10.5.0\n   *  An arbitrary-precision Decimal type for JavaScript.\n   *  https://github.com/MikeMcl/decimal.js\n   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\n   *  MIT Licence\n   *)\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHByaXNtYStjbGllbnQtcnVudGltZS11dGlsc0A3LjEuMC9ub2RlX21vZHVsZXMvQHByaXNtYS9jbGllbnQtcnVudGltZS11dGlscy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLGFBQWE7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLGNBQWM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQiw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4Qyx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUMsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELG9DQUFvQyxTQUFTO0FBQzdDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLEtBQUs7QUFDcEI7QUFDQSxRQUFRO0FBQ1Isc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsSUFBSTtBQUNKO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxXQUFXLGFBQWE7QUFDeEIsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFtQixrQkFBa0IsdUJBQXVCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsRUFBRSxrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRSxFQUFFLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0F5Qkw7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hc2xhay9yZXBvcy9wbGFuLWVhdC1yZXBlYXQvbm9kZV9tb2R1bGVzLy5wbnBtL0BwcmlzbWErY2xpZW50LXJ1bnRpbWUtdXRpbHNANy4xLjAvbm9kZV9tb2R1bGVzL0BwcmlzbWEvY2xpZW50LXJ1bnRpbWUtdXRpbHMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QyKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QyKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBBbnlOdWxsOiAoKSA9PiBBbnlOdWxsLFxuICBBbnlOdWxsQ2xhc3M6ICgpID0+IEFueU51bGxDbGFzcyxcbiAgRGJOdWxsOiAoKSA9PiBEYk51bGwsXG4gIERiTnVsbENsYXNzOiAoKSA9PiBEYk51bGxDbGFzcyxcbiAgRGVjaW1hbDogKCkgPT4gRGVjaW1hbCxcbiAgSnNvbk51bGw6ICgpID0+IEpzb25OdWxsLFxuICBKc29uTnVsbENsYXNzOiAoKSA9PiBKc29uTnVsbENsYXNzLFxuICBOdWxsVHlwZXM6ICgpID0+IE51bGxUeXBlcyxcbiAgT2JqZWN0RW51bVZhbHVlOiAoKSA9PiBPYmplY3RFbnVtVmFsdWUsXG4gIFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3I6ICgpID0+IFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IsXG4gIFByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdEVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRSdXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvcixcbiAgUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcjogKCkgPT4gUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcixcbiAgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yOiAoKSA9PiBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IsXG4gIFNxbDogKCkgPT4gU3FsLFxuICBlbXB0eTogKCkgPT4gZW1wdHksXG4gIGhhc0JhdGNoSW5kZXg6ICgpID0+IGhhc0JhdGNoSW5kZXgsXG4gIGlzQW55TnVsbDogKCkgPT4gaXNBbnlOdWxsLFxuICBpc0RiTnVsbDogKCkgPT4gaXNEYk51bGwsXG4gIGlzSnNvbk51bGw6ICgpID0+IGlzSnNvbk51bGwsXG4gIGpvaW46ICgpID0+IGpvaW4sXG4gIHJhdzogKCkgPT4gcmF3LFxuICBzcWw6ICgpID0+IHNxbFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcblxuLy8gc3JjL2Vycm9ycy9FcnJvcldpdGhCYXRjaEluZGV4LnRzXG5mdW5jdGlvbiBoYXNCYXRjaEluZGV4KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWVbXCJiYXRjaFJlcXVlc3RJZHhcIl0gPT09IFwibnVtYmVyXCI7XG59XG5cbi8vIHNyYy9lcnJvcnMvc2V0Q2xhc3NOYW1lLnRzXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUoY2xhc3NPYmplY3QsIG5hbWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzT2JqZWN0LCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBuYW1lLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gc3JjL2Vycm9ycy9QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvciA9IGNsYXNzIF9QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjbGllbnRWZXJzaW9uO1xuICBlcnJvckNvZGU7XG4gIHJldHJ5YWJsZTtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2xpZW50VmVyc2lvbiwgZXJyb3JDb2RlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yXCI7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjtcbiAgICB0aGlzLmVycm9yQ29kZSA9IGVycm9yQ29kZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcik7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIjtcbiAgfVxufTtcbnNldENsYXNzTmFtZShQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLCBcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIik7XG5cbi8vIHNyYy9lcnJvcnMvUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlO1xuICBtZXRhO1xuICBjbGllbnRWZXJzaW9uO1xuICBiYXRjaFJlcXVlc3RJZHg7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHsgY29kZSwgY2xpZW50VmVyc2lvbiwgbWV0YSwgYmF0Y2hSZXF1ZXN0SWR4IH0pIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yXCI7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hSZXF1ZXN0SWR4XCIsIHtcbiAgICAgIHZhbHVlOiBiYXRjaFJlcXVlc3RJZHgsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yXCI7XG4gIH1cbn07XG5zZXRDbGFzc05hbWUoUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIik7XG5cbi8vIHNyYy9lcnJvcnMvbG9nLnRzXG5mdW5jdGlvbiBnZXRCYWNrdHJhY2UobG9nMykge1xuICBpZiAobG9nMy5maWVsZHM/Lm1lc3NhZ2UpIHtcbiAgICBsZXQgc3RyID0gbG9nMy5maWVsZHM/Lm1lc3NhZ2U7XG4gICAgaWYgKGxvZzMuZmllbGRzPy5maWxlKSB7XG4gICAgICBzdHIgKz0gYCBpbiAke2xvZzMuZmllbGRzLmZpbGV9YDtcbiAgICAgIGlmIChsb2czLmZpZWxkcz8ubGluZSkge1xuICAgICAgICBzdHIgKz0gYDoke2xvZzMuZmllbGRzLmxpbmV9YDtcbiAgICAgIH1cbiAgICAgIGlmIChsb2czLmZpZWxkcz8uY29sdW1uKSB7XG4gICAgICAgIHN0ciArPSBgOiR7bG9nMy5maWVsZHMuY29sdW1ufWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsb2czLmZpZWxkcz8ucmVhc29uKSB7XG4gICAgICBzdHIgKz0gYFxuJHtsb2czLmZpZWxkcz8ucmVhc29ufWA7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIFwiVW5rbm93biBlcnJvclwiO1xufVxuZnVuY3Rpb24gaXNQYW5pYyhlcnIpIHtcbiAgcmV0dXJuIGVyci5maWVsZHM/Lm1lc3NhZ2UgPT09IFwiUEFOSUNcIjtcbn1cblxuLy8gc3JjL2Vycm9ycy9QcmlzbWFDbGllbnRSdXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRSdXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY2xpZW50VmVyc2lvbjtcbiAgX2lzUGFuaWM7XG4gIGNvbnN0cnVjdG9yKHsgY2xpZW50VmVyc2lvbiwgZXJyb3IgfSkge1xuICAgIGNvbnN0IGJhY2t0cmFjZSA9IGdldEJhY2t0cmFjZShlcnJvcik7XG4gICAgc3VwZXIoYmFja3RyYWNlID8/IFwiVW5rbm93biBlcnJvclwiKTtcbiAgICB0aGlzLl9pc1BhbmljID0gaXNQYW5pYyhlcnJvcik7XG4gICAgdGhpcy5jbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbjtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIFwiUHJpc21hQ2xpZW50UnVzdEVycm9yXCI7XG4gIH1cbiAgaXNQYW5pYygpIHtcbiAgICByZXR1cm4gdGhpcy5faXNQYW5pYztcbiAgfVxufTtcbnNldENsYXNzTmFtZShQcmlzbWFDbGllbnRSdXN0RXJyb3IsIFwiUHJpc21hQ2xpZW50UnVzdEVycm9yXCIpO1xuXG4vLyBzcmMvZXJyb3JzL1ByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY2xpZW50VmVyc2lvbjtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2xpZW50VmVyc2lvbikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIjtcbiAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjbGllbnRWZXJzaW9uO1xuICB9XG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gXCJQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvclwiO1xuICB9XG59O1xuc2V0Q2xhc3NOYW1lKFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yLCBcIlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXCIpO1xuXG4vLyBzcmMvZXJyb3JzL1ByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IudHNcbnZhciBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNsaWVudFZlcnNpb247XG4gIGJhdGNoUmVxdWVzdElkeDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgeyBjbGllbnRWZXJzaW9uLCBiYXRjaFJlcXVlc3RJZHggfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvclwiO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb247XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hSZXF1ZXN0SWR4XCIsIHtcbiAgICAgIHZhbHVlOiBiYXRjaFJlcXVlc3RJZHgsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIjtcbiAgfVxufTtcbnNldENsYXNzTmFtZShQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLCBcIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIik7XG5cbi8vIHNyYy9lcnJvcnMvUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLnRzXG52YXIgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIG5hbWUgPSBcIlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclwiO1xuICBjbGllbnRWZXJzaW9uO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGNsaWVudFZlcnNpb24gfSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNsaWVudFZlcnNpb247XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclwiO1xuICB9XG59O1xuc2V0Q2xhc3NOYW1lKFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvciwgXCJQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3JcIik7XG5cbi8vIHNyYy9udWxsVHlwZXMudHNcbnZhciBzZWNyZXQgPSBTeW1ib2woKTtcbnZhciByZXByZXNlbnRhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBPYmplY3RFbnVtVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGFyZykge1xuICAgIGlmIChhcmcgPT09IHNlY3JldCkge1xuICAgICAgcmVwcmVzZW50YXRpb25zLnNldCh0aGlzLCBgUHJpc21hLiR7dGhpcy5fZ2V0TmFtZSgpfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXByZXNlbnRhdGlvbnMuc2V0KHRoaXMsIGBuZXcgUHJpc21hLiR7dGhpcy5fZ2V0TmFtZXNwYWNlKCl9LiR7dGhpcy5fZ2V0TmFtZSgpfSgpYCk7XG4gICAgfVxuICB9XG4gIF9nZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHJlcHJlc2VudGF0aW9ucy5nZXQodGhpcyk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZXRDbGFzc05hbWUyKGNsYXNzT2JqZWN0LCBuYW1lKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc09iamVjdCwgXCJuYW1lXCIsIHtcbiAgICB2YWx1ZTogbmFtZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG52YXIgTnVsbFR5cGVzRW51bVZhbHVlID0gY2xhc3MgZXh0ZW5kcyBPYmplY3RFbnVtVmFsdWUge1xuICBfZ2V0TmFtZXNwYWNlKCkge1xuICAgIHJldHVybiBcIk51bGxUeXBlc1wiO1xuICB9XG59O1xudmFyIERiTnVsbENsYXNzID0gY2xhc3MgZXh0ZW5kcyBOdWxsVHlwZXNFbnVtVmFsdWUge1xuICAvLyBQaGFudG9tIHByaXZhdGUgcHJvcGVydHkgdG8gcHJldmVudCBzdHJ1Y3R1cmFsIHR5cGUgZXF1YWxpdHlcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1wcml2YXRlLWNsYXNzLW1lbWJlcnNcbiAgI19icmFuZF9EYk51bGw7XG59O1xuc2V0Q2xhc3NOYW1lMihEYk51bGxDbGFzcywgXCJEYk51bGxcIik7XG52YXIgSnNvbk51bGxDbGFzcyA9IGNsYXNzIGV4dGVuZHMgTnVsbFR5cGVzRW51bVZhbHVlIHtcbiAgLy8gUGhhbnRvbSBwcml2YXRlIHByb3BlcnR5IHRvIHByZXZlbnQgc3RydWN0dXJhbCB0eXBlIGVxdWFsaXR5XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtcHJpdmF0ZS1jbGFzcy1tZW1iZXJzXG4gICNfYnJhbmRfSnNvbk51bGw7XG59O1xuc2V0Q2xhc3NOYW1lMihKc29uTnVsbENsYXNzLCBcIkpzb25OdWxsXCIpO1xudmFyIEFueU51bGxDbGFzcyA9IGNsYXNzIGV4dGVuZHMgTnVsbFR5cGVzRW51bVZhbHVlIHtcbiAgLy8gUGhhbnRvbSBwcml2YXRlIHByb3BlcnR5IHRvIHByZXZlbnQgc3RydWN0dXJhbCB0eXBlIGVxdWFsaXR5XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtcHJpdmF0ZS1jbGFzcy1tZW1iZXJzXG4gICNfYnJhbmRfQW55TnVsbDtcbn07XG5zZXRDbGFzc05hbWUyKEFueU51bGxDbGFzcywgXCJBbnlOdWxsXCIpO1xudmFyIE51bGxUeXBlcyA9IHtcbiAgRGJOdWxsOiBEYk51bGxDbGFzcyxcbiAgSnNvbk51bGw6IEpzb25OdWxsQ2xhc3MsXG4gIEFueU51bGw6IEFueU51bGxDbGFzc1xufTtcbnZhciBEYk51bGwgPSBuZXcgRGJOdWxsQ2xhc3Moc2VjcmV0KTtcbnZhciBKc29uTnVsbCA9IG5ldyBKc29uTnVsbENsYXNzKHNlY3JldCk7XG52YXIgQW55TnVsbCA9IG5ldyBBbnlOdWxsQ2xhc3Moc2VjcmV0KTtcbmZ1bmN0aW9uIGlzRGJOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gRGJOdWxsO1xufVxuZnVuY3Rpb24gaXNKc29uTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IEpzb25OdWxsO1xufVxuZnVuY3Rpb24gaXNBbnlOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gQW55TnVsbDtcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RlY2ltYWwuanNAMTAuNS4wL25vZGVfbW9kdWxlcy9kZWNpbWFsLmpzL2RlY2ltYWwubWpzXG52YXIgRVhQX0xJTUlUID0gOWUxNTtcbnZhciBNQVhfRElHSVRTID0gMWU5O1xudmFyIE5VTUVSQUxTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG52YXIgTE4xMCA9IFwiMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4XCI7XG52YXIgUEkgPSBcIjMuMTQxNTkyNjUzNTg5NzkzMjM4NDYyNjQzMzgzMjc5NTAyODg0MTk3MTY5Mzk5Mzc1MTA1ODIwOTc0OTQ0NTkyMzA3ODE2NDA2Mjg2MjA4OTk4NjI4MDM0ODI1MzQyMTE3MDY3OTgyMTQ4MDg2NTEzMjgyMzA2NjQ3MDkzODQ0NjA5NTUwNTgyMjMxNzI1MzU5NDA4MTI4NDgxMTE3NDUwMjg0MTAyNzAxOTM4NTIxMTA1NTU5NjQ0NjIyOTQ4OTU0OTMwMzgxOTY0NDI4ODEwOTc1NjY1OTMzNDQ2MTI4NDc1NjQ4MjMzNzg2NzgzMTY1MjcxMjAxOTA5MTQ1NjQ4NTY2OTIzNDYwMzQ4NjEwNDU0MzI2NjQ4MjEzMzkzNjA3MjYwMjQ5MTQxMjczNzI0NTg3MDA2NjA2MzE1NTg4MTc0ODgxNTIwOTIwOTYyODI5MjU0MDkxNzE1MzY0MzY3ODkyNTkwMzYwMDExMzMwNTMwNTQ4ODIwNDY2NTIxMzg0MTQ2OTUxOTQxNTExNjA5NDMzMDU3MjcwMzY1NzU5NTkxOTUzMDkyMTg2MTE3MzgxOTMyNjExNzkzMTA1MTE4NTQ4MDc0NDYyMzc5OTYyNzQ5NTY3MzUxODg1NzUyNzI0ODkxMjI3OTM4MTgzMDExOTQ5MTI5ODMzNjczMzYyNDQwNjU2NjQzMDg2MDIxMzk0OTQ2Mzk1MjI0NzM3MTkwNzAyMTc5ODYwOTQzNzAyNzcwNTM5MjE3MTc2MjkzMTc2NzUyMzg0Njc0ODE4NDY3NjY5NDA1MTMyMDAwNTY4MTI3MTQ1MjYzNTYwODI3Nzg1NzcxMzQyNzU3Nzg5NjA5MTczNjM3MTc4NzIxNDY4NDQwOTAxMjI0OTUzNDMwMTQ2NTQ5NTg1MzcxMDUwNzkyMjc5Njg5MjU4OTIzNTQyMDE5OTU2MTEyMTI5MDIxOTYwODY0MDM0NDE4MTU5ODEzNjI5Nzc0NzcxMzA5OTYwNTE4NzA3MjExMzQ5OTk5OTk4MzcyOTc4MDQ5OTUxMDU5NzMxNzMyODE2MDk2MzE4NTk1MDI0NDU5NDU1MzQ2OTA4MzAyNjQyNTIyMzA4MjUzMzQ0Njg1MDM1MjYxOTMxMTg4MTcxMDEwMDAzMTM3ODM4NzUyODg2NTg3NTMzMjA4MzgxNDIwNjE3MTc3NjY5MTQ3MzAzNTk4MjUzNDkwNDI4NzU1NDY4NzMxMTU5NTYyODYzODgyMzUzNzg3NTkzNzUxOTU3NzgxODU3NzgwNTMyMTcxMjI2ODA2NjEzMDAxOTI3ODc2NjExMTk1OTA5MjE2NDIwMTk4OTM4MDk1MjU3MjAxMDY1NDg1ODYzMjc4OVwiO1xudmFyIERFRkFVTFRTID0ge1xuICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXG4gIC8vIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIHRoZSBgRGVjaW1hbC5jb25maWdgIG1ldGhvZC5cbiAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIGEgY2FsY3VsYXRpb24gb3IgYmFzZSBjb252ZXJzaW9uLlxuICAvLyBFLmcuIGBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAgfSk7YFxuICBwcmVjaXNpb246IDIwLFxuICAvLyAxIHRvIE1BWF9ESUdJVFNcbiAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIGBwcmVjaXNpb25gLlxuICAvL1xuICAvLyBST1VORF9VUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXG4gIC8vIFJPVU5EX0RPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXG4gIC8vIFJPVU5EX0NFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cbiAgLy8gUk9VTkRfRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxuICAvLyBST1VORF9IQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxuICAvLyBST1VORF9IQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXG4gIC8vIFJPVU5EX0hBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cbiAgLy8gUk9VTkRfSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cbiAgLy8gUk9VTkRfSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cbiAgLy9cbiAgLy8gRS5nLlxuICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IDQ7YFxuICAvLyBgRGVjaW1hbC5yb3VuZGluZyA9IERlY2ltYWwuUk9VTkRfSEFMRl9VUDtgXG4gIHJvdW5kaW5nOiA0LFxuICAvLyAwIHRvIDhcbiAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cbiAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXG4gIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXG4gIC8vXG4gIC8vIFVQICAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cbiAgLy8gRE9XTiAgICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kIChKYXZhU2NyaXB0ICUpLlxuICAvLyBGTE9PUiAgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxuICAvLyBIQUxGX0VWRU4gIDYgVGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cbiAgLy8gRVVDTElEICAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS4gQWx3YXlzIHBvc2l0aXZlLlxuICAvL1xuICAvLyBUcnVuY2F0ZWQgZGl2aXNpb24gKDEpLCBmbG9vcmVkIGRpdmlzaW9uICgzKSwgdGhlIElFRUUgNzU0IHJlbWFpbmRlciAoNiksIGFuZCBFdWNsaWRpYW5cbiAgLy8gZGl2aXNpb24gKDkpIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uIFRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzb1xuICAvLyBiZSB1c2VkLCBidXQgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXG4gIG1vZHVsbzogMSxcbiAgLy8gMCB0byA5XG4gIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gIC8vIEphdmFTY3JpcHQgbnVtYmVyczogLTdcbiAgdG9FeHBOZWc6IC03LFxuICAvLyAwIHRvIC1FWFBfTElNSVRcbiAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXG4gIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMjFcbiAgdG9FeHBQb3M6IDIxLFxuICAvLyAwIHRvIEVYUF9MSU1JVFxuICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXG4gIC8vIEphdmFTY3JpcHQgbnVtYmVyczogLTMyNCAgKDVlLTMyNClcbiAgbWluRTogLUVYUF9MSU1JVCxcbiAgLy8gLTEgdG8gLUVYUF9MSU1JVFxuICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxuICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxuICBtYXhFOiBFWFBfTElNSVQsXG4gIC8vIDEgdG8gRVhQX0xJTUlUXG4gIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cbiAgY3J5cHRvOiBmYWxzZVxuICAvLyB0cnVlL2ZhbHNlXG59O1xudmFyIGluZXhhY3Q7XG52YXIgcXVhZHJhbnQ7XG52YXIgZXh0ZXJuYWwgPSB0cnVlO1xudmFyIGRlY2ltYWxFcnJvciA9IFwiW0RlY2ltYWxFcnJvcl0gXCI7XG52YXIgaW52YWxpZEFyZ3VtZW50ID0gZGVjaW1hbEVycm9yICsgXCJJbnZhbGlkIGFyZ3VtZW50OiBcIjtcbnZhciBwcmVjaXNpb25MaW1pdEV4Y2VlZGVkID0gZGVjaW1hbEVycm9yICsgXCJQcmVjaXNpb24gbGltaXQgZXhjZWVkZWRcIjtcbnZhciBjcnlwdG9VbmF2YWlsYWJsZSA9IGRlY2ltYWxFcnJvciArIFwiY3J5cHRvIHVuYXZhaWxhYmxlXCI7XG52YXIgdGFnID0gXCJbb2JqZWN0IERlY2ltYWxdXCI7XG52YXIgbWF0aGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBtYXRocG93ID0gTWF0aC5wb3c7XG52YXIgaXNCaW5hcnkgPSAvXjBiKFswMV0rKFxcLlswMV0qKT98XFwuWzAxXSspKHBbKy1dP1xcZCspPyQvaTtcbnZhciBpc0hleCA9IC9eMHgoWzAtOWEtZl0rKFxcLlswLTlhLWZdKik/fFxcLlswLTlhLWZdKykocFsrLV0/XFxkKyk/JC9pO1xudmFyIGlzT2N0YWwgPSAvXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaTtcbnZhciBpc0RlY2ltYWwgPSAvXihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2k7XG52YXIgQkFTRSA9IDFlNztcbnZhciBMT0dfQkFTRSA9IDc7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG52YXIgTE4xMF9QUkVDSVNJT04gPSBMTjEwLmxlbmd0aCAtIDE7XG52YXIgUElfUFJFQ0lTSU9OID0gUEkubGVuZ3RoIC0gMTtcbnZhciBQID0geyB0b1N0cmluZ1RhZzogdGFnIH07XG5QLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xuICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xufTtcblAuY2VpbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDIpO1xufTtcblAuY2xhbXBlZFRvID0gUC5jbGFtcCA9IGZ1bmN0aW9uKG1pbjIsIG1heDIpIHtcbiAgdmFyIGssIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgbWluMiA9IG5ldyBDdG9yKG1pbjIpO1xuICBtYXgyID0gbmV3IEN0b3IobWF4Mik7XG4gIGlmICghbWluMi5zIHx8ICFtYXgyLnMpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAobWluMi5ndChtYXgyKSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbWF4Mik7XG4gIGsgPSB4LmNtcChtaW4yKTtcbiAgcmV0dXJuIGsgPCAwID8gbWluMiA6IHguY21wKG1heDIpID4gMCA/IG1heDIgOiBuZXcgQ3Rvcih4KTtcbn07XG5QLmNvbXBhcmVkVG8gPSBQLmNtcCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGksIGosIHhkTCwgeWRMLCB4ID0gdGhpcywgeGQgPSB4LmQsIHlkID0gKHkgPSBuZXcgeC5jb25zdHJ1Y3Rvcih5KSkuZCwgeHMgPSB4LnMsIHlzID0geS5zO1xuICBpZiAoIXhkIHx8ICF5ZCkge1xuICAgIHJldHVybiAheHMgfHwgIXlzID8gTmFOIDogeHMgIT09IHlzID8geHMgOiB4ZCA9PT0geWQgPyAwIDogIXhkIF4geHMgPCAwID8gMSA6IC0xO1xuICB9XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcbiAgaWYgKHhzICE9PSB5cykgcmV0dXJuIHhzO1xuICBpZiAoeC5lICE9PSB5LmUpIHJldHVybiB4LmUgPiB5LmUgXiB4cyA8IDAgPyAxIDogLTE7XG4gIHhkTCA9IHhkLmxlbmd0aDtcbiAgeWRMID0geWQubGVuZ3RoO1xuICBmb3IgKGkgPSAwLCBqID0geGRMIDwgeWRMID8geGRMIDogeWRMOyBpIDwgajsgKytpKSB7XG4gICAgaWYgKHhkW2ldICE9PSB5ZFtpXSkgcmV0dXJuIHhkW2ldID4geWRbaV0gXiB4cyA8IDAgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIHhkTCA9PT0geWRMID8gMCA6IHhkTCA+IHlkTCBeIHhzIDwgMCA/IDEgOiAtMTtcbn07XG5QLmNvc2luZSA9IFAuY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmQpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoIXguZFswXSkgcmV0dXJuIG5ldyBDdG9yKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyBMT0dfQkFTRTtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gMyA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAuY3ViZVJvb3QgPSBQLmNicnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGUsIG0sIG4sIHIsIHJlcCwgcywgc2QsIHQsIHQzLCB0M3BsdXN4LCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgcyA9IHgucyAqIG1hdGhwb3coeC5zICogeCwgMSAvIDMpO1xuICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcbiAgICBuID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcbiAgICBlID0geC5lO1xuICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMykgbiArPSBzID09IDEgfHwgcyA9PSAtMiA/IFwiMFwiIDogXCIwMFwiO1xuICAgIHMgPSBtYXRocG93KG4sIDEgLyAzKTtcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgICByLnMgPSB4LnM7XG4gIH0gZWxzZSB7XG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XG4gIH1cbiAgc2QgPSAoZSA9IEN0b3IucHJlY2lzaW9uKSArIDM7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSByO1xuICAgIHQzID0gdC50aW1lcyh0KS50aW1lcyh0KTtcbiAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcbiAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHcsIGQgPSB0aGlzLmQsIG4gPSBOYU47XG4gIGlmIChkKSB7XG4gICAgdyA9IGQubGVuZ3RoIC0gMTtcbiAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xuICAgIHcgPSBkW3ddO1xuICAgIGlmICh3KSBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApIG4tLTtcbiAgICBpZiAobiA8IDApIG4gPSAwO1xuICB9XG4gIHJldHVybiBuO1xufTtcblAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xufTtcblAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcbn07XG5QLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcbn07XG5QLmZsb29yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XG59O1xuUC5ncmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XG59O1xuUC5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24oeSkge1xuICB2YXIgayA9IHRoaXMuY21wKHkpO1xuICByZXR1cm4gayA9PSAxIHx8IGsgPT09IDA7XG59O1xuUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrLCBuLCBwciwgcm0sIGxlbiwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBvbmUgPSBuZXcgQ3RvcigxKTtcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMgPyAxIC8gMCA6IE5hTik7XG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gb25lO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgbGVuID0geC5kLmxlbmd0aDtcbiAgaWYgKGxlbiA8IDMyKSB7XG4gICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcbiAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGsgPSAxNjtcbiAgICBuID0gXCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCI7XG4gIH1cbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKG4pLCBuZXcgQ3RvcigxKSwgdHJ1ZSk7XG4gIHZhciBjb3NoMl94LCBpID0gaywgZDggPSBuZXcgQ3Rvcig4KTtcbiAgZm9yICg7IGktLTsgKSB7XG4gICAgY29zaDJfeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xuICB9XG4gIHJldHVybiBmaW5hbGlzZSh4LCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xufTtcblAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGssIHByLCBybSwgbGVuLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzKSB7XG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XG4gICAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gICAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCwgdHJ1ZSk7XG4gICAgdmFyIHNpbmgyX3gsIGQ1ID0gbmV3IEN0b3IoNSksIGQxNiA9IG5ldyBDdG9yKDE2KSwgZDIwID0gbmV3IEN0b3IoMjApO1xuICAgIGZvciAoOyBrLS07ICkge1xuICAgICAgc2luaDJfeCA9IHgudGltZXMoeCk7XG4gICAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbmgyX3gudGltZXMoZDE2LnRpbWVzKHNpbmgyX3gpLnBsdXMoZDIwKSkpKTtcbiAgICB9XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcbn07XG5QLmh5cGVyYm9saWNUYW5nZW50ID0gUC50YW5oID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMpO1xuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyA3O1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgcmV0dXJuIGRpdmlkZSh4LnNpbmgoKSwgeC5jb3NoKCksIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSk7XG59O1xuUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIGsgPSB4LmFicygpLmNtcCgxKSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoayAhPT0gLTEpIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IHguaXNOZWcoKSA/IGdldFBpKEN0b3IsIHByLCBybSkgOiBuZXcgQ3RvcigwKSA6IG5ldyBDdG9yKE5hTik7XG4gIH1cbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSBuZXcgQ3RvcigxKS5taW51cyh4KS5kaXYoeC5wbHVzKDEpKS5zcXJ0KCkuYXRhbigpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LnRpbWVzKDIpO1xufTtcblAuaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgPSBQLmFjb3NoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHgubHRlKDEpKSByZXR1cm4gbmV3IEN0b3IoeC5lcSgxKSA/IDAgOiBOYU4pO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIHgubG4oKTtcbn07XG5QLmludmVyc2VIeXBlcmJvbGljU2luZSA9IFAuYXNpbmggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSB8fCB4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDIgKiBNYXRoLm1heChNYXRoLmFicyh4LmUpLCB4LnNkKCkpICsgNjtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIHggPSB4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoeCk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xuICByZXR1cm4geC5sbigpO1xufTtcblAuaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ID0gUC5hdGFuaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcHIsIHJtLCB3cHIsIHhzZCwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmUgPj0gMCkgcmV0dXJuIG5ldyBDdG9yKHguYWJzKCkuZXEoMSkgPyB4LnMgLyAwIDogeC5pc1plcm8oKSA/IHggOiBOYU4pO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIHhzZCA9IHguc2QoKTtcbiAgaWYgKE1hdGgubWF4KHhzZCwgcHIpIDwgMiAqIC14LmUgLSAxKSByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHByLCBybSwgdHJ1ZSk7XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0geHNkIC0geC5lO1xuICB4ID0gZGl2aWRlKHgucGx1cygxKSwgbmV3IEN0b3IoMSkubWludXMoeCksIHdwciArIHByLCAxKTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDQ7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICB4ID0geC5sbigpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LnRpbWVzKDAuNSk7XG59O1xuUC5pbnZlcnNlU2luZSA9IFAuYXNpbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaGFsZlBpLCBrLCBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcbiAgayA9IHguYWJzKCkuY21wKDEpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmIChrICE9PSAtMSkge1xuICAgIGlmIChrID09PSAwKSB7XG4gICAgICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgaGFsZlBpLnMgPSB4LnM7XG4gICAgICByZXR1cm4gaGFsZlBpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEN0b3IoTmFOKTtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LmRpdihuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpO1xuICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiB4LnRpbWVzKDIpO1xufTtcblAuaW52ZXJzZVRhbmdlbnQgPSBQLmF0YW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGksIGosIGssIG4sIHB4LCB0LCByLCB3cHIsIHgyLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHByID0gQ3Rvci5wcmVjaXNpb24sIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcbiAgICBpZiAoIXgucykgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgaWYgKHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcbiAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xuICAgICAgci5zID0geC5zO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHguaXNaZXJvKCkpIHtcbiAgICByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIH0gZWxzZSBpZiAoeC5hYnMoKS5lcSgxKSAmJiBwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XG4gICAgciA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuMjUpO1xuICAgIHIucyA9IHgucztcbiAgICByZXR1cm4gcjtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHdwciA9IHByICsgMTA7XG4gIEN0b3Iucm91bmRpbmcgPSAxO1xuICBrID0gTWF0aC5taW4oMjgsIHdwciAvIExPR19CQVNFICsgMiB8IDApO1xuICBmb3IgKGkgPSBrOyBpOyAtLWkpIHggPSB4LmRpdih4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoMSkpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBqID0gTWF0aC5jZWlsKHdwciAvIExPR19CQVNFKTtcbiAgbiA9IDE7XG4gIHgyID0geC50aW1lcyh4KTtcbiAgciA9IG5ldyBDdG9yKHgpO1xuICBweCA9IHg7XG4gIGZvciAoOyBpICE9PSAtMTsgKSB7XG4gICAgcHggPSBweC50aW1lcyh4Mik7XG4gICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xuICAgIHB4ID0gcHgudGltZXMoeDIpO1xuICAgIHIgPSB0LnBsdXMocHguZGl2KG4gKz0gMikpO1xuICAgIGlmIChyLmRbal0gIT09IHZvaWQgMCkgZm9yIChpID0gajsgci5kW2ldID09PSB0LmRbaV0gJiYgaS0tOyApIDtcbiAgfVxuICBpZiAoaykgciA9IHIudGltZXMoMiA8PCBrIC0gMSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XG59O1xuUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISF0aGlzLmQ7XG59O1xuUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XG59O1xuUC5pc05hTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucztcbn07XG5QLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnMgPCAwO1xufTtcblAuaXNQb3NpdGl2ZSA9IFAuaXNQb3MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucyA+IDA7XG59O1xuUC5pc1plcm8gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcbn07XG5QLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uKHkpIHtcbiAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcbn07XG5QLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbih5KSB7XG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XG59O1xuUC5sb2dhcml0aG0gPSBQLmxvZyA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLCBhcmcgPSB0aGlzLCBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLCBwciA9IEN0b3IucHJlY2lzaW9uLCBybSA9IEN0b3Iucm91bmRpbmcsIGd1YXJkID0gNTtcbiAgaWYgKGJhc2UgPT0gbnVsbCkge1xuICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XG4gICAgaXNCYXNlMTAgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcbiAgICBkID0gYmFzZS5kO1xuICAgIGlmIChiYXNlLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGJhc2UuZXEoMSkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICAgIGlzQmFzZTEwID0gYmFzZS5lcSgxMCk7XG4gIH1cbiAgZCA9IGFyZy5kO1xuICBpZiAoYXJnLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGFyZy5lcSgxKSkge1xuICAgIHJldHVybiBuZXcgQ3RvcihkICYmICFkWzBdID8gLTEgLyAwIDogYXJnLnMgIT0gMSA/IE5hTiA6IGQgPyAwIDogMSAvIDApO1xuICB9XG4gIGlmIChpc0Jhc2UxMCkge1xuICAgIGlmIChkLmxlbmd0aCA+IDEpIHtcbiAgICAgIGluZiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoayA9IGRbMF07IGsgJSAxMCA9PT0gMDsgKSBrIC89IDEwO1xuICAgICAgaW5mID0gayAhPT0gMTtcbiAgICB9XG4gIH1cbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgc2QgPSBwciArIGd1YXJkO1xuICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xuICBkZW5vbWluYXRvciA9IGlzQmFzZTEwID8gZ2V0TG4xMChDdG9yLCBzZCArIDEwKSA6IG5hdHVyYWxMb2dhcml0aG0oYmFzZSwgc2QpO1xuICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcbiAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrID0gcHIsIHJtKSkge1xuICAgIGRvIHtcbiAgICAgIHNkICs9IDEwO1xuICAgICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcbiAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XG4gICAgICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcbiAgICAgIGlmICghaW5mKSB7XG4gICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShrICsgMSwgayArIDE1KSArIDEgPT0gMWUxNCkge1xuICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBrICs9IDEwLCBybSkpO1xuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XG59O1xuUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24oeSkge1xuICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeSA9IG5ldyBDdG9yKHkpO1xuICBpZiAoIXguZCB8fCAheS5kKSB7XG4gICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XG4gICAgZWxzZSBpZiAoeC5kKSB5LnMgPSAteS5zO1xuICAgIGVsc2UgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xuICAgIHJldHVybiB5O1xuICB9XG4gIGlmICh4LnMgIT0geS5zKSB7XG4gICAgeS5zID0gLXkucztcbiAgICByZXR1cm4geC5wbHVzKHkpO1xuICB9XG4gIHhkID0geC5kO1xuICB5ZCA9IHkuZDtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xuICAgIGlmICh5ZFswXSkgeS5zID0gLXkucztcbiAgICBlbHNlIGlmICh4ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xuICAgIGVsc2UgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbiAgfVxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xuICB4ZCA9IHhkLnNsaWNlKCk7XG4gIGsgPSB4ZSAtIGU7XG4gIGlmIChrKSB7XG4gICAgeExUeSA9IGsgPCAwO1xuICAgIGlmICh4TFR5KSB7XG4gICAgICBkID0geGQ7XG4gICAgICBrID0gLWs7XG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSB5ZDtcbiAgICAgIGUgPSB4ZTtcbiAgICAgIGxlbiA9IHhkLmxlbmd0aDtcbiAgICB9XG4gICAgaSA9IE1hdGgubWF4KE1hdGguY2VpbChwciAvIExPR19CQVNFKSwgbGVuKSArIDI7XG4gICAgaWYgKGsgPiBpKSB7XG4gICAgICBrID0gaTtcbiAgICAgIGQubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZC5yZXZlcnNlKCk7XG4gICAgZm9yIChpID0gazsgaS0tOyApIGQucHVzaCgwKTtcbiAgICBkLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBpID0geGQubGVuZ3RoO1xuICAgIGxlbiA9IHlkLmxlbmd0aDtcbiAgICB4TFR5ID0gaSA8IGxlbjtcbiAgICBpZiAoeExUeSkgbGVuID0gaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xuICAgICAgICB4TFR5ID0geGRbaV0gPCB5ZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGsgPSAwO1xuICB9XG4gIGlmICh4TFR5KSB7XG4gICAgZCA9IHhkO1xuICAgIHhkID0geWQ7XG4gICAgeWQgPSBkO1xuICAgIHkucyA9IC15LnM7XG4gIH1cbiAgbGVuID0geGQubGVuZ3RoO1xuICBmb3IgKGkgPSB5ZC5sZW5ndGggLSBsZW47IGkgPiAwOyAtLWkpIHhkW2xlbisrXSA9IDA7XG4gIGZvciAoaSA9IHlkLmxlbmd0aDsgaSA+IGs7ICkge1xuICAgIGlmICh4ZFstLWldIDwgeWRbaV0pIHtcbiAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDsgKSB4ZFtqXSA9IEJBU0UgLSAxO1xuICAgICAgLS14ZFtqXTtcbiAgICAgIHhkW2ldICs9IEJBU0U7XG4gICAgfVxuICAgIHhkW2ldIC09IHlkW2ldO1xuICB9XG4gIGZvciAoOyB4ZFstLWxlbl0gPT09IDA7ICkgeGQucG9wKCk7XG4gIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSkgLS1lO1xuICBpZiAoIXhkWzBdKSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xuICB5LmQgPSB4ZDtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbn07XG5QLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24oeSkge1xuICB2YXIgcSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICB5ID0gbmV3IEN0b3IoeSk7XG4gIGlmICgheC5kIHx8ICF5LnMgfHwgeS5kICYmICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoIXkuZCB8fCB4LmQgJiYgIXguZFswXSkge1xuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpO1xuICB9XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGlmIChDdG9yLm1vZHVsbyA9PSA5KSB7XG4gICAgcSA9IGRpdmlkZSh4LCB5LmFicygpLCAwLCAzLCAxKTtcbiAgICBxLnMgKj0geS5zO1xuICB9IGVsc2Uge1xuICAgIHEgPSBkaXZpZGUoeCwgeSwgMCwgQ3Rvci5tb2R1bG8sIDEpO1xuICB9XG4gIHEgPSBxLnRpbWVzKHkpO1xuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB4Lm1pbnVzKHEpO1xufTtcblAubmF0dXJhbEV4cG9uZW50aWFsID0gUC5leHAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5hdHVyYWxFeHBvbmVudGlhbCh0aGlzKTtcbn07XG5QLm5hdHVyYWxMb2dhcml0aG0gPSBQLmxuID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xufTtcblAubmVnYXRlZCA9IFAubmVnID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG4gIHgucyA9IC14LnM7XG4gIHJldHVybiBmaW5hbGlzZSh4KTtcbn07XG5QLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGNhcnJ5LCBkLCBlLCBpLCBrLCBsZW4sIHByLCBybSwgeGQsIHlkLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHkgPSBuZXcgQ3Rvcih5KTtcbiAgaWYgKCF4LmQgfHwgIXkuZCkge1xuICAgIGlmICgheC5zIHx8ICF5LnMpIHkgPSBuZXcgQ3RvcihOYU4pO1xuICAgIGVsc2UgaWYgKCF4LmQpIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zID09PSB5LnMgPyB4IDogTmFOKTtcbiAgICByZXR1cm4geTtcbiAgfVxuICBpZiAoeC5zICE9IHkucykge1xuICAgIHkucyA9IC15LnM7XG4gICAgcmV0dXJuIHgubWludXMoeSk7XG4gIH1cbiAgeGQgPSB4LmQ7XG4gIHlkID0geS5kO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSB7XG4gICAgaWYgKCF5ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xuICB9XG4gIGsgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcbiAgeGQgPSB4ZC5zbGljZSgpO1xuICBpID0gayAtIGU7XG4gIGlmIChpKSB7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBkID0geGQ7XG4gICAgICBpID0gLWk7XG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSB5ZDtcbiAgICAgIGUgPSBrO1xuICAgICAgbGVuID0geGQubGVuZ3RoO1xuICAgIH1cbiAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xuICAgIGxlbiA9IGsgPiBsZW4gPyBrICsgMSA6IGxlbiArIDE7XG4gICAgaWYgKGkgPiBsZW4pIHtcbiAgICAgIGkgPSBsZW47XG4gICAgICBkLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGQucmV2ZXJzZSgpO1xuICAgIGZvciAoOyBpLS07ICkgZC5wdXNoKDApO1xuICAgIGQucmV2ZXJzZSgpO1xuICB9XG4gIGxlbiA9IHhkLmxlbmd0aDtcbiAgaSA9IHlkLmxlbmd0aDtcbiAgaWYgKGxlbiAtIGkgPCAwKSB7XG4gICAgaSA9IGxlbjtcbiAgICBkID0geWQ7XG4gICAgeWQgPSB4ZDtcbiAgICB4ZCA9IGQ7XG4gIH1cbiAgZm9yIChjYXJyeSA9IDA7IGk7ICkge1xuICAgIGNhcnJ5ID0gKHhkWy0taV0gPSB4ZFtpXSArIHlkW2ldICsgY2FycnkpIC8gQkFTRSB8IDA7XG4gICAgeGRbaV0gJT0gQkFTRTtcbiAgfVxuICBpZiAoY2FycnkpIHtcbiAgICB4ZC51bnNoaWZ0KGNhcnJ5KTtcbiAgICArK2U7XG4gIH1cbiAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7IHhkWy0tbGVuXSA9PSAwOyApIHhkLnBvcCgpO1xuICB5LmQgPSB4ZDtcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcbn07XG5QLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbih6KSB7XG4gIHZhciBrLCB4ID0gdGhpcztcbiAgaWYgKHogIT09IHZvaWQgMCAmJiB6ICE9PSAhIXogJiYgeiAhPT0gMSAmJiB6ICE9PSAwKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB6KTtcbiAgaWYgKHguZCkge1xuICAgIGsgPSBnZXRQcmVjaXNpb24oeC5kKTtcbiAgICBpZiAoeiAmJiB4LmUgKyAxID4gaykgayA9IHguZSArIDE7XG4gIH0gZWxzZSB7XG4gICAgayA9IE5hTjtcbiAgfVxuICByZXR1cm4gaztcbn07XG5QLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XG59O1xuUC5zaW5lID0gUC5zaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHByLCBybSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIHByID0gQ3Rvci5wcmVjaXNpb247XG4gIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xuICBDdG9yLnJvdW5kaW5nID0gMTtcbiAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID4gMiA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbSwgbiwgc2QsIHIsIHJlcCwgdCwgeCA9IHRoaXMsIGQgPSB4LmQsIGUgPSB4LmUsIHMgPSB4LnMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAocyAhPT0gMSB8fCAhZCB8fCAhZFswXSkge1xuICAgIHJldHVybiBuZXcgQ3RvcighcyB8fCBzIDwgMCAmJiAoIWQgfHwgZFswXSkgPyBOYU4gOiBkID8geCA6IDEgLyAwKTtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBzID0gTWF0aC5zcXJ0KCt4KTtcbiAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XG4gICAgbiA9IGRpZ2l0c1RvU3RyaW5nKGQpO1xuICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSBcIjBcIjtcbiAgICBzID0gTWF0aC5zcXJ0KG4pO1xuICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcbiAgICBpZiAocyA9PSAxIC8gMCkge1xuICAgICAgbiA9IFwiNWVcIiArIGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZihcImVcIikgKyAxKSArIGU7XG4gICAgfVxuICAgIHIgPSBuZXcgQ3RvcihuKTtcbiAgfSBlbHNlIHtcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcbiAgfVxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcbiAgZm9yICg7IDsgKSB7XG4gICAgdCA9IHI7XG4gICAgciA9IHQucGx1cyhkaXZpZGUoeCwgdCwgc2QgKyAyLCAxKSkudGltZXMoMC41KTtcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XG4gICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XG4gICAgICBpZiAobiA9PSBcIjk5OTlcIiB8fCAhcmVwICYmIG4gPT0gXCI0OTk5XCIpIHtcbiAgICAgICAgaWYgKCFyZXApIHtcbiAgICAgICAgICBmaW5hbGlzZSh0LCBlICsgMSwgMCk7XG4gICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcbiAgICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNkICs9IDQ7XG4gICAgICAgIHJlcCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSBcIjVcIikge1xuICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcbiAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xufTtcblAudGFuZ2VudCA9IFAudGFuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwciwgcm0sIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyAxMDtcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XG4gIHggPSB4LnNpbigpO1xuICB4LnMgPSAxO1xuICB4ID0gZGl2aWRlKHgsIG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKSwgcHIgKyAxMCwgMCk7XG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gIEN0b3Iucm91bmRpbmcgPSBybTtcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gNCA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xufTtcblAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIGNhcnJ5LCBlLCBpLCBrLCByLCByTCwgdCwgeGRMLCB5ZEwsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvciwgeGQgPSB4LmQsIHlkID0gKHkgPSBuZXcgQ3Rvcih5KSkuZDtcbiAgeS5zICo9IHgucztcbiAgaWYgKCF4ZCB8fCAheGRbMF0gfHwgIXlkIHx8ICF5ZFswXSkge1xuICAgIHJldHVybiBuZXcgQ3RvcigheS5zIHx8IHhkICYmICF4ZFswXSAmJiAheWQgfHwgeWQgJiYgIXlkWzBdICYmICF4ZCA/IE5hTiA6ICF4ZCB8fCAheWQgPyB5LnMgLyAwIDogeS5zICogMCk7XG4gIH1cbiAgZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xuICB4ZEwgPSB4ZC5sZW5ndGg7XG4gIHlkTCA9IHlkLmxlbmd0aDtcbiAgaWYgKHhkTCA8IHlkTCkge1xuICAgIHIgPSB4ZDtcbiAgICB4ZCA9IHlkO1xuICAgIHlkID0gcjtcbiAgICByTCA9IHhkTDtcbiAgICB4ZEwgPSB5ZEw7XG4gICAgeWRMID0gckw7XG4gIH1cbiAgciA9IFtdO1xuICByTCA9IHhkTCArIHlkTDtcbiAgZm9yIChpID0gckw7IGktLTsgKSByLnB1c2goMCk7XG4gIGZvciAoaSA9IHlkTDsgLS1pID49IDA7ICkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGsgPSB4ZEwgKyBpOyBrID4gaTsgKSB7XG4gICAgICB0ID0gcltrXSArIHlkW2ldICogeGRbayAtIGkgLSAxXSArIGNhcnJ5O1xuICAgICAgcltrLS1dID0gdCAlIEJBU0UgfCAwO1xuICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XG4gICAgfVxuICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xuICB9XG4gIGZvciAoOyAhclstLXJMXTsgKSByLnBvcCgpO1xuICBpZiAoY2FycnkpICsrZTtcbiAgZWxzZSByLnNoaWZ0KCk7XG4gIHkuZCA9IHI7XG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHIsIGUpO1xuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZykgOiB5O1xufTtcblAudG9CaW5hcnkgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDIsIHNkLCBybSk7XG59O1xuUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgeCA9IG5ldyBDdG9yKHgpO1xuICBpZiAoZHAgPT09IHZvaWQgMCkgcmV0dXJuIHg7XG4gIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xuICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XG59O1xuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24oZHAsIHJtKSB7XG4gIHZhciBzdHIsIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlLCBkcCArIDEpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvRml4ZWQgPSBmdW5jdGlvbihkcCwgcm0pIHtcbiAgdmFyIHN0ciwgeSwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoZHAgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB5ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgeC5lICsgMSwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvRnJhY3Rpb24gPSBmdW5jdGlvbihtYXhEKSB7XG4gIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBrLCBuLCBuMCwgbjEsIHByLCBxLCByLCB4ID0gdGhpcywgeGQgPSB4LmQsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoIXhkKSByZXR1cm4gbmV3IEN0b3IoeCk7XG4gIG4xID0gZDAgPSBuZXcgQ3RvcigxKTtcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xuICBkID0gbmV3IEN0b3IoZDEpO1xuICBlID0gZC5lID0gZ2V0UHJlY2lzaW9uKHhkKSAtIHguZSAtIDE7XG4gIGsgPSBlICUgTE9HX0JBU0U7XG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XG4gIGlmIChtYXhEID09IG51bGwpIHtcbiAgICBtYXhEID0gZSA+IDAgPyBkIDogbjE7XG4gIH0gZWxzZSB7XG4gICAgbiA9IG5ldyBDdG9yKG1heEQpO1xuICAgIGlmICghbi5pc0ludCgpIHx8IG4ubHQobjEpKSB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBuKTtcbiAgICBtYXhEID0gbi5ndChkKSA/IGUgPiAwID8gZCA6IG4xIDogbjtcbiAgfVxuICBleHRlcm5hbCA9IGZhbHNlO1xuICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgQ3Rvci5wcmVjaXNpb24gPSBlID0geGQubGVuZ3RoICogTE9HX0JBU0UgKiAyO1xuICBmb3IgKDsgOyApIHtcbiAgICBxID0gZGl2aWRlKG4sIGQsIDAsIDEsIDEpO1xuICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XG4gICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKSBicmVhaztcbiAgICBkMCA9IGQxO1xuICAgIGQxID0gZDI7XG4gICAgZDIgPSBuMTtcbiAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMikpO1xuICAgIG4wID0gZDI7XG4gICAgZDIgPSBkO1xuICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIpKTtcbiAgICBuID0gZDI7XG4gIH1cbiAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcbiAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XG4gIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xuICBuMC5zID0gbjEucyA9IHgucztcbiAgciA9IGRpdmlkZShuMSwgZDEsIGUsIDEpLm1pbnVzKHgpLmFicygpLmNtcChkaXZpZGUobjAsIGQwLCBlLCAxKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gcjtcbn07XG5QLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcbn07XG5QLnRvTmVhcmVzdCA9IGZ1bmN0aW9uKHksIHJtKSB7XG4gIHZhciB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3I7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKHkgPT0gbnVsbCkge1xuICAgIGlmICgheC5kKSByZXR1cm4geDtcbiAgICB5ID0gbmV3IEN0b3IoMSk7XG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICB9IGVsc2Uge1xuICAgIHkgPSBuZXcgQ3Rvcih5KTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkge1xuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgICB9XG4gICAgaWYgKCF4LmQpIHJldHVybiB5LnMgPyB4IDogeTtcbiAgICBpZiAoIXkuZCkge1xuICAgICAgaWYgKHkucykgeS5zID0geC5zO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9XG4gIGlmICh5LmRbMF0pIHtcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xuICAgIHggPSBkaXZpZGUoeCwgeSwgMCwgcm0sIDEpLnRpbWVzKHkpO1xuICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICBmaW5hbGlzZSh4KTtcbiAgfSBlbHNlIHtcbiAgICB5LnMgPSB4LnM7XG4gICAgeCA9IHk7XG4gIH1cbiAgcmV0dXJuIHg7XG59O1xuUC50b051bWJlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gK3RoaXM7XG59O1xuUC50b09jdGFsID0gZnVuY3Rpb24oc2QsIHJtKSB7XG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xufTtcblAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24oeSkge1xuICB2YXIgZSwgaywgcHIsIHIsIHJtLCBzLCB4ID0gdGhpcywgQ3RvciA9IHguY29uc3RydWN0b3IsIHluID0gKyh5ID0gbmV3IEN0b3IoeSkpO1xuICBpZiAoIXguZCB8fCAheS5kIHx8ICF4LmRbMF0gfHwgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XG4gIHggPSBuZXcgQ3Rvcih4KTtcbiAgaWYgKHguZXEoMSkpIHJldHVybiB4O1xuICBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBybSA9IEN0b3Iucm91bmRpbmc7XG4gIGlmICh5LmVxKDEpKSByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcbiAgZSA9IG1hdGhmbG9vcih5LmUgLyBMT0dfQkFTRSk7XG4gIGlmIChlID49IHkuZC5sZW5ndGggLSAxICYmIChrID0geW4gPCAwID8gLXluIDogeW4pIDw9IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcbiAgICByZXR1cm4geS5zIDwgMCA/IG5ldyBDdG9yKDEpLmRpdihyKSA6IGZpbmFsaXNlKHIsIHByLCBybSk7XG4gIH1cbiAgcyA9IHgucztcbiAgaWYgKHMgPCAwKSB7XG4gICAgaWYgKGUgPCB5LmQubGVuZ3RoIC0gMSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XG4gICAgaWYgKCh5LmRbZV0gJiAxKSA9PSAwKSBzID0gMTtcbiAgICBpZiAoeC5lID09IDAgJiYgeC5kWzBdID09IDEgJiYgeC5kLmxlbmd0aCA9PSAxKSB7XG4gICAgICB4LnMgPSBzO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9XG4gIGsgPSBtYXRocG93KCt4LCB5bik7XG4gIGUgPSBrID09IDAgfHwgIWlzRmluaXRlKGspID8gbWF0aGZsb29yKHluICogKE1hdGgubG9nKFwiMC5cIiArIGRpZ2l0c1RvU3RyaW5nKHguZCkpIC8gTWF0aC5MTjEwICsgeC5lICsgMSkpIDogbmV3IEN0b3IoayArIFwiXCIpLmU7XG4gIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSkgcmV0dXJuIG5ldyBDdG9yKGUgPiAwID8gcyAvIDAgOiAwKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgQ3Rvci5yb3VuZGluZyA9IHgucyA9IDE7XG4gIGsgPSBNYXRoLm1pbigxMiwgKGUgKyBcIlwiKS5sZW5ndGgpO1xuICByID0gbmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBwciArIGspKSwgcHIpO1xuICBpZiAoci5kKSB7XG4gICAgciA9IGZpbmFsaXNlKHIsIHByICsgNSwgMSk7XG4gICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBwciwgcm0pKSB7XG4gICAgICBlID0gcHIgKyAxMDtcbiAgICAgIHIgPSBmaW5hbGlzZShuYXR1cmFsRXhwb25lbnRpYWwoeS50aW1lcyhuYXR1cmFsTG9nYXJpdGhtKHgsIGUgKyBrKSksIGUpLCBlICsgNSwgMSk7XG4gICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UocHIgKyAxLCBwciArIDE1KSArIDEgPT0gMWUxNCkge1xuICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgci5zID0gcztcbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICBDdG9yLnJvdW5kaW5nID0gcm07XG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xufTtcblAudG9QcmVjaXNpb24gPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgdmFyIHN0ciwgeCA9IHRoaXMsIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoc2QgPT09IHZvaWQgMCkge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQ3Rvci50b0V4cE5lZywgc2QpO1xuICB9XG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn07XG5QLnRvU2lnbmlmaWNhbnREaWdpdHMgPSBQLnRvU0QgPSBmdW5jdGlvbihzZCwgcm0pIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcbiAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgfSBlbHNlIHtcbiAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xufTtcblAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuUC50cnVuY2F0ZWQgPSBQLnRydW5jID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XG59O1xuUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHggPSB0aGlzLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xuICByZXR1cm4geC5pc05lZygpID8gXCItXCIgKyBzdHIgOiBzdHI7XG59O1xuZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xuICB2YXIgaSwgaywgd3MsIGluZGV4T2ZMYXN0V29yZCA9IGQubGVuZ3RoIC0gMSwgc3RyID0gXCJcIiwgdyA9IGRbMF07XG4gIGlmIChpbmRleE9mTGFzdFdvcmQgPiAwKSB7XG4gICAgc3RyICs9IHc7XG4gICAgZm9yIChpID0gMTsgaSA8IGluZGV4T2ZMYXN0V29yZDsgaSsrKSB7XG4gICAgICB3cyA9IGRbaV0gKyBcIlwiO1xuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xuICAgICAgaWYgKGspIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgICAgc3RyICs9IHdzO1xuICAgIH1cbiAgICB3ID0gZFtpXTtcbiAgICB3cyA9IHcgKyBcIlwiO1xuICAgIGsgPSBMT0dfQkFTRSAtIHdzLmxlbmd0aDtcbiAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XG4gIH0gZWxzZSBpZiAodyA9PT0gMCkge1xuICAgIHJldHVybiBcIjBcIjtcbiAgfVxuICBmb3IgKDsgdyAlIDEwID09PSAwOyApIHcgLz0gMTA7XG4gIHJldHVybiBzdHIgKyB3O1xufVxuZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4yLCBtYXgyKSB7XG4gIGlmIChpICE9PSB+fmkgfHwgaSA8IG1pbjIgfHwgaSA+IG1heDIpIHtcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBpKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tSb3VuZGluZ0RpZ2l0cyhkLCBpLCBybSwgcmVwZWF0aW5nKSB7XG4gIHZhciBkaSwgaywgciwgcmQ7XG4gIGZvciAoayA9IGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIC0taTtcbiAgaWYgKC0taSA8IDApIHtcbiAgICBpICs9IExPR19CQVNFO1xuICAgIGRpID0gMDtcbiAgfSBlbHNlIHtcbiAgICBkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgIGkgJT0gTE9HX0JBU0U7XG4gIH1cbiAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XG4gIHJkID0gZFtkaV0gJSBrIHwgMDtcbiAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XG4gICAgaWYgKGkgPCAzKSB7XG4gICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMTAwIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwIHwgMDtcbiAgICAgIHIgPSBybSA8IDQgJiYgcmQgPT0gOTk5OTkgfHwgcm0gPiAzICYmIHJkID09IDQ5OTk5IHx8IHJkID09IDVlNCB8fCByZCA9PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gKHJtIDwgNCAmJiByZCArIDEgPT0gayB8fCBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAyKSAtIDEgfHwgKHJkID09IGsgLyAyIHx8IHJkID09IDApICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGkgPCA0KSB7XG4gICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMWUzIHwgMDtcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwMCB8IDA7XG4gICAgICBlbHNlIGlmIChpID09IDIpIHJkID0gcmQgLyAxMCB8IDA7XG4gICAgICByID0gKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkID09IDk5OTkgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgPT0gNDk5OTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9ICgocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgKyAxID09IGsgfHwgIXJlcGVhdGluZyAmJiBybSA+IDMgJiYgcmQgKyAxID09IGsgLyAyKSAmJiAoZFtkaSArIDFdIC8gayAvIDFlMyB8IDApID09IG1hdGhwb3coMTAsIGkgLSAzKSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcbiAgdmFyIGosIGFyciA9IFswXSwgYXJyTCwgaSA9IDAsIHN0ckwgPSBzdHIubGVuZ3RoO1xuICBmb3IgKDsgaSA8IHN0ckw7ICkge1xuICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgKSBhcnJbYXJyTF0gKj0gYmFzZUluO1xuICAgIGFyclswXSArPSBOVU1FUkFMUy5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XG4gICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XG4gICAgICAgIGlmIChhcnJbaiArIDFdID09PSB2b2lkIDApIGFycltqICsgMV0gPSAwO1xuICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xuICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBjb3NpbmUoQ3RvciwgeCkge1xuICB2YXIgaywgbGVuLCB5O1xuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIHg7XG4gIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzMikge1xuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XG4gICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBrID0gMTY7XG4gICAgeSA9IFwiMi4zMjgzMDY0MzY1Mzg2OTYyODkwNjI1ZS0xMFwiO1xuICB9XG4gIEN0b3IucHJlY2lzaW9uICs9IGs7XG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xuICBmb3IgKHZhciBpID0gazsgaS0tOyApIHtcbiAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xuICAgIHggPSBjb3MyeC50aW1lcyhjb3MyeCkubWludXMoY29zMngpLnRpbWVzKDgpLnBsdXMoMSk7XG4gIH1cbiAgQ3Rvci5wcmVjaXNpb24gLT0gaztcbiAgcmV0dXJuIHg7XG59XG52YXIgZGl2aWRlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBtdWx0aXBseUludGVnZXIoeCwgaywgYmFzZSkge1xuICAgIHZhciB0ZW1wLCBjYXJyeSA9IDAsIGkgPSB4Lmxlbmd0aDtcbiAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTsgKSB7XG4gICAgICB0ZW1wID0geFtpXSAqIGsgKyBjYXJyeTtcbiAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZSB8IDA7XG4gICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XG4gICAgdmFyIGksIHI7XG4gICAgaWYgKGFMICE9IGJMKSB7XG4gICAgICByID0gYUwgPiBiTCA/IDEgOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gciA9IDA7IGkgPCBhTDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcbiAgICAgICAgICByID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGFMLS07ICkge1xuICAgICAgYVthTF0gLT0gaTtcbiAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XG4gICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcbiAgICB9XG4gICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgKSBhLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHksIHByLCBybSwgZHAsIGJhc2UpIHtcbiAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLCB5TCwgeXosIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBzaWduMiA9IHgucyA9PSB5LnMgPyAxIDogLTEsIHhkID0geC5kLCB5ZCA9IHkuZDtcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XG4gICAgICByZXR1cm4gbmV3IEN0b3IoXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxuICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhkID8geWQgJiYgeGRbMF0gPT0geWRbMF0gOiAheWQpID8gTmFOIDogKFxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyAwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyAwLlxuICAgICAgICAgIHhkICYmIHhkWzBdID09IDAgfHwgIXlkID8gc2lnbjIgKiAwIDogc2lnbjIgLyAwXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChiYXNlKSB7XG4gICAgICBsb2dCYXNlID0gMTtcbiAgICAgIGUgPSB4LmUgLSB5LmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSBCQVNFO1xuICAgICAgbG9nQmFzZSA9IExPR19CQVNFO1xuICAgICAgZSA9IG1hdGhmbG9vcih4LmUgLyBsb2dCYXNlKSAtIG1hdGhmbG9vcih5LmUgLyBsb2dCYXNlKTtcbiAgICB9XG4gICAgeUwgPSB5ZC5sZW5ndGg7XG4gICAgeEwgPSB4ZC5sZW5ndGg7XG4gICAgcSA9IG5ldyBDdG9yKHNpZ24yKTtcbiAgICBxZCA9IHEuZCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IHlkW2ldID09ICh4ZFtpXSB8fCAwKTsgaSsrKSA7XG4gICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKSBlLS07XG4gICAgaWYgKHByID09IG51bGwpIHtcbiAgICAgIHNkID0gcHIgPSBDdG9yLnByZWNpc2lvbjtcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgICB9IGVsc2UgaWYgKGRwKSB7XG4gICAgICBzZCA9IHByICsgKHguZSAtIHkuZSkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZCA9IHByO1xuICAgIH1cbiAgICBpZiAoc2QgPCAwKSB7XG4gICAgICBxZC5wdXNoKDEpO1xuICAgICAgbW9yZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XG4gICAgICBpID0gMDtcbiAgICAgIGlmICh5TCA9PSAxKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgICB5ZCA9IHlkWzBdO1xuICAgICAgICBzZCsrO1xuICAgICAgICBmb3IgKDsgKGkgPCB4TCB8fCBrKSAmJiBzZC0tOyBpKyspIHtcbiAgICAgICAgICB0ID0gayAqIGJhc2UgKyAoeGRbaV0gfHwgMCk7XG4gICAgICAgICAgcWRbaV0gPSB0IC8geWQgfCAwO1xuICAgICAgICAgIGsgPSB0ICUgeWQgfCAwO1xuICAgICAgICB9XG4gICAgICAgIG1vcmUgPSBrIHx8IGkgPCB4TDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSBiYXNlIC8gKHlkWzBdICsgMSkgfCAwO1xuICAgICAgICBpZiAoayA+IDEpIHtcbiAgICAgICAgICB5ZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XG4gICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xuICAgICAgICAgIHlMID0geWQubGVuZ3RoO1xuICAgICAgICAgIHhMID0geGQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHhpID0geUw7XG4gICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7ICkgcmVtW3JlbUwrK10gPSAwO1xuICAgICAgICB5eiA9IHlkLnNsaWNlKCk7XG4gICAgICAgIHl6LnVuc2hpZnQoMCk7XG4gICAgICAgIHlkMCA9IHlkWzBdO1xuICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpICsreWQwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcbiAgICAgICAgICAgIGsgPSByZW0wIC8geWQwIHwgMDtcbiAgICAgICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgICAgICBpZiAoayA+PSBiYXNlKSBrID0gYmFzZSAtIDE7XG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKTtcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHlkLCBwcm9kTCwgYmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChrID09IDApIGNtcCA9IGsgPSAxO1xuICAgICAgICAgICAgICBwcm9kID0geWQuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kLnVuc2hpZnQoMCk7XG4gICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xuICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XG4gICAgICAgICAgICAgIGlmIChjbXAgPCAxKSB7XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5ZCwgcmVtTCwgYmFzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgICAgICByZW0gPSBbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHFkW2krK10gPSBrO1xuICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XG4gICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhkW3hpXSB8fCAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcbiAgICAgICAgICAgIHJlbUwgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT09IHZvaWQgMCkgJiYgc2QtLSk7XG4gICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICghcWRbMF0pIHFkLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChsb2dCYXNlID09IDEpIHtcbiAgICAgIHEuZSA9IGU7XG4gICAgICBpbmV4YWN0ID0gbW9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMSwgayA9IHFkWzBdOyBrID49IDEwOyBrIC89IDEwKSBpKys7XG4gICAgICBxLmUgPSBpICsgZSAqIGxvZ0Jhc2UgLSAxO1xuICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIGZpbmFsaXNlKHgsIHNkLCBybSwgaXNUcnVuY2F0ZWQpIHtcbiAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBvdXQ6IGlmIChzZCAhPSBudWxsKSB7XG4gICAgeGQgPSB4LmQ7XG4gICAgaWYgKCF4ZCkgcmV0dXJuIHg7XG4gICAgZm9yIChkaWdpdHMgPSAxLCBrID0geGRbMF07IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xuICAgIGkgPSBzZCAtIGRpZ2l0cztcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGkgKz0gTE9HX0JBU0U7XG4gICAgICBqID0gc2Q7XG4gICAgICB3ID0geGRbeGRpID0gMF07XG4gICAgICByZCA9IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhkaSA9IE1hdGguY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xuICAgICAgayA9IHhkLmxlbmd0aDtcbiAgICAgIGlmICh4ZGkgPj0gaykge1xuICAgICAgICBpZiAoaXNUcnVuY2F0ZWQpIHtcbiAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTsgKSB4ZC5wdXNoKDApO1xuICAgICAgICAgIHcgPSByZCA9IDA7XG4gICAgICAgICAgZGlnaXRzID0gMTtcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdyA9IGsgPSB4ZFt4ZGldO1xuICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xuICAgICAgICBpICU9IExPR19CQVNFO1xuICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xuICAgICAgICByZCA9IGogPCAwID8gMCA6IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkgJSAxMCB8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlzVHJ1bmNhdGVkID0gaXNUcnVuY2F0ZWQgfHwgc2QgPCAwIHx8IHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xuICAgIHJvdW5kVXAgPSBybSA8IDQgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKSA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IGlzVHJ1bmNhdGVkIHx8IHJtID09IDYgJiYgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cbiAgICAoaSA+IDAgPyBqID4gMCA/IHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSA6IDAgOiB4ZFt4ZGkgLSAxXSkgJSAxMCAmIDEgfHwgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xuICAgIGlmIChzZCA8IDEgfHwgIXhkWzBdKSB7XG4gICAgICB4ZC5sZW5ndGggPSAwO1xuICAgICAgaWYgKHJvdW5kVXApIHtcbiAgICAgICAgc2QgLT0geC5lICsgMTtcbiAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcbiAgICAgICAgeC5lID0gLXNkIHx8IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ZFswXSA9IHguZSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKGkgPT0gMCkge1xuICAgICAgeGQubGVuZ3RoID0geGRpO1xuICAgICAgayA9IDE7XG4gICAgICB4ZGktLTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGQubGVuZ3RoID0geGRpICsgMTtcbiAgICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xuICAgICAgeGRbeGRpXSA9IGogPiAwID8gKHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSAlIG1hdGhwb3coMTAsIGopIHwgMCkgKiBrIDogMDtcbiAgICB9XG4gICAgaWYgKHJvdW5kVXApIHtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBpZiAoeGRpID09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGRbMF07IGogPj0gMTA7IGogLz0gMTApIGkrKztcbiAgICAgICAgICBqID0geGRbMF0gKz0gaztcbiAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwKSBrKys7XG4gICAgICAgICAgaWYgKGkgIT0gaykge1xuICAgICAgICAgICAgeC5lKys7XG4gICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSkgeGRbMF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4ZFt4ZGldICs9IGs7XG4gICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSkgYnJlYWs7XG4gICAgICAgICAgeGRbeGRpLS1dID0gMDtcbiAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7ICkgeGQucG9wKCk7XG4gIH1cbiAgaWYgKGV4dGVybmFsKSB7XG4gICAgaWYgKHguZSA+IEN0b3IubWF4RSkge1xuICAgICAgeC5kID0gbnVsbDtcbiAgICAgIHguZSA9IE5hTjtcbiAgICB9IGVsc2UgaWYgKHguZSA8IEN0b3IubWluRSkge1xuICAgICAgeC5lID0gMDtcbiAgICAgIHguZCA9IFswXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBmaW5pdGVUb1N0cmluZyh4LCBpc0V4cCwgc2QpIHtcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBub25GaW5pdGVUb1N0cmluZyh4KTtcbiAgdmFyIGssIGUgPSB4LmUsIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksIGxlbiA9IHN0ci5sZW5ndGg7XG4gIGlmIChpc0V4cCkge1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcbiAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKSArIGdldFplcm9TdHJpbmcoayk7XG4gICAgfSBlbHNlIGlmIChsZW4gPiAxKSB7XG4gICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgXCIuXCIgKyBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHN0ciA9IHN0ciArICh4LmUgPCAwID8gXCJlXCIgOiBcImUrXCIpICsgeC5lO1xuICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgc3RyID0gXCIwLlwiICsgZ2V0WmVyb1N0cmluZygtZSAtIDEpICsgc3RyO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XG4gICAgc3RyICs9IGdldFplcm9TdHJpbmcoZSArIDEgLSBsZW4pO1xuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gZSAtIDEpID4gMCkgc3RyID0gc3RyICsgXCIuXCIgKyBnZXRaZXJvU3RyaW5nKGspO1xuICB9IGVsc2Uge1xuICAgIGlmICgoayA9IGUgKyAxKSA8IGxlbikgc3RyID0gc3RyLnNsaWNlKDAsIGspICsgXCIuXCIgKyBzdHIuc2xpY2Uoayk7XG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xuICAgICAgaWYgKGUgKyAxID09PSBsZW4pIHN0ciArPSBcIi5cIjtcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZ2V0QmFzZTEwRXhwb25lbnQoZGlnaXRzLCBlKSB7XG4gIHZhciB3ID0gZGlnaXRzWzBdO1xuICBmb3IgKGUgKj0gTE9HX0JBU0U7IHcgPj0gMTA7IHcgLz0gMTApIGUrKztcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xuICBpZiAoc2QgPiBMTjEwX1BSRUNJU0lPTikge1xuICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICBpZiAocHIpIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKExOMTApLCBzZCwgMSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZXRQaShDdG9yLCBzZCwgcm0pIHtcbiAgaWYgKHNkID4gUElfUFJFQ0lTSU9OKSB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKFBJKSwgc2QsIHJtLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdldFByZWNpc2lvbihkaWdpdHMpIHtcbiAgdmFyIHcgPSBkaWdpdHMubGVuZ3RoIC0gMSwgbGVuID0gdyAqIExPR19CQVNFICsgMTtcbiAgdyA9IGRpZ2l0c1t3XTtcbiAgaWYgKHcpIHtcbiAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApIGxlbi0tO1xuICAgIGZvciAodyA9IGRpZ2l0c1swXTsgdyA+PSAxMDsgdyAvPSAxMCkgbGVuKys7XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbmZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xuICB2YXIgenMgPSBcIlwiO1xuICBmb3IgKDsgay0tOyApIHpzICs9IFwiMFwiO1xuICByZXR1cm4genM7XG59XG5mdW5jdGlvbiBpbnRQb3coQ3RvciwgeCwgbiwgcHIpIHtcbiAgdmFyIGlzVHJ1bmNhdGVkLCByID0gbmV3IEN0b3IoMSksIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSArIDQpO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBmb3IgKDsgOyApIHtcbiAgICBpZiAobiAlIDIpIHtcbiAgICAgIHIgPSByLnRpbWVzKHgpO1xuICAgICAgaWYgKHRydW5jYXRlKHIuZCwgaykpIGlzVHJ1bmNhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbiA9IG1hdGhmbG9vcihuIC8gMik7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIG4gPSByLmQubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpc1RydW5jYXRlZCAmJiByLmRbbl0gPT09IDApICsrci5kW25dO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHggPSB4LnRpbWVzKHgpO1xuICAgIHRydW5jYXRlKHguZCwgayk7XG4gIH1cbiAgZXh0ZXJuYWwgPSB0cnVlO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGlzT2RkKG4pIHtcbiAgcmV0dXJuIG4uZFtuLmQubGVuZ3RoIC0gMV0gJiAxO1xufVxuZnVuY3Rpb24gbWF4T3JNaW4oQ3RvciwgYXJncywgbikge1xuICB2YXIgaywgeSwgeCA9IG5ldyBDdG9yKGFyZ3NbMF0pLCBpID0gMDtcbiAgZm9yICg7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcbiAgICB5ID0gbmV3IEN0b3IoYXJnc1tpXSk7XG4gICAgaWYgKCF5LnMpIHtcbiAgICAgIHggPSB5O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGsgPSB4LmNtcCh5KTtcbiAgICBpZiAoayA9PT0gbiB8fCBrID09PSAwICYmIHgucyA9PT0gbikge1xuICAgICAgeCA9IHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XG4gIHZhciBkZW5vbWluYXRvciwgZ3VhcmQsIGosIHBvdzIsIHN1bTIsIHQsIHdwciwgcmVwID0gMCwgaSA9IDAsIGsgPSAwLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZCA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMCA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcbiAgfVxuICBpZiAoc2QgPT0gbnVsbCkge1xuICAgIGV4dGVybmFsID0gZmFsc2U7XG4gICAgd3ByID0gcHI7XG4gIH0gZWxzZSB7XG4gICAgd3ByID0gc2Q7XG4gIH1cbiAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xuICB3aGlsZSAoeC5lID4gLTIpIHtcbiAgICB4ID0geC50aW1lcyh0KTtcbiAgICBrICs9IDU7XG4gIH1cbiAgZ3VhcmQgPSBNYXRoLmxvZyhtYXRocG93KDIsIGspKSAvIE1hdGguTE4xMCAqIDIgKyA1IHwgMDtcbiAgd3ByICs9IGd1YXJkO1xuICBkZW5vbWluYXRvciA9IHBvdzIgPSBzdW0yID0gbmV3IEN0b3IoMSk7XG4gIEN0b3IucHJlY2lzaW9uID0gd3ByO1xuICBmb3IgKDsgOyApIHtcbiAgICBwb3cyID0gZmluYWxpc2UocG93Mi50aW1lcyh4KSwgd3ByLCAxKTtcbiAgICBkZW5vbWluYXRvciA9IGRlbm9taW5hdG9yLnRpbWVzKCsraSk7XG4gICAgdCA9IHN1bTIucGx1cyhkaXZpZGUocG93MiwgZGVub21pbmF0b3IsIHdwciwgMSkpO1xuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bTIuZCkuc2xpY2UoMCwgd3ByKSkge1xuICAgICAgaiA9IGs7XG4gICAgICB3aGlsZSAoai0tKSBzdW0yID0gZmluYWxpc2Uoc3VtMi50aW1lcyhzdW0yKSwgd3ByLCAxKTtcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXAgPCAzICYmIGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtMi5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSAxMDtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdzIgPSB0ID0gbmV3IEN0b3IoMSk7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgcmVwKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bTIsIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xuICAgICAgICByZXR1cm4gc3VtMjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VtMiA9IHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcbiAgdmFyIGMsIGMwLCBkZW5vbWluYXRvciwgZSwgbnVtZXJhdG9yLCByZXAsIHN1bTIsIHQsIHdwciwgeDEsIHgyLCBuID0gMSwgZ3VhcmQgPSAxMCwgeCA9IHksIHhkID0geC5kLCBDdG9yID0geC5jb25zdHJ1Y3Rvciwgcm0gPSBDdG9yLnJvdW5kaW5nLCBwciA9IEN0b3IucHJlY2lzaW9uO1xuICBpZiAoeC5zIDwgMCB8fCAheGQgfHwgIXhkWzBdIHx8ICF4LmUgJiYgeGRbMF0gPT0gMSAmJiB4ZC5sZW5ndGggPT0gMSkge1xuICAgIHJldHVybiBuZXcgQ3Rvcih4ZCAmJiAheGRbMF0gPyAtMSAvIDAgOiB4LnMgIT0gMSA/IE5hTiA6IHhkID8gMCA6IHgpO1xuICB9XG4gIGlmIChzZCA9PSBudWxsKSB7XG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICB3cHIgPSBwcjtcbiAgfSBlbHNlIHtcbiAgICB3cHIgPSBzZDtcbiAgfVxuICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcbiAgYzAgPSBjLmNoYXJBdCgwKTtcbiAgaWYgKE1hdGguYWJzKGUgPSB4LmUpIDwgMTVlMTQpIHtcbiAgICB3aGlsZSAoYzAgPCA3ICYmIGMwICE9IDEgfHwgYzAgPT0gMSAmJiBjLmNoYXJBdCgxKSA+IDMpIHtcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xuICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XG4gICAgICBjMCA9IGMuY2hhckF0KDApO1xuICAgICAgbisrO1xuICAgIH1cbiAgICBlID0geC5lO1xuICAgIGlmIChjMCA+IDEpIHtcbiAgICAgIHggPSBuZXcgQ3RvcihcIjAuXCIgKyBjKTtcbiAgICAgIGUrKztcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IG5ldyBDdG9yKGMwICsgXCIuXCIgKyBjLnNsaWNlKDEpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKTtcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArIFwiLlwiICsgYy5zbGljZSgxKSksIHdwciAtIGd1YXJkKS5wbHVzKHQpO1xuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xuICB9XG4gIHgxID0geDtcbiAgc3VtMiA9IG51bWVyYXRvciA9IHggPSBkaXZpZGUoeC5taW51cygxKSwgeC5wbHVzKDEpLCB3cHIsIDEpO1xuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gIGRlbm9taW5hdG9yID0gMztcbiAgZm9yICg7IDsgKSB7XG4gICAgbnVtZXJhdG9yID0gZmluYWxpc2UobnVtZXJhdG9yLnRpbWVzKHgyKSwgd3ByLCAxKTtcbiAgICB0ID0gc3VtMi5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtMi5kKS5zbGljZSgwLCB3cHIpKSB7XG4gICAgICBzdW0yID0gc3VtMi50aW1lcygyKTtcbiAgICAgIGlmIChlICE9PSAwKSBzdW0yID0gc3VtMi5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyBcIlwiKSk7XG4gICAgICBzdW0yID0gZGl2aWRlKHN1bTIsIG5ldyBDdG9yKG4pLCB3cHIsIDEpO1xuICAgICAgaWYgKHNkID09IG51bGwpIHtcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtMi5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcbiAgICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcbiAgICAgICAgICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSByZXAgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0yLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcbiAgICAgICAgcmV0dXJuIHN1bTI7XG4gICAgICB9XG4gICAgfVxuICAgIHN1bTIgPSB0O1xuICAgIGRlbm9taW5hdG9yICs9IDI7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vbkZpbml0ZVRvU3RyaW5nKHgpIHtcbiAgcmV0dXJuIFN0cmluZyh4LnMgKiB4LnMgLyAwKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRGVjaW1hbCh4LCBzdHIpIHtcbiAgdmFyIGUsIGksIGxlbjtcbiAgaWYgKChlID0gc3RyLmluZGV4T2YoXCIuXCIpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZShcIi5cIiwgXCJcIik7XG4gIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xuICAgIGlmIChlIDwgMCkgZSA9IGk7XG4gICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xuICB9IGVsc2UgaWYgKGUgPCAwKSB7XG4gICAgZSA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspIDtcbiAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdChsZW4gLSAxKSA9PT0gNDg7IC0tbGVuKSA7XG4gIHN0ciA9IHN0ci5zbGljZShpLCBsZW4pO1xuICBpZiAoc3RyKSB7XG4gICAgbGVuIC09IGk7XG4gICAgeC5lID0gZSA9IGUgLSBpIC0gMTtcbiAgICB4LmQgPSBbXTtcbiAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xuICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTtcbiAgICBpZiAoaSA8IGxlbikge1xuICAgICAgaWYgKGkpIHguZC5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xuICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47ICkgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XG4gICAgICBzdHIgPSBzdHIuc2xpY2UoaSk7XG4gICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpIC09IGxlbjtcbiAgICB9XG4gICAgZm9yICg7IGktLTsgKSBzdHIgKz0gXCIwXCI7XG4gICAgeC5kLnB1c2goK3N0cik7XG4gICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICBpZiAoeC5lID4geC5jb25zdHJ1Y3Rvci5tYXhFKSB7XG4gICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIHguZSA9IE5hTjtcbiAgICAgIH0gZWxzZSBpZiAoeC5lIDwgeC5jb25zdHJ1Y3Rvci5taW5FKSB7XG4gICAgICAgIHguZSA9IDA7XG4gICAgICAgIHguZCA9IFswXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgeC5lID0gMDtcbiAgICB4LmQgPSBbMF07XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBwYXJzZU90aGVyKHgsIHN0cikge1xuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XG4gIGlmIChzdHIuaW5kZXhPZihcIl9cIikgPiAtMSkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csIFwiJDFcIik7XG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpIHJldHVybiBwYXJzZURlY2ltYWwoeCwgc3RyKTtcbiAgfSBlbHNlIGlmIChzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiTmFOXCIpIHtcbiAgICBpZiAoIStzdHIpIHgucyA9IE5hTjtcbiAgICB4LmUgPSBOYU47XG4gICAgeC5kID0gbnVsbDtcbiAgICByZXR1cm4geDtcbiAgfVxuICBpZiAoaXNIZXgudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDE2O1xuICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkge1xuICAgIGJhc2UgPSAyO1xuICB9IGVsc2UgaWYgKGlzT2N0YWwudGVzdChzdHIpKSB7XG4gICAgYmFzZSA9IDg7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcbiAgfVxuICBpID0gc3RyLnNlYXJjaCgvcC9pKTtcbiAgaWYgKGkgPiAwKSB7XG4gICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMiwgaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xuICB9XG4gIGkgPSBzdHIuaW5kZXhPZihcIi5cIik7XG4gIGlzRmxvYXQgPSBpID49IDA7XG4gIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xuICBpZiAoaXNGbG9hdCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGkgPSBsZW4gLSBpO1xuICAgIGRpdmlzb3IgPSBpbnRQb3coQ3RvciwgbmV3IEN0b3IoYmFzZSksIGksIGkgKiAyKTtcbiAgfVxuICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XG4gIHhlID0geGQubGVuZ3RoIC0gMTtcbiAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpIHhkLnBvcCgpO1xuICBpZiAoaSA8IDApIHJldHVybiBuZXcgQ3Rvcih4LnMgKiAwKTtcbiAgeC5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIHhlKTtcbiAgeC5kID0geGQ7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGlmIChpc0Zsb2F0KSB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xuICBpZiAocCkgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBzaW5lKEN0b3IsIHgpIHtcbiAgdmFyIGssIGxlbiA9IHguZC5sZW5ndGg7XG4gIGlmIChsZW4gPCAzKSB7XG4gICAgcmV0dXJuIHguaXNaZXJvKCkgPyB4IDogdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xuICB9XG4gIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcbiAgayA9IGsgPiAxNiA/IDE2IDogayB8IDA7XG4gIHggPSB4LnRpbWVzKDEgLyB0aW55UG93KDUsIGspKTtcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcbiAgdmFyIHNpbjJfeCwgZDUgPSBuZXcgQ3Rvcig1KSwgZDE2ID0gbmV3IEN0b3IoMTYpLCBkMjAgPSBuZXcgQ3RvcigyMCk7XG4gIGZvciAoOyBrLS07ICkge1xuICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XG4gICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW4yX3gudGltZXMoZDE2LnRpbWVzKHNpbjJfeCkubWludXMoZDIwKSkpKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHRheWxvclNlcmllcyhDdG9yLCBuLCB4LCB5LCBpc0h5cGVyYm9saWMpIHtcbiAgdmFyIGosIHQsIHUsIHgyLCBpID0gMSwgcHIgPSBDdG9yLnByZWNpc2lvbiwgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgeDIgPSB4LnRpbWVzKHgpO1xuICB1ID0gbmV3IEN0b3IoeSk7XG4gIGZvciAoOyA7ICkge1xuICAgIHQgPSBkaXZpZGUodS50aW1lcyh4MiksIG5ldyBDdG9yKG4rKyAqIG4rKyksIHByLCAxKTtcbiAgICB1ID0gaXNIeXBlcmJvbGljID8geS5wbHVzKHQpIDogeS5taW51cyh0KTtcbiAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XG4gICAgdCA9IHUucGx1cyh5KTtcbiAgICBpZiAodC5kW2tdICE9PSB2b2lkIDApIHtcbiAgICAgIGZvciAoaiA9IGs7IHQuZFtqXSA9PT0gdS5kW2pdICYmIGotLTsgKSA7XG4gICAgICBpZiAoaiA9PSAtMSkgYnJlYWs7XG4gICAgfVxuICAgIGogPSB1O1xuICAgIHUgPSB5O1xuICAgIHkgPSB0O1xuICAgIHQgPSBqO1xuICAgIGkrKztcbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHQuZC5sZW5ndGggPSBrICsgMTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcbiAgdmFyIG4gPSBiO1xuICB3aGlsZSAoLS1lKSBuICo9IGI7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XG4gIHZhciB0LCBpc05lZyA9IHgucyA8IDAsIHBpID0gZ2V0UGkoQ3RvciwgQ3Rvci5wcmVjaXNpb24sIDEpLCBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xuICB4ID0geC5hYnMoKTtcbiAgaWYgKHgubHRlKGhhbGZQaSkpIHtcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gNCA6IDE7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdCA9IHguZGl2VG9JbnQocGkpO1xuICBpZiAodC5pc1plcm8oKSkge1xuICAgIHF1YWRyYW50ID0gaXNOZWcgPyAzIDogMjtcbiAgfSBlbHNlIHtcbiAgICB4ID0geC5taW51cyh0LnRpbWVzKHBpKSk7XG4gICAgaWYgKHgubHRlKGhhbGZQaSkpIHtcbiAgICAgIHF1YWRyYW50ID0gaXNPZGQodCkgPyBpc05lZyA/IDIgOiAzIDogaXNOZWcgPyA0IDogMTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBxdWFkcmFudCA9IGlzT2RkKHQpID8gaXNOZWcgPyAxIDogNCA6IGlzTmVnID8gMyA6IDI7XG4gIH1cbiAgcmV0dXJuIHgubWludXMocGkpLmFicygpO1xufVxuZnVuY3Rpb24gdG9TdHJpbmdCaW5hcnkoeCwgYmFzZU91dCwgc2QsIHJtKSB7XG4gIHZhciBiYXNlLCBlLCBpLCBrLCBsZW4sIHJvdW5kVXAsIHN0ciwgeGQsIHksIEN0b3IgPSB4LmNvbnN0cnVjdG9yLCBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XG4gIGlmIChpc0V4cCkge1xuICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xuICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcbiAgfSBlbHNlIHtcbiAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcbiAgfVxuICBpZiAoIXguaXNGaW5pdGUoKSkge1xuICAgIHN0ciA9IG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xuICAgIGkgPSBzdHIuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGlzRXhwKSB7XG4gICAgICBiYXNlID0gMjtcbiAgICAgIGlmIChiYXNlT3V0ID09IDE2KSB7XG4gICAgICAgIHNkID0gc2QgKiA0IC0gMztcbiAgICAgIH0gZWxzZSBpZiAoYmFzZU91dCA9PSA4KSB7XG4gICAgICAgIHNkID0gc2QgKiAzIC0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9IGJhc2VPdXQ7XG4gICAgfVxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICAgIHkgPSBuZXcgQ3RvcigxKTtcbiAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xuICAgICAgeS5kID0gY29udmVydEJhc2UoZmluaXRlVG9TdHJpbmcoeSksIDEwLCBiYXNlKTtcbiAgICAgIHkuZSA9IHkuZC5sZW5ndGg7XG4gICAgfVxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCAxMCwgYmFzZSk7XG4gICAgZSA9IGxlbiA9IHhkLmxlbmd0aDtcbiAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7ICkgeGQucG9wKCk7XG4gICAgaWYgKCF4ZFswXSkge1xuICAgICAgc3RyID0gaXNFeHAgPyBcIjBwKzBcIiA6IFwiMFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgZS0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xuICAgICAgICB4LmQgPSB4ZDtcbiAgICAgICAgeC5lID0gZTtcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xuICAgICAgICB4ZCA9IHguZDtcbiAgICAgICAgZSA9IHguZTtcbiAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XG4gICAgICB9XG4gICAgICBpID0geGRbc2RdO1xuICAgICAgayA9IGJhc2UgLyAyO1xuICAgICAgcm91bmRVcCA9IHJvdW5kVXAgfHwgeGRbc2QgKyAxXSAhPT0gdm9pZCAwO1xuICAgICAgcm91bmRVcCA9IHJtIDwgNCA/IChpICE9PSB2b2lkIDAgfHwgcm91bmRVcCkgJiYgKHJtID09PSAwIHx8IHJtID09PSAoeC5zIDwgMCA/IDMgOiAyKSkgOiBpID4gayB8fCBpID09PSBrICYmIChybSA9PT0gNCB8fCByb3VuZFVwIHx8IHJtID09PSA2ICYmIHhkW3NkIC0gMV0gJiAxIHx8IHJtID09PSAoeC5zIDwgMCA/IDggOiA3KSk7XG4gICAgICB4ZC5sZW5ndGggPSBzZDtcbiAgICAgIGlmIChyb3VuZFVwKSB7XG4gICAgICAgIGZvciAoOyArK3hkWy0tc2RdID4gYmFzZSAtIDE7ICkge1xuICAgICAgICAgIHhkW3NkXSA9IDA7XG4gICAgICAgICAgaWYgKCFzZCkge1xuICAgICAgICAgICAgKytlO1xuICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKSA7XG4gICAgICBmb3IgKGkgPSAwLCBzdHIgPSBcIlwiOyBpIDwgbGVuOyBpKyspIHN0ciArPSBOVU1FUkFMUy5jaGFyQXQoeGRbaV0pO1xuICAgICAgaWYgKGlzRXhwKSB7XG4gICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XG4gICAgICAgICAgICBpID0gYmFzZU91dCA9PSAxNiA/IDQgOiAzO1xuICAgICAgICAgICAgZm9yICgtLWxlbjsgbGVuICUgaTsgbGVuKyspIHN0ciArPSBcIjBcIjtcbiAgICAgICAgICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBiYXNlT3V0KTtcbiAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKSA7XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBzdHIgPSBcIjEuXCI7IGkgPCBsZW47IGkrKykgc3RyICs9IE5VTUVSQUxTLmNoYXJBdCh4ZFtpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyBcIi5cIiArIHN0ci5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyICsgKGUgPCAwID8gXCJwXCIgOiBcInArXCIpICsgZTtcbiAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcbiAgICAgICAgZm9yICg7ICsrZTsgKSBzdHIgPSBcIjBcIiArIHN0cjtcbiAgICAgICAgc3RyID0gXCIwLlwiICsgc3RyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCsrZSA+IGxlbikgZm9yIChlIC09IGxlbjsgZS0tOyApIHN0ciArPSBcIjBcIjtcbiAgICAgICAgZWxzZSBpZiAoZSA8IGxlbikgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgXCIuXCIgKyBzdHIuc2xpY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gXCIweFwiIDogYmFzZU91dCA9PSAyID8gXCIwYlwiIDogYmFzZU91dCA9PSA4ID8gXCIwb1wiIDogXCJcIikgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHgucyA8IDAgPyBcIi1cIiArIHN0ciA6IHN0cjtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlKGFyciwgbGVuKSB7XG4gIGlmIChhcnIubGVuZ3RoID4gbGVuKSB7XG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYWJzKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFicygpO1xufVxuZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zKCk7XG59XG5mdW5jdGlvbiBhY29zaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5hY29zaCgpO1xufVxuZnVuY3Rpb24gYWRkKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBsdXMoeSk7XG59XG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW4oKTtcbn1cbmZ1bmN0aW9uIGFzaW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW5oKCk7XG59XG5mdW5jdGlvbiBhdGFuKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW4oKTtcbn1cbmZ1bmN0aW9uIGF0YW5oKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW5oKCk7XG59XG5mdW5jdGlvbiBhdGFuMih5LCB4KSB7XG4gIHkgPSBuZXcgdGhpcyh5KTtcbiAgeCA9IG5ldyB0aGlzKHgpO1xuICB2YXIgciwgcHIgPSB0aGlzLnByZWNpc2lvbiwgcm0gPSB0aGlzLnJvdW5kaW5nLCB3cHIgPSBwciArIDQ7XG4gIGlmICgheS5zIHx8ICF4LnMpIHtcbiAgICByID0gbmV3IHRoaXMoTmFOKTtcbiAgfSBlbHNlIGlmICgheS5kICYmICF4LmQpIHtcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xuICAgIHIucyA9IHkucztcbiAgfSBlbHNlIGlmICgheC5kIHx8IHkuaXNaZXJvKCkpIHtcbiAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoIXkuZCB8fCB4LmlzWmVybygpKSB7XG4gICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcbiAgICByLnMgPSB5LnM7XG4gIH0gZWxzZSBpZiAoeC5zIDwgMCkge1xuICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xuICAgIHRoaXMucm91bmRpbmcgPSAxO1xuICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xuICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xuICAgIHRoaXMucHJlY2lzaW9uID0gcHI7XG4gICAgdGhpcy5yb3VuZGluZyA9IHJtO1xuICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcbiAgfSBlbHNlIHtcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGNicnQoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY2JydCgpO1xufVxuZnVuY3Rpb24gY2VpbCh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDIpO1xufVxuZnVuY3Rpb24gY2xhbXAoeCwgbWluMiwgbWF4Mikge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuY2xhbXAobWluMiwgbWF4Mik7XG59XG5mdW5jdGlvbiBjb25maWcob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArIFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICB2YXIgaSwgcCwgdiwgdXNlRGVmYXVsdHMgPSBvYmouZGVmYXVsdHMgPT09IHRydWUsIHBzID0gW1xuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgMSxcbiAgICBNQVhfRElHSVRTLFxuICAgIFwicm91bmRpbmdcIixcbiAgICAwLFxuICAgIDgsXG4gICAgXCJ0b0V4cE5lZ1wiLFxuICAgIC1FWFBfTElNSVQsXG4gICAgMCxcbiAgICBcInRvRXhwUG9zXCIsXG4gICAgMCxcbiAgICBFWFBfTElNSVQsXG4gICAgXCJtYXhFXCIsXG4gICAgMCxcbiAgICBFWFBfTElNSVQsXG4gICAgXCJtaW5FXCIsXG4gICAgLUVYUF9MSU1JVCxcbiAgICAwLFxuICAgIFwibW9kdWxvXCIsXG4gICAgMCxcbiAgICA5XG4gIF07XG4gIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGlmIChwID0gcHNbaV0sIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XG4gICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKSB0aGlzW3BdID0gdjtcbiAgICAgIGVsc2UgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArIFwiOiBcIiArIHYpO1xuICAgIH1cbiAgfVxuICBpZiAocCA9IFwiY3J5cHRvXCIsIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XG4gIGlmICgodiA9IG9ialtwXSkgIT09IHZvaWQgMCkge1xuICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xuICAgICAgaWYgKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gXCJ1bmRlZmluZWRcIiAmJiBjcnlwdG8gJiYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xuICAgICAgICAgIHRoaXNbcF0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgXCI6IFwiICsgdik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gY29zKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xufVxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5jb3NoKCk7XG59XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgdmFyIGksIHAsIHBzO1xuICBmdW5jdGlvbiBEZWNpbWFsMih2KSB7XG4gICAgdmFyIGUsIGkyLCB0LCB4ID0gdGhpcztcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgRGVjaW1hbDIpKSByZXR1cm4gbmV3IERlY2ltYWwyKHYpO1xuICAgIHguY29uc3RydWN0b3IgPSBEZWNpbWFsMjtcbiAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcbiAgICAgIHgucyA9IHYucztcbiAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICBpZiAoIXYuZCB8fCB2LmUgPiBEZWNpbWFsMi5tYXhFKSB7XG4gICAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICAgIHguZCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgRGVjaW1hbDIubWluRSkge1xuICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHguZSA9IHYuZTtcbiAgICAgICAgICB4LmQgPSB2LmQuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC5lID0gdi5lO1xuICAgICAgICB4LmQgPSB2LmQgPyB2LmQuc2xpY2UoKSA6IHYuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdCA9IHR5cGVvZiB2O1xuICAgIGlmICh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAtMSA6IDE7XG4gICAgICAgIHguZSA9IDA7XG4gICAgICAgIHguZCA9IFswXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgeC5zID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4LnMgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHYgPT09IH5+diAmJiB2IDwgMWU3KSB7XG4gICAgICAgIGZvciAoZSA9IDAsIGkyID0gdjsgaTIgPj0gMTA7IGkyIC89IDEwKSBlKys7XG4gICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgIGlmIChlID4gRGVjaW1hbDIubWF4RSkge1xuICAgICAgICAgICAgeC5lID0gTmFOO1xuICAgICAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGUgPCBEZWNpbWFsMi5taW5FKSB7XG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5kID0gWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgICAgeC5kID0gW3ZdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4LmUgPSBlO1xuICAgICAgICAgIHguZCA9IFt2XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodiAqIDAgIT09IDApIHtcbiAgICAgICAgaWYgKCF2KSB4LnMgPSBOYU47XG4gICAgICAgIHguZSA9IE5hTjtcbiAgICAgICAgeC5kID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlRGVjaW1hbCh4LCB2LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKChpMiA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7XG4gICAgICAgIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgICB4LnMgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpMiA9PT0gNDMpIHYgPSB2LnNsaWNlKDEpO1xuICAgICAgICB4LnMgPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcbiAgICB9XG4gICAgaWYgKHQgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gLXY7XG4gICAgICAgIHgucyA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeC5zID0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XG4gIH1cbiAgRGVjaW1hbDIucHJvdG90eXBlID0gUDtcbiAgRGVjaW1hbDIuUk9VTkRfVVAgPSAwO1xuICBEZWNpbWFsMi5ST1VORF9ET1dOID0gMTtcbiAgRGVjaW1hbDIuUk9VTkRfQ0VJTCA9IDI7XG4gIERlY2ltYWwyLlJPVU5EX0ZMT09SID0gMztcbiAgRGVjaW1hbDIuUk9VTkRfSEFMRl9VUCA9IDQ7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XG4gIERlY2ltYWwyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xuICBEZWNpbWFsMi5FVUNMSUQgPSA5O1xuICBEZWNpbWFsMi5jb25maWcgPSBEZWNpbWFsMi5zZXQgPSBjb25maWc7XG4gIERlY2ltYWwyLmNsb25lID0gY2xvbmU7XG4gIERlY2ltYWwyLmlzRGVjaW1hbCA9IGlzRGVjaW1hbEluc3RhbmNlO1xuICBEZWNpbWFsMi5hYnMgPSBhYnM7XG4gIERlY2ltYWwyLmFjb3MgPSBhY29zO1xuICBEZWNpbWFsMi5hY29zaCA9IGFjb3NoO1xuICBEZWNpbWFsMi5hZGQgPSBhZGQ7XG4gIERlY2ltYWwyLmFzaW4gPSBhc2luO1xuICBEZWNpbWFsMi5hc2luaCA9IGFzaW5oO1xuICBEZWNpbWFsMi5hdGFuID0gYXRhbjtcbiAgRGVjaW1hbDIuYXRhbmggPSBhdGFuaDtcbiAgRGVjaW1hbDIuYXRhbjIgPSBhdGFuMjtcbiAgRGVjaW1hbDIuY2JydCA9IGNicnQ7XG4gIERlY2ltYWwyLmNlaWwgPSBjZWlsO1xuICBEZWNpbWFsMi5jbGFtcCA9IGNsYW1wO1xuICBEZWNpbWFsMi5jb3MgPSBjb3M7XG4gIERlY2ltYWwyLmNvc2ggPSBjb3NoO1xuICBEZWNpbWFsMi5kaXYgPSBkaXY7XG4gIERlY2ltYWwyLmV4cCA9IGV4cDtcbiAgRGVjaW1hbDIuZmxvb3IgPSBmbG9vcjtcbiAgRGVjaW1hbDIuaHlwb3QgPSBoeXBvdDtcbiAgRGVjaW1hbDIubG4gPSBsbjtcbiAgRGVjaW1hbDIubG9nID0gbG9nO1xuICBEZWNpbWFsMi5sb2cxMCA9IGxvZzEwO1xuICBEZWNpbWFsMi5sb2cyID0gbG9nMjtcbiAgRGVjaW1hbDIubWF4ID0gbWF4O1xuICBEZWNpbWFsMi5taW4gPSBtaW47XG4gIERlY2ltYWwyLm1vZCA9IG1vZDtcbiAgRGVjaW1hbDIubXVsID0gbXVsO1xuICBEZWNpbWFsMi5wb3cgPSBwb3c7XG4gIERlY2ltYWwyLnJhbmRvbSA9IHJhbmRvbTtcbiAgRGVjaW1hbDIucm91bmQgPSByb3VuZDtcbiAgRGVjaW1hbDIuc2lnbiA9IHNpZ247XG4gIERlY2ltYWwyLnNpbiA9IHNpbjtcbiAgRGVjaW1hbDIuc2luaCA9IHNpbmg7XG4gIERlY2ltYWwyLnNxcnQgPSBzcXJ0O1xuICBEZWNpbWFsMi5zdWIgPSBzdWI7XG4gIERlY2ltYWwyLnN1bSA9IHN1bTtcbiAgRGVjaW1hbDIudGFuID0gdGFuO1xuICBEZWNpbWFsMi50YW5oID0gdGFuaDtcbiAgRGVjaW1hbDIudHJ1bmMgPSB0cnVuYztcbiAgaWYgKG9iaiA9PT0gdm9pZCAwKSBvYmogPSB7fTtcbiAgaWYgKG9iaikge1xuICAgIGlmIChvYmouZGVmYXVsdHMgIT09IHRydWUpIHtcbiAgICAgIHBzID0gW1wicHJlY2lzaW9uXCIsIFwicm91bmRpbmdcIiwgXCJ0b0V4cE5lZ1wiLCBcInRvRXhwUG9zXCIsIFwibWF4RVwiLCBcIm1pbkVcIiwgXCJtb2R1bG9cIiwgXCJjcnlwdG9cIl07XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyApIGlmICghb2JqLmhhc093blByb3BlcnR5KHAgPSBwc1tpKytdKSkgb2JqW3BdID0gdGhpc1twXTtcbiAgICB9XG4gIH1cbiAgRGVjaW1hbDIuY29uZmlnKG9iaik7XG4gIHJldHVybiBEZWNpbWFsMjtcbn1cbmZ1bmN0aW9uIGRpdih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5kaXYoeSk7XG59XG5mdW5jdGlvbiBleHAoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkuZXhwKCk7XG59XG5mdW5jdGlvbiBmbG9vcih4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDMpO1xufVxuZnVuY3Rpb24gaHlwb3QoKSB7XG4gIHZhciBpLCBuLCB0ID0gbmV3IHRoaXMoMCk7XG4gIGV4dGVybmFsID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyApIHtcbiAgICBuID0gbmV3IHRoaXMoYXJndW1lbnRzW2krK10pO1xuICAgIGlmICghbi5kKSB7XG4gICAgICBpZiAobi5zKSB7XG4gICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKDEgLyAwKTtcbiAgICAgIH1cbiAgICAgIHQgPSBuO1xuICAgIH0gZWxzZSBpZiAodC5kKSB7XG4gICAgICB0ID0gdC5wbHVzKG4udGltZXMobikpO1xuICAgIH1cbiAgfVxuICBleHRlcm5hbCA9IHRydWU7XG4gIHJldHVybiB0LnNxcnQoKTtcbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRGVjaW1hbCB8fCBvYmogJiYgb2JqLnRvU3RyaW5nVGFnID09PSB0YWcgfHwgZmFsc2U7XG59XG5mdW5jdGlvbiBsbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5sbigpO1xufVxuZnVuY3Rpb24gbG9nKHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZyh5KTtcbn1cbmZ1bmN0aW9uIGxvZzIoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDIpO1xufVxuZnVuY3Rpb24gbG9nMTAoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubG9nKDEwKTtcbn1cbmZ1bmN0aW9uIG1heCgpIHtcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgLTEpO1xufVxuZnVuY3Rpb24gbWluKCkge1xuICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAxKTtcbn1cbmZ1bmN0aW9uIG1vZCh4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5tb2QoeSk7XG59XG5mdW5jdGlvbiBtdWwoeCwgeSkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xufVxuZnVuY3Rpb24gcG93KHgsIHkpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbShzZCkge1xuICB2YXIgZCwgZSwgaywgbiwgaSA9IDAsIHIgPSBuZXcgdGhpcygxKSwgcmQgPSBbXTtcbiAgaWYgKHNkID09PSB2b2lkIDApIHNkID0gdGhpcy5wcmVjaXNpb247XG4gIGVsc2UgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XG4gIGsgPSBNYXRoLmNlaWwoc2QgLyBMT0dfQkFTRSk7XG4gIGlmICghdGhpcy5jcnlwdG8pIHtcbiAgICBmb3IgKDsgaSA8IGs7ICkgcmRbaSsrXSA9IE1hdGgucmFuZG9tKCkgKiAxZTcgfCAwO1xuICB9IGVsc2UgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICBkID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoaykpO1xuICAgIGZvciAoOyBpIDwgazsgKSB7XG4gICAgICBuID0gZFtpXTtcbiAgICAgIGlmIChuID49IDQyOWU3KSB7XG4gICAgICAgIGRbaV0gPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZFtpKytdID0gbiAlIDFlNztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XG4gICAgZCA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDQpO1xuICAgIGZvciAoOyBpIDwgazsgKSB7XG4gICAgICBuID0gZFtpXSArIChkW2kgKyAxXSA8PCA4KSArIChkW2kgKyAyXSA8PCAxNikgKyAoKGRbaSArIDNdICYgMTI3KSA8PCAyNCk7XG4gICAgICBpZiAobiA+PSAyMTRlNykge1xuICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkuY29weShkLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkLnB1c2gobiAlIDFlNyk7XG4gICAgICAgIGkgKz0gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGsgLyA0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcbiAgfVxuICBrID0gcmRbLS1pXTtcbiAgc2QgJT0gTE9HX0JBU0U7XG4gIGlmIChrICYmIHNkKSB7XG4gICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xuICAgIHJkW2ldID0gKGsgLyBuIHwgMCkgKiBuO1xuICB9XG4gIGZvciAoOyByZFtpXSA9PT0gMDsgaS0tKSByZC5wb3AoKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgZSA9IDA7XG4gICAgcmQgPSBbMF07XG4gIH0gZWxzZSB7XG4gICAgZSA9IC0xO1xuICAgIGZvciAoOyByZFswXSA9PT0gMDsgZSAtPSBMT0dfQkFTRSkgcmQuc2hpZnQoKTtcbiAgICBmb3IgKGsgPSAxLCBuID0gcmRbMF07IG4gPj0gMTA7IG4gLz0gMTApIGsrKztcbiAgICBpZiAoayA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaztcbiAgfVxuICByLmUgPSBlO1xuICByLmQgPSByZDtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiByb3VuZCh4KSB7XG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xufVxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHggPSBuZXcgdGhpcyh4KTtcbiAgcmV0dXJuIHguZCA/IHguZFswXSA/IHgucyA6IDAgKiB4LnMgOiB4LnMgfHwgTmFOO1xufVxuZnVuY3Rpb24gc2luKHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbigpO1xufVxuZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XG59XG5mdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNxcnQoKTtcbn1cbmZ1bmN0aW9uIHN1Yih4LCB5KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XG59XG5mdW5jdGlvbiBzdW0oKSB7XG4gIHZhciBpID0gMCwgYXJncyA9IGFyZ3VtZW50cywgeCA9IG5ldyB0aGlzKGFyZ3NbaV0pO1xuICBleHRlcm5hbCA9IGZhbHNlO1xuICBmb3IgKDsgeC5zICYmICsraSA8IGFyZ3MubGVuZ3RoOyApIHggPSB4LnBsdXMoYXJnc1tpXSk7XG4gIGV4dGVybmFsID0gdHJ1ZTtcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIHRoaXMucHJlY2lzaW9uLCB0aGlzLnJvdW5kaW5nKTtcbn1cbmZ1bmN0aW9uIHRhbih4KSB7XG4gIHJldHVybiBuZXcgdGhpcyh4KS50YW4oKTtcbn1cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gbmV3IHRoaXMoeCkudGFuaCgpO1xufVxuZnVuY3Rpb24gdHJ1bmMoeCkge1xuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAxKTtcbn1cblBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSA9IFAudG9TdHJpbmc7XG5QW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIkRlY2ltYWxcIjtcbnZhciBEZWNpbWFsID0gUC5jb25zdHJ1Y3RvciA9IGNsb25lKERFRkFVTFRTKTtcbkxOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcblBJID0gbmV3IERlY2ltYWwoUEkpO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3FsLXRlbXBsYXRlLXRhZ0A1LjIuMS9ub2RlX21vZHVsZXMvc3FsLXRlbXBsYXRlLXRhZy9kaXN0L2luZGV4LmpzXG52YXIgU3FsID0gY2xhc3MgX1NxbCB7XG4gIGNvbnN0cnVjdG9yKHJhd1N0cmluZ3MsIHJhd1ZhbHVlcykge1xuICAgIGlmIChyYXdTdHJpbmdzLmxlbmd0aCAtIDEgIT09IHJhd1ZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChyYXdTdHJpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgMSBzdHJpbmdcIik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAke3Jhd1N0cmluZ3MubGVuZ3RofSBzdHJpbmdzIHRvIGhhdmUgJHtyYXdTdHJpbmdzLmxlbmd0aCAtIDF9IHZhbHVlc2ApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXNMZW5ndGggPSByYXdWYWx1ZXMucmVkdWNlKChsZW4sIHZhbHVlKSA9PiBsZW4gKyAodmFsdWUgaW5zdGFuY2VvZiBfU3FsID8gdmFsdWUudmFsdWVzLmxlbmd0aCA6IDEpLCAwKTtcbiAgICB0aGlzLnZhbHVlcyA9IG5ldyBBcnJheSh2YWx1ZXNMZW5ndGgpO1xuICAgIHRoaXMuc3RyaW5ncyA9IG5ldyBBcnJheSh2YWx1ZXNMZW5ndGggKyAxKTtcbiAgICB0aGlzLnN0cmluZ3NbMF0gPSByYXdTdHJpbmdzWzBdO1xuICAgIGxldCBpID0gMCwgcG9zID0gMDtcbiAgICB3aGlsZSAoaSA8IHJhd1ZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gcmF3VmFsdWVzW2krK107XG4gICAgICBjb25zdCByYXdTdHJpbmcgPSByYXdTdHJpbmdzW2ldO1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgX1NxbCkge1xuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSArPSBjaGlsZC5zdHJpbmdzWzBdO1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChjaGlsZEluZGV4IDwgY2hpbGQudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudmFsdWVzW3BvcysrXSA9IGNoaWxkLnZhbHVlc1tjaGlsZEluZGV4KytdO1xuICAgICAgICAgIHRoaXMuc3RyaW5nc1twb3NdID0gY2hpbGQuc3RyaW5nc1tjaGlsZEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmluZ3NbcG9zXSArPSByYXdTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlc1twb3MrK10gPSBjaGlsZDtcbiAgICAgICAgdGhpcy5zdHJpbmdzW3Bvc10gPSByYXdTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBzcWwoKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5zdHJpbmdzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDE7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zdHJpbmdzWzBdO1xuICAgIHdoaWxlIChpIDwgbGVuKVxuICAgICAgdmFsdWUgKz0gYD8ke3RoaXMuc3RyaW5nc1tpKytdfWA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGdldCBzdGF0ZW1lbnQoKSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5zdHJpbmdzLmxlbmd0aDtcbiAgICBsZXQgaSA9IDE7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zdHJpbmdzWzBdO1xuICAgIHdoaWxlIChpIDwgbGVuKVxuICAgICAgdmFsdWUgKz0gYDoke2l9JHt0aGlzLnN0cmluZ3NbaSsrXX1gO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnN0cmluZ3MubGVuZ3RoO1xuICAgIGxldCBpID0gMTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnN0cmluZ3NbMF07XG4gICAgd2hpbGUgKGkgPCBsZW4pXG4gICAgICB2YWx1ZSArPSBgJCR7aX0ke3RoaXMuc3RyaW5nc1tpKytdfWA7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNxbDogdGhpcy5zcWwsXG4gICAgICBzdGF0ZW1lbnQ6IHRoaXMuc3RhdGVtZW50LFxuICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBqb2luKHZhbHVlcywgc2VwYXJhdG9yID0gXCIsXCIsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIpIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYGpvaW4oW10pYCB0byBiZSBjYWxsZWQgd2l0aCBhbiBhcnJheSBvZiBtdWx0aXBsZSBlbGVtZW50cywgYnV0IGdvdCBhbiBlbXB0eSBhcnJheVwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFNxbChbcHJlZml4LCAuLi5BcnJheSh2YWx1ZXMubGVuZ3RoIC0gMSkuZmlsbChzZXBhcmF0b3IpLCBzdWZmaXhdLCB2YWx1ZXMpO1xufVxuZnVuY3Rpb24gcmF3KHZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3FsKFt2YWx1ZV0sIFtdKTtcbn1cbnZhciBlbXB0eSA9IHJhdyhcIlwiKTtcbmZ1bmN0aW9uIHNxbChzdHJpbmdzLCAuLi52YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTcWwoc3RyaW5ncywgdmFsdWVzKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBBbnlOdWxsLFxuICBBbnlOdWxsQ2xhc3MsXG4gIERiTnVsbCxcbiAgRGJOdWxsQ2xhc3MsXG4gIERlY2ltYWwsXG4gIEpzb25OdWxsLFxuICBKc29uTnVsbENsYXNzLFxuICBOdWxsVHlwZXMsXG4gIE9iamVjdEVudW1WYWx1ZSxcbiAgUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvcixcbiAgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFJ1c3RFcnJvcixcbiAgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IsXG4gIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IsXG4gIFByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvcixcbiAgU3FsLFxuICBlbXB0eSxcbiAgaGFzQmF0Y2hJbmRleCxcbiAgaXNBbnlOdWxsLFxuICBpc0RiTnVsbCxcbiAgaXNKc29uTnVsbCxcbiAgam9pbixcbiAgcmF3LFxuICBzcWxcbn0pO1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuZGVjaW1hbC5qcy9kZWNpbWFsLm1qczpcbiAgKCohXG4gICAqICBkZWNpbWFsLmpzIHYxMC41LjBcbiAgICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxuICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xuICAgKiAgQ29weXJpZ2h0IChjKSAyMDI1IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XG4gICAqICBNSVQgTGljZW5jZVxuICAgKilcbiovXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/@prisma+client-runtime-utils@7.1.0/node_modules/@prisma/client-runtime-utils/dist/index.js\n");

/***/ })

};
;