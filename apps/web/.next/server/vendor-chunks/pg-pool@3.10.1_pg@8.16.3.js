"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool@3.10.1_pg@8.16.3";
exports.ids = ["vendor-chunks/pg-pool@3.10.1_pg@8.16.3"];
exports.modules = {

/***/ "(api-node)/../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter)\n\nconst NOOP = function () {}\n\nconst removeWhere = (list, predicate) => {\n  const i = list.findIndex(predicate)\n\n  return i === -1 ? undefined : list.splice(i, 1)[0]\n}\n\nclass IdleItem {\n  constructor(client, idleListener, timeoutId) {\n    this.client = client\n    this.idleListener = idleListener\n    this.timeoutId = timeoutId\n  }\n}\n\nclass PendingItem {\n  constructor(callback) {\n    this.callback = callback\n  }\n}\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.')\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return { callback: callback, result: undefined }\n  }\n  let rej\n  let res\n  const cb = function (err, client) {\n    err ? rej(err) : res(client)\n  }\n  const result = new Promise(function (resolve, reject) {\n    res = resolve\n    rej = reject\n  }).catch((err) => {\n    // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n    // application that created the query\n    Error.captureStackTrace(err)\n    throw err\n  })\n  return { callback: cb, result: result }\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client\n\n    client.removeListener('error', idleListener)\n    client.on('error', () => {\n      pool.log('additional client error after disconnection due to error', err)\n    })\n    pool._remove(client)\n    // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n    pool.emit('error', err, client)\n  }\n}\n\nclass Pool extends EventEmitter {\n  constructor(options, Client) {\n    super()\n    this.options = Object.assign({}, options)\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password,\n      })\n    }\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(this.options.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this.options.max = this.options.max || this.options.poolSize || 10\n    this.options.min = this.options.min || 0\n    this.options.maxUses = this.options.maxUses || Infinity\n    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false\n    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0\n    this.log = this.options.log || function () {}\n    this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(api-node)/../../node_modules/.pnpm/pg@8.16.3/node_modules/pg/lib/index.js\").Client)\n    this.Promise = this.options.Promise || global.Promise\n\n    if (typeof this.options.idleTimeoutMillis === 'undefined') {\n      this.options.idleTimeoutMillis = 10000\n    }\n\n    this._clients = []\n    this._idle = []\n    this._expired = new WeakSet()\n    this._pendingQueue = []\n    this._endCallback = undefined\n    this.ending = false\n    this.ended = false\n  }\n\n  _isFull() {\n    return this._clients.length >= this.options.max\n  }\n\n  _isAboveMin() {\n    return this._clients.length > this.options.min\n  }\n\n  _pulseQueue() {\n    this.log('pulse queue')\n    if (this.ended) {\n      this.log('pulse queue ended')\n      return\n    }\n    if (this.ending) {\n      this.log('pulse queue on ending')\n      if (this._idle.length) {\n        this._idle.slice().map((item) => {\n          this._remove(item.client)\n        })\n      }\n      if (!this._clients.length) {\n        this.ended = true\n        this._endCallback()\n      }\n      return\n    }\n\n    // if we don't have any waiting, do nothing\n    if (!this._pendingQueue.length) {\n      this.log('no queued requests')\n      return\n    }\n    // if we don't have any idle clients and we have no more room do nothing\n    if (!this._idle.length && this._isFull()) {\n      return\n    }\n    const pendingItem = this._pendingQueue.shift()\n    if (this._idle.length) {\n      const idleItem = this._idle.pop()\n      clearTimeout(idleItem.timeoutId)\n      const client = idleItem.client\n      client.ref && client.ref()\n      const idleListener = idleItem.idleListener\n\n      return this._acquireClient(client, pendingItem, idleListener, false)\n    }\n    if (!this._isFull()) {\n      return this.newClient(pendingItem)\n    }\n    throw new Error('unexpected condition')\n  }\n\n  _remove(client, callback) {\n    const removed = removeWhere(this._idle, (item) => item.client === client)\n\n    if (removed !== undefined) {\n      clearTimeout(removed.timeoutId)\n    }\n\n    this._clients = this._clients.filter((c) => c !== client)\n    const context = this\n    client.end(() => {\n      context.emit('remove', client)\n\n      if (typeof callback === 'function') {\n        callback()\n      }\n    })\n  }\n\n  connect(cb) {\n    if (this.ending) {\n      const err = new Error('Cannot use a pool after calling end on the pool')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n\n    const response = promisify(this.Promise, cb)\n    const result = response.result\n\n    // if we don't have to connect a new client, don't do so\n    if (this._isFull() || this._idle.length) {\n      // if we have idle clients schedule a pulse immediately\n      if (this._idle.length) {\n        process.nextTick(() => this._pulseQueue())\n      }\n\n      if (!this.options.connectionTimeoutMillis) {\n        this._pendingQueue.push(new PendingItem(response.callback))\n        return result\n      }\n\n      const queueCallback = (err, res, done) => {\n        clearTimeout(tid)\n        response.callback(err, res, done)\n      }\n\n      const pendingItem = new PendingItem(queueCallback)\n\n      // set connection timeout on checking out an existing client\n      const tid = setTimeout(() => {\n        // remove the callback from pending waiters because\n        // we're going to call it with a timeout error\n        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)\n        pendingItem.timedOut = true\n        response.callback(new Error('timeout exceeded when trying to connect'))\n      }, this.options.connectionTimeoutMillis)\n\n      if (tid.unref) {\n        tid.unref()\n      }\n\n      this._pendingQueue.push(pendingItem)\n      return result\n    }\n\n    this.newClient(new PendingItem(response.callback))\n\n    return result\n  }\n\n  newClient(pendingItem) {\n    const client = new this.Client(this.options)\n    this._clients.push(client)\n    const idleListener = makeIdleListener(this, client)\n\n    this.log('checking client timeout')\n\n    // connection timeout logic\n    let tid\n    let timeoutHit = false\n    if (this.options.connectionTimeoutMillis) {\n      tid = setTimeout(() => {\n        this.log('ending client due to timeout')\n        timeoutHit = true\n        // force kill the node driver, and let libpq do its teardown\n        client.connection ? client.connection.stream.destroy() : client.end()\n      }, this.options.connectionTimeoutMillis)\n    }\n\n    this.log('connecting new client')\n    client.connect((err) => {\n      if (tid) {\n        clearTimeout(tid)\n      }\n      client.on('error', idleListener)\n      if (err) {\n        this.log('client failed to connect', err)\n        // remove the dead client from our list of clients\n        this._clients = this._clients.filter((c) => c !== client)\n        if (timeoutHit) {\n          err = new Error('Connection terminated due to connection timeout', { cause: err })\n        }\n\n        // this client wonâ€™t be released, so move on immediately\n        this._pulseQueue()\n\n        if (!pendingItem.timedOut) {\n          pendingItem.callback(err, undefined, NOOP)\n        }\n      } else {\n        this.log('new client connected')\n\n        if (this.options.maxLifetimeSeconds !== 0) {\n          const maxLifetimeTimeout = setTimeout(() => {\n            this.log('ending client due to expired lifetime')\n            this._expired.add(client)\n            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)\n            if (idleIndex !== -1) {\n              this._acquireClient(\n                client,\n                new PendingItem((err, client, clientRelease) => clientRelease()),\n                idleListener,\n                false\n              )\n            }\n          }, this.options.maxLifetimeSeconds * 1000)\n\n          maxLifetimeTimeout.unref()\n          client.once('end', () => clearTimeout(maxLifetimeTimeout))\n        }\n\n        return this._acquireClient(client, pendingItem, idleListener, true)\n      }\n    })\n  }\n\n  // acquire a client for a pending work item\n  _acquireClient(client, pendingItem, idleListener, isNew) {\n    if (isNew) {\n      this.emit('connect', client)\n    }\n\n    this.emit('acquire', client)\n\n    client.release = this._releaseOnce(client, idleListener)\n\n    client.removeListener('error', idleListener)\n\n    if (!pendingItem.timedOut) {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, (err) => {\n          if (err) {\n            client.release(err)\n            return pendingItem.callback(err, undefined, NOOP)\n          }\n\n          pendingItem.callback(undefined, client, client.release)\n        })\n      } else {\n        pendingItem.callback(undefined, client, client.release)\n      }\n    } else {\n      if (isNew && this.options.verify) {\n        this.options.verify(client, client.release)\n      } else {\n        client.release()\n      }\n    }\n  }\n\n  // returns a function that wraps _release and throws if called more than once\n  _releaseOnce(client, idleListener) {\n    let released = false\n\n    return (err) => {\n      if (released) {\n        throwOnDoubleRelease()\n      }\n\n      released = true\n      this._release(client, idleListener, err)\n    }\n  }\n\n  // release a client back to the poll, include an error\n  // to remove it from the pool\n  _release(client, idleListener, err) {\n    client.on('error', idleListener)\n\n    client._poolUseCount = (client._poolUseCount || 0) + 1\n\n    this.emit('release', err, client)\n\n    // TODO(bmc): expose a proper, public interface _queryable and _ending\n    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n      if (client._poolUseCount >= this.options.maxUses) {\n        this.log('remove expended client')\n      }\n\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    const isExpired = this._expired.has(client)\n    if (isExpired) {\n      this.log('remove expired client')\n      this._expired.delete(client)\n      return this._remove(client, this._pulseQueue.bind(this))\n    }\n\n    // idle timeout\n    let tid\n    if (this.options.idleTimeoutMillis && this._isAboveMin()) {\n      tid = setTimeout(() => {\n        this.log('remove idle client')\n        this._remove(client, this._pulseQueue.bind(this))\n      }, this.options.idleTimeoutMillis)\n\n      if (this.options.allowExitOnIdle) {\n        // allow Node to exit if this is all that's left\n        tid.unref()\n      }\n    }\n\n    if (this.options.allowExitOnIdle) {\n      client.unref()\n    }\n\n    this._idle.push(new IdleItem(client, idleListener, tid))\n    this._pulseQueue()\n  }\n\n  query(text, values, cb) {\n    // guard clause against passing a function as the first parameter\n    if (typeof text === 'function') {\n      const response = promisify(this.Promise, text)\n      setImmediate(function () {\n        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))\n      })\n      return response.result\n    }\n\n    // allow plain text query without values\n    if (typeof values === 'function') {\n      cb = values\n      values = undefined\n    }\n    const response = promisify(this.Promise, cb)\n    cb = response.callback\n\n    this.connect((err, client) => {\n      if (err) {\n        return cb(err)\n      }\n\n      let clientReleased = false\n      const onError = (err) => {\n        if (clientReleased) {\n          return\n        }\n        clientReleased = true\n        client.release(err)\n        cb(err)\n      }\n\n      client.once('error', onError)\n      this.log('dispatching query')\n      try {\n        client.query(text, values, (err, res) => {\n          this.log('query dispatched')\n          client.removeListener('error', onError)\n          if (clientReleased) {\n            return\n          }\n          clientReleased = true\n          client.release(err)\n          if (err) {\n            return cb(err)\n          }\n          return cb(undefined, res)\n        })\n      } catch (err) {\n        client.release(err)\n        return cb(err)\n      }\n    })\n    return response.result\n  }\n\n  end(cb) {\n    this.log('ending')\n    if (this.ending) {\n      const err = new Error('Called end on pool more than once')\n      return cb ? cb(err) : this.Promise.reject(err)\n    }\n    this.ending = true\n    const promised = promisify(this.Promise, cb)\n    this._endCallback = promised.callback\n    this._pulseQueue()\n    return promised.result\n  }\n\n  get waitingCount() {\n    return this._pendingQueue.length\n  }\n\n  get idleCount() {\n    return this._idle.length\n  }\n\n  get expiredCount() {\n    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)\n  }\n\n  get totalCount() {\n    return this._clients.length\n  }\n}\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGctcG9vbEAzLjEwLjFfcGdAOC4xNi4zL25vZGVfbW9kdWxlcy9wZy1wb29sL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1oscUJBQXFCLDBEQUE4Qjs7QUFFbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvSEFBb0I7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsWUFBWTtBQUMzRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYXNsYWsvcmVwb3MvcGxhbi1lYXQtcmVwZWF0L25vZGVfbW9kdWxlcy8ucG5wbS9wZy1wb29sQDMuMTAuMV9wZ0A4LjE2LjMvbm9kZV9tb2R1bGVzL3BnLXBvb2wvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcblxuY29uc3QgTk9PUCA9IGZ1bmN0aW9uICgpIHt9XG5cbmNvbnN0IHJlbW92ZVdoZXJlID0gKGxpc3QsIHByZWRpY2F0ZSkgPT4ge1xuICBjb25zdCBpID0gbGlzdC5maW5kSW5kZXgocHJlZGljYXRlKVxuXG4gIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IGxpc3Quc3BsaWNlKGksIDEpWzBdXG59XG5cbmNsYXNzIElkbGVJdGVtIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBpZGxlTGlzdGVuZXIsIHRpbWVvdXRJZCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5pZGxlTGlzdGVuZXIgPSBpZGxlTGlzdGVuZXJcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHRpbWVvdXRJZFxuICB9XG59XG5cbmNsYXNzIFBlbmRpbmdJdGVtIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd09uRG91YmxlUmVsZWFzZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWxlYXNlIGNhbGxlZCBvbiBjbGllbnQgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiByZWxlYXNlZCB0byB0aGUgcG9vbC4nKVxufVxuXG5mdW5jdGlvbiBwcm9taXNpZnkoUHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHsgY2FsbGJhY2s6IGNhbGxiYWNrLCByZXN1bHQ6IHVuZGVmaW5lZCB9XG4gIH1cbiAgbGV0IHJlalxuICBsZXQgcmVzXG4gIGNvbnN0IGNiID0gZnVuY3Rpb24gKGVyciwgY2xpZW50KSB7XG4gICAgZXJyID8gcmVqKGVycikgOiByZXMoY2xpZW50KVxuICB9XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXMgPSByZXNvbHZlXG4gICAgcmVqID0gcmVqZWN0XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAvLyByZXBsYWNlIHRoZSBzdGFjayB0cmFjZSB0aGF0IGxlYWRzIHRvIGBUQ1Aub25TdHJlYW1SZWFkYCB3aXRoIG9uZSB0aGF0IGxlYWRzIGJhY2sgdG8gdGhlXG4gICAgLy8gYXBwbGljYXRpb24gdGhhdCBjcmVhdGVkIHRoZSBxdWVyeVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycilcbiAgICB0aHJvdyBlcnJcbiAgfSlcbiAgcmV0dXJuIHsgY2FsbGJhY2s6IGNiLCByZXN1bHQ6IHJlc3VsdCB9XG59XG5cbmZ1bmN0aW9uIG1ha2VJZGxlTGlzdGVuZXIocG9vbCwgY2xpZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpZGxlTGlzdGVuZXIoZXJyKSB7XG4gICAgZXJyLmNsaWVudCA9IGNsaWVudFxuXG4gICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICBjbGllbnQub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgcG9vbC5sb2coJ2FkZGl0aW9uYWwgY2xpZW50IGVycm9yIGFmdGVyIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGVycm9yJywgZXJyKVxuICAgIH0pXG4gICAgcG9vbC5fcmVtb3ZlKGNsaWVudClcbiAgICAvLyBUT0RPIC0gZG9jdW1lbnQgdGhhdCBvbmNlIHRoZSBwb29sIGVtaXRzIGFuIGVycm9yXG4gICAgLy8gdGhlIGNsaWVudCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCAmIHB1cmdlZCBhbmQgaXMgdW51c2FibGVcbiAgICBwb29sLmVtaXQoJ2Vycm9yJywgZXJyLCBjbGllbnQpXG4gIH1cbn1cblxuY2xhc3MgUG9vbCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIENsaWVudCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAncGFzc3dvcmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHBhc3N3b3JkIHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsICdwYXNzd29yZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLnBhc3N3b3JkLFxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnNzbCAmJiBvcHRpb25zLnNzbC5rZXkpIHtcbiAgICAgIC8vIFwiaGlkaW5nXCIgdGhlIHNzbC0+a2V5IHNvIGl0IGRvZXNuJ3Qgc2hvdyB1cCBpbiBzdGFjayB0cmFjZXNcbiAgICAgIC8vIG9yIGlmIHRoZSBjbGllbnQgaXMgY29uc29sZS5sb2dnZWRcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLm9wdGlvbnMuc3NsLCAna2V5Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zLm1heCA9IHRoaXMub3B0aW9ucy5tYXggfHwgdGhpcy5vcHRpb25zLnBvb2xTaXplIHx8IDEwXG4gICAgdGhpcy5vcHRpb25zLm1pbiA9IHRoaXMub3B0aW9ucy5taW4gfHwgMFxuICAgIHRoaXMub3B0aW9ucy5tYXhVc2VzID0gdGhpcy5vcHRpb25zLm1heFVzZXMgfHwgSW5maW5pdHlcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlID0gdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSB8fCBmYWxzZVxuICAgIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgPSB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzIHx8IDBcbiAgICB0aGlzLmxvZyA9IHRoaXMub3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24gKCkge31cbiAgICB0aGlzLkNsaWVudCA9IHRoaXMub3B0aW9ucy5DbGllbnQgfHwgQ2xpZW50IHx8IHJlcXVpcmUoJ3BnJykuQ2xpZW50XG4gICAgdGhpcy5Qcm9taXNlID0gdGhpcy5vcHRpb25zLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2VcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID0gMTAwMDBcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gW11cbiAgICB0aGlzLl9pZGxlID0gW11cbiAgICB0aGlzLl9leHBpcmVkID0gbmV3IFdlYWtTZXQoKVxuICAgIHRoaXMuX3BlbmRpbmdRdWV1ZSA9IFtdXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlXG4gIH1cblxuICBfaXNGdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4XG4gIH1cblxuICBfaXNBYm92ZU1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWluXG4gIH1cblxuICBfcHVsc2VRdWV1ZSgpIHtcbiAgICB0aGlzLmxvZygncHVsc2UgcXVldWUnKVxuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygncHVsc2UgcXVldWUgZW5kZWQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIG9uIGVuZGluZycpXG4gICAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faWRsZS5zbGljZSgpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZShpdGVtLmNsaWVudClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fY2xpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgd2FpdGluZywgZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ25vIHF1ZXVlZCByZXF1ZXN0cycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgaWRsZSBjbGllbnRzIGFuZCB3ZSBoYXZlIG5vIG1vcmUgcm9vbSBkbyBub3RoaW5nXG4gICAgaWYgKCF0aGlzLl9pZGxlLmxlbmd0aCAmJiB0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gdGhpcy5fcGVuZGluZ1F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGlkbGVJdGVtID0gdGhpcy5faWRsZS5wb3AoKVxuICAgICAgY2xlYXJUaW1lb3V0KGlkbGVJdGVtLnRpbWVvdXRJZClcbiAgICAgIGNvbnN0IGNsaWVudCA9IGlkbGVJdGVtLmNsaWVudFxuICAgICAgY2xpZW50LnJlZiAmJiBjbGllbnQucmVmKClcbiAgICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IGlkbGVJdGVtLmlkbGVMaXN0ZW5lclxuXG4gICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGZhbHNlKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDbGllbnQocGVuZGluZ0l0ZW0pXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjb25kaXRpb24nKVxuICB9XG5cbiAgX3JlbW92ZShjbGllbnQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZVdoZXJlKHRoaXMuX2lkbGUsIChpdGVtKSA9PiBpdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuXG4gICAgaWYgKHJlbW92ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlbW92ZWQudGltZW91dElkKVxuICAgIH1cblxuICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLmZpbHRlcigoYykgPT4gYyAhPT0gY2xpZW50KVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzXG4gICAgY2xpZW50LmVuZCgoKSA9PiB7XG4gICAgICBjb250ZXh0LmVtaXQoJ3JlbW92ZScsIGNsaWVudClcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGNvbm5lY3QoY2IpIHtcbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2Fubm90IHVzZSBhIHBvb2wgYWZ0ZXIgY2FsbGluZyBlbmQgb24gdGhlIHBvb2wnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY29uc3QgcmVzdWx0ID0gcmVzcG9uc2UucmVzdWx0XG5cbiAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRvIGNvbm5lY3QgYSBuZXcgY2xpZW50LCBkb24ndCBkbyBzb1xuICAgIGlmICh0aGlzLl9pc0Z1bGwoKSB8fCB0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBpZGxlIGNsaWVudHMgc2NoZWR1bGUgYSBwdWxzZSBpbW1lZGlhdGVseVxuICAgICAgaWYgKHRoaXMuX2lkbGUubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5fcHVsc2VRdWV1ZSgpKVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcykge1xuICAgICAgICB0aGlzLl9wZW5kaW5nUXVldWUucHVzaChuZXcgUGVuZGluZ0l0ZW0ocmVzcG9uc2UuY2FsbGJhY2spKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXVlQ2FsbGJhY2sgPSAoZXJyLCByZXMsIGRvbmUpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpZClcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2soZXJyLCByZXMsIGRvbmUpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gbmV3IFBlbmRpbmdJdGVtKHF1ZXVlQ2FsbGJhY2spXG5cbiAgICAgIC8vIHNldCBjb25uZWN0aW9uIHRpbWVvdXQgb24gY2hlY2tpbmcgb3V0IGFuIGV4aXN0aW5nIGNsaWVudFxuICAgICAgY29uc3QgdGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBwZW5kaW5nIHdhaXRlcnMgYmVjYXVzZVxuICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byBjYWxsIGl0IHdpdGggYSB0aW1lb3V0IGVycm9yXG4gICAgICAgIHJlbW92ZVdoZXJlKHRoaXMuX3BlbmRpbmdRdWV1ZSwgKGkpID0+IGkuY2FsbGJhY2sgPT09IHF1ZXVlQ2FsbGJhY2spXG4gICAgICAgIHBlbmRpbmdJdGVtLnRpbWVkT3V0ID0gdHJ1ZVxuICAgICAgICByZXNwb25zZS5jYWxsYmFjayhuZXcgRXJyb3IoJ3RpbWVvdXQgZXhjZWVkZWQgd2hlbiB0cnlpbmcgdG8gY29ubmVjdCcpKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGlkLnVucmVmKSB7XG4gICAgICAgIHRpZC51bnJlZigpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BlbmRpbmdRdWV1ZS5wdXNoKHBlbmRpbmdJdGVtKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIHRoaXMubmV3Q2xpZW50KG5ldyBQZW5kaW5nSXRlbShyZXNwb25zZS5jYWxsYmFjaykpXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBuZXdDbGllbnQocGVuZGluZ0l0ZW0pIHtcbiAgICBjb25zdCBjbGllbnQgPSBuZXcgdGhpcy5DbGllbnQodGhpcy5vcHRpb25zKVxuICAgIHRoaXMuX2NsaWVudHMucHVzaChjbGllbnQpXG4gICAgY29uc3QgaWRsZUxpc3RlbmVyID0gbWFrZUlkbGVMaXN0ZW5lcih0aGlzLCBjbGllbnQpXG5cbiAgICB0aGlzLmxvZygnY2hlY2tpbmcgY2xpZW50IHRpbWVvdXQnKVxuXG4gICAgLy8gY29ubmVjdGlvbiB0aW1lb3V0IGxvZ2ljXG4gICAgbGV0IHRpZFxuICAgIGxldCB0aW1lb3V0SGl0ID0gZmFsc2VcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzKSB7XG4gICAgICB0aWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5sb2coJ2VuZGluZyBjbGllbnQgZHVlIHRvIHRpbWVvdXQnKVxuICAgICAgICB0aW1lb3V0SGl0ID0gdHJ1ZVxuICAgICAgICAvLyBmb3JjZSBraWxsIHRoZSBub2RlIGRyaXZlciwgYW5kIGxldCBsaWJwcSBkbyBpdHMgdGVhcmRvd25cbiAgICAgICAgY2xpZW50LmNvbm5lY3Rpb24gPyBjbGllbnQuY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveSgpIDogY2xpZW50LmVuZCgpXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpXG4gICAgfVxuXG4gICAgdGhpcy5sb2coJ2Nvbm5lY3RpbmcgbmV3IGNsaWVudCcpXG4gICAgY2xpZW50LmNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgaWYgKHRpZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGlkKVxuICAgICAgfVxuICAgICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5sb2coJ2NsaWVudCBmYWlsZWQgdG8gY29ubmVjdCcsIGVycilcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBkZWFkIGNsaWVudCBmcm9tIG91ciBsaXN0IG9mIGNsaWVudHNcbiAgICAgICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuZmlsdGVyKChjKSA9PiBjICE9PSBjbGllbnQpXG4gICAgICAgIGlmICh0aW1lb3V0SGl0KSB7XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIHRlcm1pbmF0ZWQgZHVlIHRvIGNvbm5lY3Rpb24gdGltZW91dCcsIHsgY2F1c2U6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBjbGllbnQgd29u4oCZdCBiZSByZWxlYXNlZCwgc28gbW92ZSBvbiBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLl9wdWxzZVF1ZXVlKClcblxuICAgICAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nKCduZXcgY2xpZW50IGNvbm5lY3RlZCcpXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgIT09IDApIHtcbiAgICAgICAgICBjb25zdCBtYXhMaWZldGltZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlbmRpbmcgY2xpZW50IGR1ZSB0byBleHBpcmVkIGxpZmV0aW1lJylcbiAgICAgICAgICAgIHRoaXMuX2V4cGlyZWQuYWRkKGNsaWVudClcbiAgICAgICAgICAgIGNvbnN0IGlkbGVJbmRleCA9IHRoaXMuX2lkbGUuZmluZEluZGV4KChpZGxlSXRlbSkgPT4gaWRsZUl0ZW0uY2xpZW50ID09PSBjbGllbnQpXG4gICAgICAgICAgICBpZiAoaWRsZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9hY3F1aXJlQ2xpZW50KFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICBuZXcgUGVuZGluZ0l0ZW0oKGVyciwgY2xpZW50LCBjbGllbnRSZWxlYXNlKSA9PiBjbGllbnRSZWxlYXNlKCkpLFxuICAgICAgICAgICAgICAgIGlkbGVMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLm1heExpZmV0aW1lU2Vjb25kcyAqIDEwMDApXG5cbiAgICAgICAgICBtYXhMaWZldGltZVRpbWVvdXQudW5yZWYoKVxuICAgICAgICAgIGNsaWVudC5vbmNlKCdlbmQnLCAoKSA9PiBjbGVhclRpbWVvdXQobWF4TGlmZXRpbWVUaW1lb3V0KSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlQ2xpZW50KGNsaWVudCwgcGVuZGluZ0l0ZW0sIGlkbGVMaXN0ZW5lciwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gYWNxdWlyZSBhIGNsaWVudCBmb3IgYSBwZW5kaW5nIHdvcmsgaXRlbVxuICBfYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGlzTmV3KSB7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjbGllbnQpXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdhY3F1aXJlJywgY2xpZW50KVxuXG4gICAgY2xpZW50LnJlbGVhc2UgPSB0aGlzLl9yZWxlYXNlT25jZShjbGllbnQsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBpZiAoIXBlbmRpbmdJdGVtLnRpbWVkT3V0KSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgICAgIHJldHVybiBwZW5kaW5nSXRlbS5jYWxsYmFjayhlcnIsIHVuZGVmaW5lZCwgTk9PUClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nSXRlbS5jYWxsYmFjayh1bmRlZmluZWQsIGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc05ldyAmJiB0aGlzLm9wdGlvbnMudmVyaWZ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy52ZXJpZnkoY2xpZW50LCBjbGllbnQucmVsZWFzZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBfcmVsZWFzZSBhbmQgdGhyb3dzIGlmIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICBfcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpIHtcbiAgICBsZXQgcmVsZWFzZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIChlcnIpID0+IHtcbiAgICAgIGlmIChyZWxlYXNlZCkge1xuICAgICAgICB0aHJvd09uRG91YmxlUmVsZWFzZSgpXG4gICAgICB9XG5cbiAgICAgIHJlbGVhc2VkID0gdHJ1ZVxuICAgICAgdGhpcy5fcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbGVhc2UgYSBjbGllbnQgYmFjayB0byB0aGUgcG9sbCwgaW5jbHVkZSBhbiBlcnJvclxuICAvLyB0byByZW1vdmUgaXQgZnJvbSB0aGUgcG9vbFxuICBfcmVsZWFzZShjbGllbnQsIGlkbGVMaXN0ZW5lciwgZXJyKSB7XG4gICAgY2xpZW50Lm9uKCdlcnJvcicsIGlkbGVMaXN0ZW5lcilcblxuICAgIGNsaWVudC5fcG9vbFVzZUNvdW50ID0gKGNsaWVudC5fcG9vbFVzZUNvdW50IHx8IDApICsgMVxuXG4gICAgdGhpcy5lbWl0KCdyZWxlYXNlJywgZXJyLCBjbGllbnQpXG5cbiAgICAvLyBUT0RPKGJtYyk6IGV4cG9zZSBhIHByb3BlciwgcHVibGljIGludGVyZmFjZSBfcXVlcnlhYmxlIGFuZCBfZW5kaW5nXG4gICAgaWYgKGVyciB8fCB0aGlzLmVuZGluZyB8fCAhY2xpZW50Ll9xdWVyeWFibGUgfHwgY2xpZW50Ll9lbmRpbmcgfHwgY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgIGlmIChjbGllbnQuX3Bvb2xVc2VDb3VudCA+PSB0aGlzLm9wdGlvbnMubWF4VXNlcykge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGV4cGVuZGVkIGNsaWVudCcpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUoY2xpZW50LCB0aGlzLl9wdWxzZVF1ZXVlLmJpbmQodGhpcykpXG4gICAgfVxuXG4gICAgY29uc3QgaXNFeHBpcmVkID0gdGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHRoaXMubG9nKCdyZW1vdmUgZXhwaXJlZCBjbGllbnQnKVxuICAgICAgdGhpcy5fZXhwaXJlZC5kZWxldGUoY2xpZW50KVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShjbGllbnQsIHRoaXMuX3B1bHNlUXVldWUuYmluZCh0aGlzKSlcbiAgICB9XG5cbiAgICAvLyBpZGxlIHRpbWVvdXRcbiAgICBsZXQgdGlkXG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcyAmJiB0aGlzLl9pc0Fib3ZlTWluKCkpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGlkbGUgY2xpZW50JylcbiAgICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudCwgdGhpcy5fcHVsc2VRdWV1ZS5iaW5kKHRoaXMpKVxuICAgICAgfSwgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzKVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgICAvLyBhbGxvdyBOb2RlIHRvIGV4aXQgaWYgdGhpcyBpcyBhbGwgdGhhdCdzIGxlZnRcbiAgICAgICAgdGlkLnVucmVmKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSkge1xuICAgICAgY2xpZW50LnVucmVmKClcbiAgICB9XG5cbiAgICB0aGlzLl9pZGxlLnB1c2gobmV3IElkbGVJdGVtKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aWQpKVxuICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICB9XG5cbiAgcXVlcnkodGV4dCwgdmFsdWVzLCBjYikge1xuICAgIC8vIGd1YXJkIGNsYXVzZSBhZ2FpbnN0IHBhc3NpbmcgYSBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIHRleHQpXG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCdQYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBwb29sLnF1ZXJ5IGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgcGxhaW4gdGV4dCBxdWVyeSB3aXRob3V0IHZhbHVlc1xuICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHZhbHVlc1xuICAgICAgdmFsdWVzID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gcHJvbWlzaWZ5KHRoaXMuUHJvbWlzZSwgY2IpXG4gICAgY2IgPSByZXNwb25zZS5jYWxsYmFja1xuXG4gICAgdGhpcy5jb25uZWN0KChlcnIsIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBsZXQgY2xpZW50UmVsZWFzZWQgPSBmYWxzZVxuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgY2IoZXJyKVxuICAgICAgfVxuXG4gICAgICBjbGllbnQub25jZSgnZXJyb3InLCBvbkVycm9yKVxuICAgICAgdGhpcy5sb2coJ2Rpc3BhdGNoaW5nIHF1ZXJ5JylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsaWVudC5xdWVyeSh0ZXh0LCB2YWx1ZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIHRoaXMubG9nKCdxdWVyeSBkaXNwYXRjaGVkJylcbiAgICAgICAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgICBpZiAoY2xpZW50UmVsZWFzZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBjbGllbnRSZWxlYXNlZCA9IHRydWVcbiAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNiKHVuZGVmaW5lZCwgcmVzKVxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNsaWVudC5yZWxlYXNlKGVycilcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHRcbiAgfVxuXG4gIGVuZChjYikge1xuICAgIHRoaXMubG9nKCdlbmRpbmcnKVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYWxsZWQgZW5kIG9uIHBvb2wgbW9yZSB0aGFuIG9uY2UnKVxuICAgICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHRoaXMuUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgIH1cbiAgICB0aGlzLmVuZGluZyA9IHRydWVcbiAgICBjb25zdCBwcm9taXNlZCA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIHRoaXMuX2VuZENhbGxiYWNrID0gcHJvbWlzZWQuY2FsbGJhY2tcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgICByZXR1cm4gcHJvbWlzZWQucmVzdWx0XG4gIH1cblxuICBnZXQgd2FpdGluZ0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nUXVldWUubGVuZ3RoXG4gIH1cblxuICBnZXQgaWRsZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pZGxlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGV4cGlyZWRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5yZWR1Y2UoKGFjYywgY2xpZW50KSA9PiBhY2MgKyAodGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KSA/IDEgOiAwKSwgMClcbiAgfVxuXG4gIGdldCB0b3RhbENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/../../node_modules/.pnpm/pg-pool@3.10.1_pg@8.16.3/node_modules/pg-pool/index.js\n");

/***/ })

};
;